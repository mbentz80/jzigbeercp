#line 1 "numpy/core/src/scalartypes.inc.src"

/*
 *****************************************************************************
 **       This file was autogenerated from a template  DO NOT EDIT!!!!      **
 **       Changes should be made to the original source (.src) file         **
 *****************************************************************************
 */

#line 1
/* -*- c -*- */

#ifndef _MULTIARRAYMODULE
#define _MULTIARRAYMODULE
#endif
#include "numpy/arrayscalars.h"

static PyBoolScalarObject _PyArrayScalar_BoolValues[2] = {
    {PyObject_HEAD_INIT(&PyBoolArrType_Type) 0},
    {PyObject_HEAD_INIT(&PyBoolArrType_Type) 1},
};

/* Inheritance established later when tp_bases is set (or tp_base for
   single inheritance) */

#line 21

static PyTypeObject PyNumberArrType_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                /*ob_size*/
    "numpy.number",                   /*tp_name*/
    sizeof(PyObject),                 /*tp_basicsize*/
};

#line 21

static PyTypeObject PyIntegerArrType_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                /*ob_size*/
    "numpy.integer",                   /*tp_name*/
    sizeof(PyObject),                 /*tp_basicsize*/
};

#line 21

static PyTypeObject PySignedIntegerArrType_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                /*ob_size*/
    "numpy.signedinteger",                   /*tp_name*/
    sizeof(PyObject),                 /*tp_basicsize*/
};

#line 21

static PyTypeObject PyUnsignedIntegerArrType_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                /*ob_size*/
    "numpy.unsignedinteger",                   /*tp_name*/
    sizeof(PyObject),                 /*tp_basicsize*/
};

#line 21

static PyTypeObject PyInexactArrType_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                /*ob_size*/
    "numpy.inexact",                   /*tp_name*/
    sizeof(PyObject),                 /*tp_basicsize*/
};

#line 21

static PyTypeObject PyFloatingArrType_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                /*ob_size*/
    "numpy.floating",                   /*tp_name*/
    sizeof(PyObject),                 /*tp_basicsize*/
};

#line 21

static PyTypeObject PyComplexFloatingArrType_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                /*ob_size*/
    "numpy.complexfloating",                   /*tp_name*/
    sizeof(PyObject),                 /*tp_basicsize*/
};

#line 21

static PyTypeObject PyFlexibleArrType_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                /*ob_size*/
    "numpy.flexible",                   /*tp_name*/
    sizeof(PyObject),                 /*tp_basicsize*/
};

#line 21

static PyTypeObject PyCharacterArrType_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                /*ob_size*/
    "numpy.character",                   /*tp_name*/
    sizeof(PyObject),                 /*tp_basicsize*/
};


static void *
scalar_value(PyObject *scalar, PyArray_Descr *descr)
{
    int type_num;
    int align;
    intp memloc;
    if (descr == NULL) {
        descr = PyArray_DescrFromScalar(scalar);
        type_num = descr->type_num;
        Py_DECREF(descr);
    }
    else {
        type_num = descr->type_num;
    }
    switch (type_num) {
#define CASE(ut,lt) case NPY_##ut: return &(((Py##lt##ScalarObject *)scalar)->obval)
        CASE(BOOL, Bool);
        CASE(BYTE, Byte);
        CASE(UBYTE, UByte);
        CASE(SHORT, Short);
        CASE(USHORT, UShort);
        CASE(INT, Int);
        CASE(UINT, UInt);
        CASE(LONG, Long);
        CASE(ULONG, ULong);
        CASE(LONGLONG, LongLong);
        CASE(ULONGLONG, ULongLong);
        CASE(FLOAT, Float);
        CASE(DOUBLE, Double);
        CASE(LONGDOUBLE, LongDouble);
        CASE(CFLOAT, CFloat);
        CASE(CDOUBLE, CDouble);
        CASE(CLONGDOUBLE, CLongDouble);
        CASE(OBJECT, Object);
#undef CASE
        case NPY_STRING: return (void *)PyString_AS_STRING(scalar);
        case NPY_UNICODE: return (void *)PyUnicode_AS_DATA(scalar);
        case NPY_VOID: return ((PyVoidScalarObject *)scalar)->obval;
    }

    /* Must be a user-defined type --- check to see which
       scalar it inherits from. */

#define _CHK(cls) (PyObject_IsInstance(scalar, \
            (PyObject *)&Py##cls##ArrType_Type))
#define _OBJ(lt) &(((Py##lt##ScalarObject *)scalar)->obval)
#define _IFCASE(cls) if _CHK(cls) return _OBJ(cls)

    if _CHK(Number) {
        if _CHK(Integer) {
            if _CHK(SignedInteger) {
                _IFCASE(Byte);
                _IFCASE(Short);
                _IFCASE(Int);
                _IFCASE(Long);
                _IFCASE(LongLong);
            }
            else { /* Unsigned Integer */
                _IFCASE(UByte);
                _IFCASE(UShort);
                _IFCASE(UInt);
                _IFCASE(ULong);
                _IFCASE(ULongLong);
            }
        }
        else { /* Inexact */
            if _CHK(Floating) {
                _IFCASE(Float);
                _IFCASE(Double);
                _IFCASE(LongDouble);
            }
            else { /*ComplexFloating */
                _IFCASE(CFloat);
                _IFCASE(CDouble);
                _IFCASE(CLongDouble);
            }
        }
    }
    else if _CHK(Bool) return _OBJ(Bool);
    else if _CHK(Flexible) {
        if _CHK(String) return (void *)PyString_AS_STRING(scalar);
        if _CHK(Unicode) return (void *)PyUnicode_AS_DATA(scalar);
        if _CHK(Void) return ((PyVoidScalarObject *)scalar)->obval;
    }
    else _IFCASE(Object);


    /* Use the alignment flag to figure out where the data begins
       after a PyObject_HEAD
     */
    memloc = (intp)scalar;
    memloc += sizeof(PyObject);
    /* now round-up to the nearest alignment value
     */
    align = descr->alignment;
    if (align > 1) memloc = ((memloc + align - 1)/align)*align;
    return (void *)memloc;
#undef _IFCASE
#undef _OBJ
#undef _CHK
}

/* no error checking is performed -- ctypeptr must be same type as scalar */
/* in case of flexible type, the data is not copied
   into ctypeptr which is expected to be a pointer to pointer */
/*NUMPY_API
 Convert to c-type
*/
static void
PyArray_ScalarAsCtype(PyObject *scalar, void *ctypeptr)
{
    PyArray_Descr *typecode;
    void *newptr;
    typecode = PyArray_DescrFromScalar(scalar);
    newptr = scalar_value(scalar, typecode);

    if (PyTypeNum_ISEXTENDED(typecode->type_num)) {
        void **ct = (void **)ctypeptr;
        *ct = newptr;
    } else {
        memcpy(ctypeptr, newptr, typecode->elsize);
    }
    Py_DECREF(typecode);
    return;
}

/* The output buffer must be large-enough to receive the value */
/*  Even for flexible types which is different from ScalarAsCtype
    where only a reference for flexible types is returned
*/

/* This may not work right on narrow builds for NumPy unicode scalars.
 */

/*NUMPY_API
 Cast Scalar to c-type
*/
static int
PyArray_CastScalarToCtype(PyObject *scalar, void *ctypeptr,
                          PyArray_Descr *outcode)
{
    PyArray_Descr* descr;
    PyArray_VectorUnaryFunc* castfunc;

    descr = PyArray_DescrFromScalar(scalar);
    castfunc = PyArray_GetCastFunc(descr, outcode->type_num);
    if (castfunc == NULL) return -1;
    if (PyTypeNum_ISEXTENDED(descr->type_num) ||
            PyTypeNum_ISEXTENDED(outcode->type_num)) {
        PyArrayObject *ain, *aout;

        ain = (PyArrayObject *)PyArray_FromScalar(scalar, NULL);
        if (ain == NULL) {
            Py_DECREF(descr);
            return -1;
        }
        aout = (PyArrayObject *)
            PyArray_NewFromDescr(&PyArray_Type,
                    outcode,
                    0, NULL,
                    NULL, ctypeptr,
                    CARRAY, NULL);
        if (aout == NULL) {Py_DECREF(ain); return -1;}
        castfunc(ain->data, aout->data, 1, ain, aout);
        Py_DECREF(ain);
        Py_DECREF(aout);
    }
    else {
        castfunc(scalar_value(scalar, descr), ctypeptr, 1, NULL, NULL);
    }
    Py_DECREF(descr);
    return 0;
}

/*NUMPY_API
 Cast Scalar to c-type
*/
static int
PyArray_CastScalarDirect(PyObject *scalar, PyArray_Descr *indescr,
                         void *ctypeptr, int outtype)
{
    PyArray_VectorUnaryFunc* castfunc;
    void *ptr;
    castfunc = PyArray_GetCastFunc(indescr, outtype);
    if (castfunc == NULL) return -1;
    ptr = scalar_value(scalar, indescr);
    castfunc(ptr, ctypeptr, 1, NULL, NULL);
    return 0;
}

/* 0-dim array from array-scalar object */
/* always contains a copy of the data
   unless outcode is NULL, it is of void type and the referrer does
   not own it either.
*/

/* steals reference to outcode */
/*NUMPY_API
 Get 0-dim array from scalar
*/
static PyObject *
PyArray_FromScalar(PyObject *scalar, PyArray_Descr *outcode)
{
    PyArray_Descr *typecode;
    PyObject *r;
    char *memptr;
    PyObject *ret;

    /* convert to 0-dim array of scalar typecode */
    typecode = PyArray_DescrFromScalar(scalar);
    if ((typecode->type_num == PyArray_VOID) &&
            !(((PyVoidScalarObject *)scalar)->flags & OWNDATA) &&
            outcode == NULL) {
        r = PyArray_NewFromDescr(&PyArray_Type,
                typecode,
                0, NULL, NULL,
                ((PyVoidScalarObject *)scalar)->obval,
                ((PyVoidScalarObject *)scalar)->flags,
                NULL);
        PyArray_BASE(r) = (PyObject *)scalar;
        Py_INCREF(scalar);
        return r;
    }
    r = PyArray_NewFromDescr(&PyArray_Type,
            typecode,
            0, NULL,
            NULL, NULL, 0, NULL);
    if (r==NULL) {Py_XDECREF(outcode); return NULL;}

    if (PyDataType_FLAGCHK(typecode, NPY_USE_SETITEM)) {
        if (typecode->f->setitem(scalar, PyArray_DATA(r), r) < 0) {
            Py_XDECREF(outcode); Py_DECREF(r);
            return NULL;
        }
        goto finish;
    }

    memptr = scalar_value(scalar, typecode);

#ifndef Py_UNICODE_WIDE
    if (typecode->type_num == PyArray_UNICODE) {
        PyUCS2Buffer_AsUCS4((Py_UNICODE *)memptr,
                (PyArray_UCS4 *)PyArray_DATA(r),
                PyUnicode_GET_SIZE(scalar),
                PyArray_ITEMSIZE(r) >> 2);
    } else
#endif
    {
        memcpy(PyArray_DATA(r), memptr, PyArray_ITEMSIZE(r));
        if (PyDataType_FLAGCHK(typecode, NPY_ITEM_HASOBJECT)) {
            Py_INCREF(*((PyObject **)memptr));
        }
    }

finish:
    if (outcode == NULL) return r;

    if (outcode->type_num == typecode->type_num) {
        if (!PyTypeNum_ISEXTENDED(typecode->type_num) ||
                (outcode->elsize == typecode->elsize))
            return r;
    }

    /* cast if necessary to desired output typecode */
    ret = PyArray_CastToType((PyArrayObject *)r, outcode, 0);
    Py_DECREF(r);
    return ret;
}

/*NUMPY_API
  Get an Array Scalar From a Python Object
  Returns NULL if unsuccessful but error is only
  set if another error occurred. Currently only Numeric-like
  object supported.
 */
static PyObject *
PyArray_ScalarFromObject(PyObject *object)
{
    PyObject *ret=NULL;
    if (PyArray_IsZeroDim(object)) {
        return PyArray_ToScalar(PyArray_DATA(object), object);
    }
    if (PyInt_Check(object)) {
        ret = PyArrayScalar_New(Long);
        if (ret == NULL) return NULL;
        PyArrayScalar_VAL(ret, Long) = PyInt_AS_LONG(object);
    }
    else if (PyFloat_Check(object)) {
        ret = PyArrayScalar_New(Double);
        if (ret == NULL) return NULL;
        PyArrayScalar_VAL(ret, Double) = PyFloat_AS_DOUBLE(object);
    }
    else if (PyComplex_Check(object)) {
        ret = PyArrayScalar_New(CDouble);
        if (ret == NULL) return NULL;
        PyArrayScalar_VAL(ret, CDouble).real =
                ((PyComplexObject *)object)->cval.real;
        PyArrayScalar_VAL(ret, CDouble).imag =
                ((PyComplexObject *)object)->cval.imag;
    }
    else if (PyLong_Check(object)) {
        longlong val;
        val = PyLong_AsLongLong(object);
        if (val==-1 && PyErr_Occurred()) {
            PyErr_Clear();
            return NULL;
        }
        ret = PyArrayScalar_New(LongLong);
        if (ret == NULL) return NULL;
        PyArrayScalar_VAL(ret, LongLong) = val;
    }
    else if (PyBool_Check(object)) {
        if (object == Py_True) {
            PyArrayScalar_RETURN_TRUE;
        }
        else {
            PyArrayScalar_RETURN_FALSE;
        }
    }
    return ret;
}


static PyObject *
gentype_alloc(PyTypeObject *type, Py_ssize_t nitems)
{
    PyObject *obj;
    const size_t size = _PyObject_VAR_SIZE(type, nitems+1);

    obj = (PyObject *)_pya_malloc(size);
    memset(obj, 0, size);
    if (type->tp_itemsize == 0)
        PyObject_INIT(obj, type);
    else
        (void) PyObject_INIT_VAR((PyVarObject *)obj, type, nitems);
    return obj;
}

static void
gentype_dealloc(PyObject *v)
{
    v->ob_type->tp_free(v);
}


static PyObject *
gentype_power(PyObject *m1, PyObject *m2, PyObject *m3)
{
    PyObject *arr, *ret, *arg2;
    char *msg="unsupported operand type(s) for ** or pow()";

    if (!PyArray_IsScalar(m1,Generic)) {
        if (PyArray_Check(m1)) {
            ret = m1->ob_type->tp_as_number->nb_power(m1,m2,
                    Py_None);
        }
        else {
            if (!PyArray_IsScalar(m2,Generic)) {
                PyErr_SetString(PyExc_TypeError, msg);
                return NULL;
            }
            arr = PyArray_FromScalar(m2, NULL);
            if (arr == NULL) return NULL;
            ret = arr->ob_type->tp_as_number->nb_power(m1, arr,
                    Py_None);
            Py_DECREF(arr);
        }
        return ret;
    }
    if (!PyArray_IsScalar(m2, Generic)) {
        if (PyArray_Check(m2)) {
            ret = m2->ob_type->tp_as_number->nb_power(m1,m2,
                    Py_None);
        }
        else {
            if (!PyArray_IsScalar(m1, Generic)) {
                PyErr_SetString(PyExc_TypeError, msg);
                return NULL;
            }
            arr = PyArray_FromScalar(m1, NULL);
            if (arr == NULL) return NULL;
            ret = arr->ob_type->tp_as_number->nb_power(arr, m2,
                    Py_None);
            Py_DECREF(arr);
        }
        return ret;
    }
    arr=arg2=NULL;
    arr = PyArray_FromScalar(m1, NULL);
    arg2 = PyArray_FromScalar(m2, NULL);
    if (arr == NULL || arg2 == NULL) {
        Py_XDECREF(arr); Py_XDECREF(arg2); return NULL;
    }
    ret = arr->ob_type->tp_as_number->nb_power(arr, arg2, Py_None);
    Py_DECREF(arr);
    Py_DECREF(arg2);
    return ret;
}

static PyObject *
gentype_generic_method(PyObject *self, PyObject *args, PyObject *kwds,
        char *str)
{
    PyObject *arr, *meth, *ret;

    arr = PyArray_FromScalar(self, NULL);
    if (arr == NULL) return NULL;
    meth = PyObject_GetAttrString(arr, str);
    if (meth == NULL) {Py_DECREF(arr); return NULL;}
    if (kwds == NULL)
        ret = PyObject_CallObject(meth, args);
    else
        ret = PyObject_Call(meth, args, kwds);
    Py_DECREF(meth);
    Py_DECREF(arr);
    if (ret && PyArray_Check(ret))
        return PyArray_Return((PyArrayObject *)ret);
    else
        return ret;
}

#line 455

static PyObject *
gentype_add(PyObject *m1, PyObject *m2)
{
    return PyArray_Type.tp_as_number->nb_add(m1, m2);
}


#line 455

static PyObject *
gentype_subtract(PyObject *m1, PyObject *m2)
{
    return PyArray_Type.tp_as_number->nb_subtract(m1, m2);
}


#line 455

static PyObject *
gentype_divide(PyObject *m1, PyObject *m2)
{
    return PyArray_Type.tp_as_number->nb_divide(m1, m2);
}


#line 455

static PyObject *
gentype_remainder(PyObject *m1, PyObject *m2)
{
    return PyArray_Type.tp_as_number->nb_remainder(m1, m2);
}


#line 455

static PyObject *
gentype_divmod(PyObject *m1, PyObject *m2)
{
    return PyArray_Type.tp_as_number->nb_divmod(m1, m2);
}


#line 455

static PyObject *
gentype_lshift(PyObject *m1, PyObject *m2)
{
    return PyArray_Type.tp_as_number->nb_lshift(m1, m2);
}


#line 455

static PyObject *
gentype_rshift(PyObject *m1, PyObject *m2)
{
    return PyArray_Type.tp_as_number->nb_rshift(m1, m2);
}


#line 455

static PyObject *
gentype_and(PyObject *m1, PyObject *m2)
{
    return PyArray_Type.tp_as_number->nb_and(m1, m2);
}


#line 455

static PyObject *
gentype_xor(PyObject *m1, PyObject *m2)
{
    return PyArray_Type.tp_as_number->nb_xor(m1, m2);
}


#line 455

static PyObject *
gentype_or(PyObject *m1, PyObject *m2)
{
    return PyArray_Type.tp_as_number->nb_or(m1, m2);
}


#line 455

static PyObject *
gentype_floor_divide(PyObject *m1, PyObject *m2)
{
    return PyArray_Type.tp_as_number->nb_floor_divide(m1, m2);
}


#line 455

static PyObject *
gentype_true_divide(PyObject *m1, PyObject *m2)
{
    return PyArray_Type.tp_as_number->nb_true_divide(m1, m2);
}




static PyObject *
gentype_multiply(PyObject *m1, PyObject *m2)
{
    PyObject *ret=NULL;
    long repeat;

    if (!PyArray_IsScalar(m1, Generic) &&
            ((m1->ob_type->tp_as_number == NULL) ||
             (m1->ob_type->tp_as_number->nb_multiply == NULL))) {
        /* Try to convert m2 to an int and try sequence
           repeat */
        repeat = PyInt_AsLong(m2);
        if (repeat == -1 && PyErr_Occurred()) return NULL;
        ret = PySequence_Repeat(m1, (int) repeat);
    }
    else if (!PyArray_IsScalar(m2, Generic) &&
            ((m2->ob_type->tp_as_number == NULL) ||
             (m2->ob_type->tp_as_number->nb_multiply == NULL))) {
        /* Try to convert m1 to an int and try sequence
           repeat */
        repeat = PyInt_AsLong(m1);
        if (repeat == -1 && PyErr_Occurred()) return NULL;
        ret = PySequence_Repeat(m2, (int) repeat);
    }
    if (ret==NULL) {
        PyErr_Clear(); /* no effect if not set */
        ret = PyArray_Type.tp_as_number->nb_multiply(m1, m2);
    }
    return ret;
}

#line 500

static PyObject *
gentype_positive(PyObject *m1)
{
    PyObject *arr, *ret;

    arr = PyArray_FromScalar(m1, NULL);
    if (arr == NULL) return NULL;
    ret = arr->ob_type->tp_as_number->nb_positive(arr);
    Py_DECREF(arr);
    return ret;
}

#line 500

static PyObject *
gentype_negative(PyObject *m1)
{
    PyObject *arr, *ret;

    arr = PyArray_FromScalar(m1, NULL);
    if (arr == NULL) return NULL;
    ret = arr->ob_type->tp_as_number->nb_negative(arr);
    Py_DECREF(arr);
    return ret;
}

#line 500

static PyObject *
gentype_absolute(PyObject *m1)
{
    PyObject *arr, *ret;

    arr = PyArray_FromScalar(m1, NULL);
    if (arr == NULL) return NULL;
    ret = arr->ob_type->tp_as_number->nb_absolute(arr);
    Py_DECREF(arr);
    return ret;
}

#line 500

static PyObject *
gentype_invert(PyObject *m1)
{
    PyObject *arr, *ret;

    arr = PyArray_FromScalar(m1, NULL);
    if (arr == NULL) return NULL;
    ret = arr->ob_type->tp_as_number->nb_invert(arr);
    Py_DECREF(arr);
    return ret;
}

#line 500

static PyObject *
gentype_int(PyObject *m1)
{
    PyObject *arr, *ret;

    arr = PyArray_FromScalar(m1, NULL);
    if (arr == NULL) return NULL;
    ret = arr->ob_type->tp_as_number->nb_int(arr);
    Py_DECREF(arr);
    return ret;
}

#line 500

static PyObject *
gentype_long(PyObject *m1)
{
    PyObject *arr, *ret;

    arr = PyArray_FromScalar(m1, NULL);
    if (arr == NULL) return NULL;
    ret = arr->ob_type->tp_as_number->nb_long(arr);
    Py_DECREF(arr);
    return ret;
}

#line 500

static PyObject *
gentype_float(PyObject *m1)
{
    PyObject *arr, *ret;

    arr = PyArray_FromScalar(m1, NULL);
    if (arr == NULL) return NULL;
    ret = arr->ob_type->tp_as_number->nb_float(arr);
    Py_DECREF(arr);
    return ret;
}

#line 500

static PyObject *
gentype_oct(PyObject *m1)
{
    PyObject *arr, *ret;

    arr = PyArray_FromScalar(m1, NULL);
    if (arr == NULL) return NULL;
    ret = arr->ob_type->tp_as_number->nb_oct(arr);
    Py_DECREF(arr);
    return ret;
}

#line 500

static PyObject *
gentype_hex(PyObject *m1)
{
    PyObject *arr, *ret;

    arr = PyArray_FromScalar(m1, NULL);
    if (arr == NULL) return NULL;
    ret = arr->ob_type->tp_as_number->nb_hex(arr);
    Py_DECREF(arr);
    return ret;
}


static int
gentype_nonzero_number(PyObject *m1)
{
    PyObject *arr;
    int ret;

    arr = PyArray_FromScalar(m1, NULL);
    if (arr == NULL) return -1;
    ret = arr->ob_type->tp_as_number->nb_nonzero(arr);
    Py_DECREF(arr);
    return ret;
}

static PyObject *
gentype_str(PyObject *self)
{
    PyArrayObject *arr;
    PyObject *ret;

    arr = (PyArrayObject *)PyArray_FromScalar(self, NULL);
    if (arr==NULL) return NULL;
    ret = PyObject_Str((PyObject *)arr);
    Py_DECREF(arr);
    return ret;
}


static PyObject *
gentype_repr(PyObject *self)
{
    PyArrayObject *arr;
    PyObject *ret;

    arr = (PyArrayObject *)PyArray_FromScalar(self, NULL);
    if (arr==NULL) return NULL;
    ret = PyObject_Str((PyObject *)arr);
    Py_DECREF(arr);
    return ret;
}

#line 558

#define FMT "%.*" NPY_FLOAT_FMT
#define CFMT1 "%.*" NPY_FLOAT_FMT "j"
#define CFMT2 "(%.*" NPY_FLOAT_FMT "%+.*" NPY_FLOAT_FMT "j)"

static void
format_float(char *buf, size_t buflen, float val, unsigned int prec)
{
    int cnt, i;

    cnt = PyOS_snprintf(buf, buflen, FMT, prec, val);

    /* If nothing but digits after sign, append ".0" */
    for (i = (val < 0) ? 1 : 0; i < cnt; ++i) {
        if (!isdigit(Py_CHARMASK(buf[i]))) {
            break;
        }
    }
    if (i == cnt && buflen >= cnt + 3) {
        strcpy(&buf[cnt],".0");
    }
}

static void
format_cfloat(char *buf, size_t buflen, cfloat val, unsigned int prec)
{
    if (val.real == 0.0) {
        PyOS_snprintf(buf, buflen, CFMT1, prec, val.imag);
    }
    else {
        PyOS_snprintf(buf, buflen, CFMT2, prec, val.real, prec, val.imag);
    }
}

#undef FMT
#undef CFMT1
#undef CFMT2


#line 558

#define FMT "%.*" NPY_DOUBLE_FMT
#define CFMT1 "%.*" NPY_DOUBLE_FMT "j"
#define CFMT2 "(%.*" NPY_DOUBLE_FMT "%+.*" NPY_DOUBLE_FMT "j)"

static void
format_double(char *buf, size_t buflen, double val, unsigned int prec)
{
    int cnt, i;

    cnt = PyOS_snprintf(buf, buflen, FMT, prec, val);

    /* If nothing but digits after sign, append ".0" */
    for (i = (val < 0) ? 1 : 0; i < cnt; ++i) {
        if (!isdigit(Py_CHARMASK(buf[i]))) {
            break;
        }
    }
    if (i == cnt && buflen >= cnt + 3) {
        strcpy(&buf[cnt],".0");
    }
}

static void
format_cdouble(char *buf, size_t buflen, cdouble val, unsigned int prec)
{
    if (val.real == 0.0) {
        PyOS_snprintf(buf, buflen, CFMT1, prec, val.imag);
    }
    else {
        PyOS_snprintf(buf, buflen, CFMT2, prec, val.real, prec, val.imag);
    }
}

#undef FMT
#undef CFMT1
#undef CFMT2


#line 558

#define FMT "%.*" NPY_LONGDOUBLE_FMT
#define CFMT1 "%.*" NPY_LONGDOUBLE_FMT "j"
#define CFMT2 "(%.*" NPY_LONGDOUBLE_FMT "%+.*" NPY_LONGDOUBLE_FMT "j)"

static void
format_longdouble(char *buf, size_t buflen, longdouble val, unsigned int prec)
{
    int cnt, i;

    cnt = PyOS_snprintf(buf, buflen, FMT, prec, val);

    /* If nothing but digits after sign, append ".0" */
    for (i = (val < 0) ? 1 : 0; i < cnt; ++i) {
        if (!isdigit(Py_CHARMASK(buf[i]))) {
            break;
        }
    }
    if (i == cnt && buflen >= cnt + 3) {
        strcpy(&buf[cnt],".0");
    }
}

static void
format_clongdouble(char *buf, size_t buflen, clongdouble val, unsigned int prec)
{
    if (val.real == 0.0) {
        PyOS_snprintf(buf, buflen, CFMT1, prec, val.imag);
    }
    else {
        PyOS_snprintf(buf, buflen, CFMT2, prec, val.real, prec, val.imag);
    }
}

#undef FMT
#undef CFMT1
#undef CFMT2



/* over-ride repr and str of array-scalar strings and unicode to
   remove NULL bytes and then call the corresponding functions
   of string and unicode.
 */

#line 611
static PyObject *
stringtype_repr(PyObject *self)
{
    const char *dptr, *ip;
    int len;
    PyObject *new;
    PyObject *ret;

    ip = dptr = PyString_AS_STRING(self);
    len = PyString_GET_SIZE(self);
    dptr += len-1;
    while(len > 0 && *dptr-- == 0) len--;
    new = PyString_FromStringAndSize(ip, len);
    if (new == NULL) return PyString_FromString("");
    ret = PyString_Type.tp_repr(new);
    Py_DECREF(new);
    return ret;
}

#line 611
static PyObject *
stringtype_str(PyObject *self)
{
    const char *dptr, *ip;
    int len;
    PyObject *new;
    PyObject *ret;

    ip = dptr = PyString_AS_STRING(self);
    len = PyString_GET_SIZE(self);
    dptr += len-1;
    while(len > 0 && *dptr-- == 0) len--;
    new = PyString_FromStringAndSize(ip, len);
    if (new == NULL) return PyString_FromString("");
    ret = PyString_Type.tp_str(new);
    Py_DECREF(new);
    return ret;
}

#line 611
static PyObject *
unicodetype_repr(PyObject *self)
{
    const Py_UNICODE *dptr, *ip;
    int len;
    PyObject *new;
    PyObject *ret;

    ip = dptr = PyUnicode_AS_UNICODE(self);
    len = PyUnicode_GET_SIZE(self);
    dptr += len-1;
    while(len > 0 && *dptr-- == 0) len--;
    new = PyUnicode_FromUnicode(ip, len);
    if (new == NULL) return PyString_FromString("");
    ret = PyUnicode_Type.tp_repr(new);
    Py_DECREF(new);
    return ret;
}

#line 611
static PyObject *
unicodetype_str(PyObject *self)
{
    const Py_UNICODE *dptr, *ip;
    int len;
    PyObject *new;
    PyObject *ret;

    ip = dptr = PyUnicode_AS_UNICODE(self);
    len = PyUnicode_GET_SIZE(self);
    dptr += len-1;
    while(len > 0 && *dptr-- == 0) len--;
    new = PyUnicode_FromUnicode(ip, len);
    if (new == NULL) return PyString_FromString("");
    ret = PyUnicode_Type.tp_str(new);
    Py_DECREF(new);
    return ret;
}


/* These values are finfo.precision + 2 */
#define FLOATPREC_REPR 8
#define FLOATPREC_STR 6
#define DOUBLEPREC_REPR 17
#define DOUBLEPREC_STR 12
#if SIZEOF_LONGDOUBLE == SIZEOF_DOUBLE
#define LONGDOUBLEPREC_REPR DOUBLEPREC_REPR
#define LONGDOUBLEPREC_STR DOUBLEPREC_STR
#else /* More than probably needed on Intel FP */
#define LONGDOUBLEPREC_REPR 20
#define LONGDOUBLEPREC_STR 12
#endif

/*
 * float type str and repr
 *
 * These functions will return NULL if PyString creation fails.
 */
#line 654
#line 658

#define PREC FLOATPREC_STR

static PyObject *
floattype_str(PyObject *self)
{
    char buf[100];
    float val = ((PyFloatScalarObject *)self)->obval;

    format_float(buf, sizeof(buf), val, PREC);
    return PyString_FromString(buf);
}

static PyObject *
cfloattype_str(PyObject *self)
{
    char buf[202];
    cfloat val = ((PyCFloatScalarObject *)self)->obval;

    format_cfloat(buf, sizeof(buf), val, PREC);
    return PyString_FromString(buf);
}

#undef PREC


#line 658

#define PREC FLOATPREC_REPR

static PyObject *
floattype_repr(PyObject *self)
{
    char buf[100];
    float val = ((PyFloatScalarObject *)self)->obval;

    format_float(buf, sizeof(buf), val, PREC);
    return PyString_FromString(buf);
}

static PyObject *
cfloattype_repr(PyObject *self)
{
    char buf[202];
    cfloat val = ((PyCFloatScalarObject *)self)->obval;

    format_cfloat(buf, sizeof(buf), val, PREC);
    return PyString_FromString(buf);
}

#undef PREC



#line 654
#line 658

#define PREC DOUBLEPREC_STR

static PyObject *
doubletype_str(PyObject *self)
{
    char buf[100];
    double val = ((PyDoubleScalarObject *)self)->obval;

    format_double(buf, sizeof(buf), val, PREC);
    return PyString_FromString(buf);
}

static PyObject *
cdoubletype_str(PyObject *self)
{
    char buf[202];
    cdouble val = ((PyCDoubleScalarObject *)self)->obval;

    format_cdouble(buf, sizeof(buf), val, PREC);
    return PyString_FromString(buf);
}

#undef PREC


#line 658

#define PREC DOUBLEPREC_REPR

static PyObject *
doubletype_repr(PyObject *self)
{
    char buf[100];
    double val = ((PyDoubleScalarObject *)self)->obval;

    format_double(buf, sizeof(buf), val, PREC);
    return PyString_FromString(buf);
}

static PyObject *
cdoubletype_repr(PyObject *self)
{
    char buf[202];
    cdouble val = ((PyCDoubleScalarObject *)self)->obval;

    format_cdouble(buf, sizeof(buf), val, PREC);
    return PyString_FromString(buf);
}

#undef PREC



#line 654
#line 658

#define PREC LONGDOUBLEPREC_STR

static PyObject *
longdoubletype_str(PyObject *self)
{
    char buf[100];
    longdouble val = ((PyLongDoubleScalarObject *)self)->obval;

    format_longdouble(buf, sizeof(buf), val, PREC);
    return PyString_FromString(buf);
}

static PyObject *
clongdoubletype_str(PyObject *self)
{
    char buf[202];
    clongdouble val = ((PyCLongDoubleScalarObject *)self)->obval;

    format_clongdouble(buf, sizeof(buf), val, PREC);
    return PyString_FromString(buf);
}

#undef PREC


#line 658

#define PREC LONGDOUBLEPREC_REPR

static PyObject *
longdoubletype_repr(PyObject *self)
{
    char buf[100];
    longdouble val = ((PyLongDoubleScalarObject *)self)->obval;

    format_longdouble(buf, sizeof(buf), val, PREC);
    return PyString_FromString(buf);
}

static PyObject *
clongdoubletype_repr(PyObject *self)
{
    char buf[202];
    clongdouble val = ((PyCLongDoubleScalarObject *)self)->obval;

    format_clongdouble(buf, sizeof(buf), val, PREC);
    return PyString_FromString(buf);
}

#undef PREC





/*
 * Could improve this with a PyLong_FromLongDouble(longdouble ldval)
 * but this would need some more work...
 */

#line 700
static PyObject *
longdoubletype_int(PyObject *self)
{
    double dval;
    PyObject *obj, *ret;

    dval = (double)(((PyLongDoubleScalarObject *)self)->obval);
    obj = PyLong_FromDouble(dval);
    ret = obj->ob_type->tp_as_number->nb_int(obj);
    Py_DECREF(obj);
    return ret;
}

#line 700
static PyObject *
longdoubletype_long(PyObject *self)
{
    double dval;
    PyObject *obj, *ret;

    dval = (double)(((PyLongDoubleScalarObject *)self)->obval);
    obj = PyLong_FromDouble(dval);
    ret = obj->ob_type->tp_as_number->nb_long(obj);
    Py_DECREF(obj);
    return ret;
}

#line 700
static PyObject *
longdoubletype_hex(PyObject *self)
{
    double dval;
    PyObject *obj, *ret;

    dval = (double)(((PyLongDoubleScalarObject *)self)->obval);
    obj = PyLong_FromDouble(dval);
    ret = obj->ob_type->tp_as_number->nb_hex(obj);
    Py_DECREF(obj);
    return ret;
}

#line 700
static PyObject *
longdoubletype_oct(PyObject *self)
{
    double dval;
    PyObject *obj, *ret;

    dval = (double)(((PyLongDoubleScalarObject *)self)->obval);
    obj = PyLong_FromDouble(dval);
    ret = obj->ob_type->tp_as_number->nb_oct(obj);
    Py_DECREF(obj);
    return ret;
}

#line 700
static PyObject *
longdoubletype_float(PyObject *self)
{
    double dval;
    PyObject *obj, *ret;

    dval = (double)(((PyLongDoubleScalarObject *)self)->obval);
    obj = PyFloat_FromDouble(dval);
    ret = obj->ob_type->tp_as_number->nb_float(obj);
    Py_DECREF(obj);
    return ret;
}

#line 700
static PyObject *
clongdoubletype_int(PyObject *self)
{
    double dval;
    PyObject *obj, *ret;

    dval = (double)(((PyCLongDoubleScalarObject *)self)->obval).real;
    obj = PyLong_FromDouble(dval);
    ret = obj->ob_type->tp_as_number->nb_int(obj);
    Py_DECREF(obj);
    return ret;
}

#line 700
static PyObject *
clongdoubletype_long(PyObject *self)
{
    double dval;
    PyObject *obj, *ret;

    dval = (double)(((PyCLongDoubleScalarObject *)self)->obval).real;
    obj = PyLong_FromDouble(dval);
    ret = obj->ob_type->tp_as_number->nb_long(obj);
    Py_DECREF(obj);
    return ret;
}

#line 700
static PyObject *
clongdoubletype_hex(PyObject *self)
{
    double dval;
    PyObject *obj, *ret;

    dval = (double)(((PyCLongDoubleScalarObject *)self)->obval).real;
    obj = PyLong_FromDouble(dval);
    ret = obj->ob_type->tp_as_number->nb_hex(obj);
    Py_DECREF(obj);
    return ret;
}

#line 700
static PyObject *
clongdoubletype_oct(PyObject *self)
{
    double dval;
    PyObject *obj, *ret;

    dval = (double)(((PyCLongDoubleScalarObject *)self)->obval).real;
    obj = PyLong_FromDouble(dval);
    ret = obj->ob_type->tp_as_number->nb_oct(obj);
    Py_DECREF(obj);
    return ret;
}

#line 700
static PyObject *
clongdoubletype_float(PyObject *self)
{
    double dval;
    PyObject *obj, *ret;

    dval = (double)(((PyCLongDoubleScalarObject *)self)->obval).real;
    obj = PyFloat_FromDouble(dval);
    ret = obj->ob_type->tp_as_number->nb_float(obj);
    Py_DECREF(obj);
    return ret;
}



static PyNumberMethods gentype_as_number = {
    (binaryfunc)gentype_add,                    /*nb_add*/
    (binaryfunc)gentype_subtract,               /*nb_subtract*/
    (binaryfunc)gentype_multiply,               /*nb_multiply*/
    (binaryfunc)gentype_divide,                 /*nb_divide*/
    (binaryfunc)gentype_remainder,              /*nb_remainder*/
    (binaryfunc)gentype_divmod,                 /*nb_divmod*/
    (ternaryfunc)gentype_power,                 /*nb_power*/
    (unaryfunc)gentype_negative,
    (unaryfunc)gentype_positive,                /*nb_pos*/
    (unaryfunc)gentype_absolute,                /*(unaryfunc)gentype_abs,*/
    (inquiry)gentype_nonzero_number,            /*nb_nonzero*/
    (unaryfunc)gentype_invert,                  /*nb_invert*/
    (binaryfunc)gentype_lshift,                 /*nb_lshift*/
    (binaryfunc)gentype_rshift,                 /*nb_rshift*/
    (binaryfunc)gentype_and,                    /*nb_and*/
    (binaryfunc)gentype_xor,                    /*nb_xor*/
    (binaryfunc)gentype_or,                     /*nb_or*/
    0,                                          /*nb_coerce*/
    (unaryfunc)gentype_int,                     /*nb_int*/
    (unaryfunc)gentype_long,                    /*nb_long*/
    (unaryfunc)gentype_float,                   /*nb_float*/
    (unaryfunc)gentype_oct,                     /*nb_oct*/
    (unaryfunc)gentype_hex,                     /*nb_hex*/
    0,                                          /*inplace_add*/
    0,                                          /*inplace_subtract*/
    0,                                          /*inplace_multiply*/
    0,                                          /*inplace_divide*/
    0,                                          /*inplace_remainder*/
    0,                                          /*inplace_power*/
    0,                                          /*inplace_lshift*/
    0,                                          /*inplace_rshift*/
    0,                                          /*inplace_and*/
    0,                                          /*inplace_xor*/
    0,                                          /*inplace_or*/
    (binaryfunc)gentype_floor_divide,           /*nb_floor_divide*/
    (binaryfunc)gentype_true_divide,            /*nb_true_divide*/
    0,                                          /*nb_inplace_floor_divide*/
    0,                                          /*nb_inplace_true_divide*/
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc)NULL,                            /*nb_index*/
#endif
};


static PyObject *
gentype_richcompare(PyObject *self, PyObject *other, int cmp_op)
{
    PyObject *arr, *ret;

    arr = PyArray_FromScalar(self, NULL);
    if (arr == NULL) return NULL;
    ret = arr->ob_type->tp_richcompare(arr, other, cmp_op);
    Py_DECREF(arr);
    return ret;
}

static PyObject *
gentype_ndim_get(PyObject *self)
{
    return PyInt_FromLong(0);
}

static PyObject *
gentype_flags_get(PyObject *self)
{
    return PyArray_NewFlagsObject(NULL);
}

static PyObject *
voidtype_flags_get(PyVoidScalarObject *self)
{
    PyObject *flagobj;
    flagobj = PyArrayFlags_Type.tp_alloc(&PyArrayFlags_Type, 0);
    if (flagobj == NULL) return NULL;
    ((PyArrayFlagsObject *)flagobj)->arr = NULL;
    ((PyArrayFlagsObject *)flagobj)->flags = self->flags;
    return flagobj;
}

static PyObject *
voidtype_dtypedescr_get(PyVoidScalarObject *self)
{
    Py_INCREF(self->descr);
    return (PyObject *)self->descr;
}


static PyObject *
gentype_data_get(PyObject *self)
{
    return PyBuffer_FromObject(self, 0, Py_END_OF_BUFFER);
}


static PyObject *
gentype_itemsize_get(PyObject *self)
{
    PyArray_Descr *typecode;
    PyObject *ret;
    int elsize;

    typecode = PyArray_DescrFromScalar(self);
    elsize = typecode->elsize;
#ifndef Py_UNICODE_WIDE
    if (typecode->type_num == NPY_UNICODE) {
        elsize >>= 1;
    }
#endif
    ret = PyInt_FromLong((long) elsize);
    Py_DECREF(typecode);
    return ret;
}

static PyObject *
gentype_size_get(PyObject *self)
{
    return PyInt_FromLong(1);
}

static void
gentype_struct_free(void *ptr, void *arg)
{
    PyArrayInterface *arrif = (PyArrayInterface *)ptr;
    Py_DECREF((PyObject *)arg);
    Py_XDECREF(arrif->descr);
    _pya_free(arrif->shape);
    _pya_free(arrif);
}

static PyObject *
gentype_struct_get(PyObject *self)
{
    PyArrayObject *arr;
    PyArrayInterface *inter;

    arr = (PyArrayObject *)PyArray_FromScalar(self, NULL);
    inter = (PyArrayInterface *)_pya_malloc(sizeof(PyArrayInterface));
    inter->two = 2;
    inter->nd = 0;
    inter->flags = arr->flags;
    inter->flags &= ~(UPDATEIFCOPY | OWNDATA);
    inter->flags |= NPY_NOTSWAPPED;
    inter->typekind = arr->descr->kind;
    inter->itemsize = arr->descr->elsize;
    inter->strides = NULL;
    inter->shape = NULL;
    inter->data = arr->data;
    inter->descr = NULL;

    return PyCObject_FromVoidPtrAndDesc(inter, arr, gentype_struct_free);
}

static PyObject *
gentype_priority_get(PyObject *self)
{
    return PyFloat_FromDouble(NPY_SCALAR_PRIORITY);
}

static PyObject *
gentype_shape_get(PyObject *self)
{
    return PyTuple_New(0);
}


static PyObject *
gentype_interface_get(PyObject *self)
{
    PyArrayObject *arr;
    PyObject *inter;

    arr = (PyArrayObject *)PyArray_FromScalar(self, NULL);
    if (arr == NULL) return NULL;
    inter = PyObject_GetAttrString((PyObject *)arr, "__array_interface__");
    if (inter != NULL) PyDict_SetItemString(inter, "__ref", (PyObject *)arr);
    Py_DECREF(arr);
    return inter;
}



static PyObject *
gentype_typedescr_get(PyObject *self)
{
    return (PyObject *)PyArray_DescrFromScalar(self);
}


static PyObject *
gentype_base_get(PyObject *self)
{
    Py_INCREF(Py_None);
    return Py_None;
}


static PyArray_Descr *
_realdescr_fromcomplexscalar(PyObject *self, int *typenum)
{
    if (PyArray_IsScalar(self, CDouble)) {
        *typenum = PyArray_CDOUBLE;
        return PyArray_DescrFromType(PyArray_DOUBLE);
    }
    if (PyArray_IsScalar(self, CFloat)) {
        *typenum = PyArray_CFLOAT;
        return PyArray_DescrFromType(PyArray_FLOAT);
    }
    if (PyArray_IsScalar(self, CLongDouble)) {
        *typenum = PyArray_CLONGDOUBLE;
        return PyArray_DescrFromType(PyArray_LONGDOUBLE);
    }
    return NULL;
}

static PyObject *
gentype_real_get(PyObject *self)
{
    PyArray_Descr *typecode;
    PyObject *ret;
    int typenum;

    if (PyArray_IsScalar(self, ComplexFloating)) {
        void *ptr;
        typecode = _realdescr_fromcomplexscalar(self, &typenum);
        ptr = scalar_value(self, NULL);
        ret = PyArray_Scalar(ptr, typecode, NULL);
        Py_DECREF(typecode);
        return ret;
    }
    else if (PyArray_IsScalar(self, Object)) {
        PyObject *obj = ((PyObjectScalarObject *)self)->obval;
        ret = PyObject_GetAttrString(obj, "real");
        if (ret != NULL) return ret;
        PyErr_Clear();
    }
    Py_INCREF(self);
    return (PyObject *)self;
}

static PyObject *
gentype_imag_get(PyObject *self)
{
    PyArray_Descr *typecode=NULL;
    PyObject *ret;
    int typenum;

    if (PyArray_IsScalar(self, ComplexFloating)) {
        char *ptr;
        typecode = _realdescr_fromcomplexscalar(self, &typenum);
        ptr = (char *)scalar_value(self, NULL);
        ret = PyArray_Scalar(ptr + typecode->elsize,
                typecode, NULL);
    }
    else if (PyArray_IsScalar(self, Object)) {
        PyObject *obj = ((PyObjectScalarObject *)self)->obval;
        PyArray_Descr *newtype;
        ret = PyObject_GetAttrString(obj, "imag");
        if (ret == NULL) {
            PyErr_Clear();
            obj = PyInt_FromLong(0);
            newtype = PyArray_DescrFromType(PyArray_OBJECT);
            ret = PyArray_Scalar((char *)&obj, newtype, NULL);
            Py_DECREF(newtype);
            Py_DECREF(obj);
        }
    }
    else {
        char *temp;
        int elsize;
        typecode = PyArray_DescrFromScalar(self);
        elsize = typecode->elsize;
        temp = PyDataMem_NEW(elsize);
        memset(temp, '\0', elsize);
        ret = PyArray_Scalar(temp, typecode, NULL);
        PyDataMem_FREE(temp);
    }

    Py_XDECREF(typecode);
    return ret;
}

static PyObject *
gentype_flat_get(PyObject *self)
{
    PyObject *ret, *arr;

    arr = PyArray_FromScalar(self, NULL);
    if (arr == NULL) return NULL;
    ret = PyArray_IterNew(arr);
    Py_DECREF(arr);
    return ret;
}


static PyObject *
gentype_transpose_get(PyObject *self)
{
    Py_INCREF(self);
    return self;
}


static PyGetSetDef gentype_getsets[] = {
    {"ndim",
        (getter)gentype_ndim_get,
        (setter) 0,
        "number of array dimensions"},
    {"flags",
        (getter)gentype_flags_get,
        (setter)0,
        "integer value of flags"},
    {"shape",
        (getter)gentype_shape_get,
        (setter)0,
        "tuple of array dimensions"},
    {"strides",
        (getter)gentype_shape_get,
        (setter) 0,
        "tuple of bytes steps in each dimension"},
    {"data",
        (getter)gentype_data_get,
        (setter) 0,
        "pointer to start of data"},
    {"itemsize",
        (getter)gentype_itemsize_get,
        (setter)0,
        "length of one element in bytes"},
    {"size",
        (getter)gentype_size_get,
        (setter)0,
        "number of elements in the gentype"},
    {"nbytes",
        (getter)gentype_itemsize_get,
        (setter)0,
        "length of item in bytes"},
    {"base",
        (getter)gentype_base_get,
        (setter)0,
        "base object"},
    {"dtype",
        (getter)gentype_typedescr_get,
        NULL,
        "get array data-descriptor"},
    {"real",
        (getter)gentype_real_get,
        (setter)0,
        "real part of scalar"},
    {"imag",
        (getter)gentype_imag_get,
        (setter)0,
        "imaginary part of scalar"},
    {"flat",
        (getter)gentype_flat_get,
        (setter)0,
        "a 1-d view of scalar"},
    {"T",
        (getter)gentype_transpose_get,
        (setter)0,
        "transpose"},
    {"__array_interface__",
        (getter)gentype_interface_get,
        NULL,
        "Array protocol: Python side"},
    {"__array_struct__",
        (getter)gentype_struct_get,
        NULL,
        "Array protocol: struct"},
    {"__array_priority__",
        (getter)gentype_priority_get,
        NULL,
        "Array priority."},
    {NULL, NULL, NULL, NULL}  /* Sentinel */
};


/* 0-dim array from scalar object */

static char doc_getarray[] = "sc.__array__(|type) return 0-dim array";

static PyObject *
gentype_getarray(PyObject *scalar, PyObject *args)
{
    PyArray_Descr *outcode=NULL;
    PyObject *ret;

    if (!PyArg_ParseTuple(args, "|O&", &PyArray_DescrConverter,
                &outcode)) {
        Py_XDECREF(outcode);
        return NULL;
    }
    ret = PyArray_FromScalar(scalar, outcode);
    return ret;
}

static char doc_sc_wraparray[] = "sc.__array_wrap__(obj) return scalar from array";

static PyObject *
gentype_wraparray(PyObject *scalar, PyObject *args)
{
    PyObject *arr;

    if (PyTuple_Size(args) < 1) {
        PyErr_SetString(PyExc_TypeError,
                "only accepts 1 argument.");
        return NULL;
    }
    arr = PyTuple_GET_ITEM(args, 0);
    if (!PyArray_Check(arr)) {
        PyErr_SetString(PyExc_TypeError,
                "can only be called with ndarray object");
        return NULL;
    }

    return PyArray_Scalar(PyArray_DATA(arr), PyArray_DESCR(arr), arr);
}


#line 1137

static PyObject *
gentype_tolist(PyObject *self, PyObject *args)
{
    return gentype_generic_method(self, args, NULL, "tolist");
}

#line 1137

static PyObject *
gentype_item(PyObject *self, PyObject *args)
{
    return gentype_generic_method(self, args, NULL, "item");
}

#line 1137

static PyObject *
gentype_tostring(PyObject *self, PyObject *args)
{
    return gentype_generic_method(self, args, NULL, "tostring");
}

#line 1137

static PyObject *
gentype_astype(PyObject *self, PyObject *args)
{
    return gentype_generic_method(self, args, NULL, "astype");
}

#line 1137

static PyObject *
gentype_copy(PyObject *self, PyObject *args)
{
    return gentype_generic_method(self, args, NULL, "copy");
}

#line 1137

static PyObject *
gentype___deepcopy__(PyObject *self, PyObject *args)
{
    return gentype_generic_method(self, args, NULL, "__deepcopy__");
}

#line 1137

static PyObject *
gentype_searchsorted(PyObject *self, PyObject *args)
{
    return gentype_generic_method(self, args, NULL, "searchsorted");
}

#line 1137

static PyObject *
gentype_view(PyObject *self, PyObject *args)
{
    return gentype_generic_method(self, args, NULL, "view");
}

#line 1137

static PyObject *
gentype_swapaxes(PyObject *self, PyObject *args)
{
    return gentype_generic_method(self, args, NULL, "swapaxes");
}

#line 1137

static PyObject *
gentype_conj(PyObject *self, PyObject *args)
{
    return gentype_generic_method(self, args, NULL, "conj");
}

#line 1137

static PyObject *
gentype_conjugate(PyObject *self, PyObject *args)
{
    return gentype_generic_method(self, args, NULL, "conjugate");
}

#line 1137

static PyObject *
gentype_nonzero(PyObject *self, PyObject *args)
{
    return gentype_generic_method(self, args, NULL, "nonzero");
}

#line 1137

static PyObject *
gentype_flatten(PyObject *self, PyObject *args)
{
    return gentype_generic_method(self, args, NULL, "flatten");
}

#line 1137

static PyObject *
gentype_ravel(PyObject *self, PyObject *args)
{
    return gentype_generic_method(self, args, NULL, "ravel");
}

#line 1137

static PyObject *
gentype_fill(PyObject *self, PyObject *args)
{
    return gentype_generic_method(self, args, NULL, "fill");
}

#line 1137

static PyObject *
gentype_transpose(PyObject *self, PyObject *args)
{
    return gentype_generic_method(self, args, NULL, "transpose");
}

#line 1137

static PyObject *
gentype_newbyteorder(PyObject *self, PyObject *args)
{
    return gentype_generic_method(self, args, NULL, "newbyteorder");
}


static PyObject *
gentype_itemset(PyObject *self, PyObject *args)
{
    PyErr_SetString(PyExc_ValueError, "array-scalars are immutable");
    return NULL;
}

static PyObject *
gentype_squeeze(PyObject *self, PyObject *args)
{
    if (!PyArg_ParseTuple(args, "")) return NULL;
    Py_INCREF(self);
    return self;
}

static Py_ssize_t
gentype_getreadbuf(PyObject *, Py_ssize_t, void **);

static PyObject *
gentype_byteswap(PyObject *self, PyObject *args)
{
    Bool inplace=FALSE;

    if (!PyArg_ParseTuple(args, "|O&", PyArray_BoolConverter, &inplace))
        return NULL;

    if (inplace) {
        PyErr_SetString(PyExc_ValueError,
                "cannot byteswap a scalar in-place");
        return NULL;
    }
    else {
        /* get the data, copyswap it and pass it to a new Array scalar
        */
        char *data;
        int numbytes;
        PyArray_Descr *descr;
        PyObject *new;
        char *newmem;

        numbytes = gentype_getreadbuf(self, 0, (void **)&data);
        descr = PyArray_DescrFromScalar(self);
        newmem = _pya_malloc(descr->elsize);
        if (newmem == NULL) {Py_DECREF(descr); return PyErr_NoMemory();}
        else memcpy(newmem, data, descr->elsize);
        byte_swap_vector(newmem, 1, descr->elsize);
        new = PyArray_Scalar(newmem, descr, NULL);
        _pya_free(newmem);
        Py_DECREF(descr);
        return new;
    }
}


#line 1203

static PyObject *
gentype_take(PyObject *self, PyObject *args, PyObject *kwds)
{
    return gentype_generic_method(self, args, kwds, "take");
}

#line 1203

static PyObject *
gentype_getfield(PyObject *self, PyObject *args, PyObject *kwds)
{
    return gentype_generic_method(self, args, kwds, "getfield");
}

#line 1203

static PyObject *
gentype_put(PyObject *self, PyObject *args, PyObject *kwds)
{
    return gentype_generic_method(self, args, kwds, "put");
}

#line 1203

static PyObject *
gentype_repeat(PyObject *self, PyObject *args, PyObject *kwds)
{
    return gentype_generic_method(self, args, kwds, "repeat");
}

#line 1203

static PyObject *
gentype_tofile(PyObject *self, PyObject *args, PyObject *kwds)
{
    return gentype_generic_method(self, args, kwds, "tofile");
}

#line 1203

static PyObject *
gentype_mean(PyObject *self, PyObject *args, PyObject *kwds)
{
    return gentype_generic_method(self, args, kwds, "mean");
}

#line 1203

static PyObject *
gentype_trace(PyObject *self, PyObject *args, PyObject *kwds)
{
    return gentype_generic_method(self, args, kwds, "trace");
}

#line 1203

static PyObject *
gentype_diagonal(PyObject *self, PyObject *args, PyObject *kwds)
{
    return gentype_generic_method(self, args, kwds, "diagonal");
}

#line 1203

static PyObject *
gentype_clip(PyObject *self, PyObject *args, PyObject *kwds)
{
    return gentype_generic_method(self, args, kwds, "clip");
}

#line 1203

static PyObject *
gentype_std(PyObject *self, PyObject *args, PyObject *kwds)
{
    return gentype_generic_method(self, args, kwds, "std");
}

#line 1203

static PyObject *
gentype_var(PyObject *self, PyObject *args, PyObject *kwds)
{
    return gentype_generic_method(self, args, kwds, "var");
}

#line 1203

static PyObject *
gentype_sum(PyObject *self, PyObject *args, PyObject *kwds)
{
    return gentype_generic_method(self, args, kwds, "sum");
}

#line 1203

static PyObject *
gentype_cumsum(PyObject *self, PyObject *args, PyObject *kwds)
{
    return gentype_generic_method(self, args, kwds, "cumsum");
}

#line 1203

static PyObject *
gentype_prod(PyObject *self, PyObject *args, PyObject *kwds)
{
    return gentype_generic_method(self, args, kwds, "prod");
}

#line 1203

static PyObject *
gentype_cumprod(PyObject *self, PyObject *args, PyObject *kwds)
{
    return gentype_generic_method(self, args, kwds, "cumprod");
}

#line 1203

static PyObject *
gentype_compress(PyObject *self, PyObject *args, PyObject *kwds)
{
    return gentype_generic_method(self, args, kwds, "compress");
}

#line 1203

static PyObject *
gentype_sort(PyObject *self, PyObject *args, PyObject *kwds)
{
    return gentype_generic_method(self, args, kwds, "sort");
}

#line 1203

static PyObject *
gentype_argsort(PyObject *self, PyObject *args, PyObject *kwds)
{
    return gentype_generic_method(self, args, kwds, "argsort");
}

#line 1203

static PyObject *
gentype_round(PyObject *self, PyObject *args, PyObject *kwds)
{
    return gentype_generic_method(self, args, kwds, "round");
}

#line 1203

static PyObject *
gentype_argmax(PyObject *self, PyObject *args, PyObject *kwds)
{
    return gentype_generic_method(self, args, kwds, "argmax");
}

#line 1203

static PyObject *
gentype_argmin(PyObject *self, PyObject *args, PyObject *kwds)
{
    return gentype_generic_method(self, args, kwds, "argmin");
}

#line 1203

static PyObject *
gentype_max(PyObject *self, PyObject *args, PyObject *kwds)
{
    return gentype_generic_method(self, args, kwds, "max");
}

#line 1203

static PyObject *
gentype_min(PyObject *self, PyObject *args, PyObject *kwds)
{
    return gentype_generic_method(self, args, kwds, "min");
}

#line 1203

static PyObject *
gentype_ptp(PyObject *self, PyObject *args, PyObject *kwds)
{
    return gentype_generic_method(self, args, kwds, "ptp");
}

#line 1203

static PyObject *
gentype_any(PyObject *self, PyObject *args, PyObject *kwds)
{
    return gentype_generic_method(self, args, kwds, "any");
}

#line 1203

static PyObject *
gentype_all(PyObject *self, PyObject *args, PyObject *kwds)
{
    return gentype_generic_method(self, args, kwds, "all");
}

#line 1203

static PyObject *
gentype_resize(PyObject *self, PyObject *args, PyObject *kwds)
{
    return gentype_generic_method(self, args, kwds, "resize");
}

#line 1203

static PyObject *
gentype_reshape(PyObject *self, PyObject *args, PyObject *kwds)
{
    return gentype_generic_method(self, args, kwds, "reshape");
}

#line 1203

static PyObject *
gentype_choose(PyObject *self, PyObject *args, PyObject *kwds)
{
    return gentype_generic_method(self, args, kwds, "choose");
}


static PyObject *
voidtype_getfield(PyVoidScalarObject *self, PyObject *args, PyObject *kwds)
{
    PyObject *ret;

    ret = gentype_generic_method((PyObject *)self, args, kwds, "getfield");
    if (!ret) return ret;
    if (PyArray_IsScalar(ret, Generic) &&   \
            (!PyArray_IsScalar(ret, Void))) {
        PyArray_Descr *new;
        void *ptr;
        if (!PyArray_ISNBO(self->descr->byteorder)) {
            new = PyArray_DescrFromScalar(ret);
            ptr = scalar_value(ret, new);
            byte_swap_vector(ptr, 1, new->elsize);
            Py_DECREF(new);
        }
    }
    return ret;
}

static PyObject *
gentype_setfield(PyObject *self, PyObject *args, PyObject *kwds)
{
    PyErr_SetString(PyExc_TypeError,
            "Can't set fields in a non-void array scalar.");
    return NULL;
}

static PyObject *
voidtype_setfield(PyVoidScalarObject *self, PyObject *args, PyObject *kwds)
{
    PyArray_Descr *typecode=NULL;
    int offset = 0;
    PyObject *value, *src;
    int mysize;
    char *dptr;
    static char *kwlist[] = {"value", "dtype", "offset", 0};

    if ((self->flags & WRITEABLE) != WRITEABLE) {
        PyErr_SetString(PyExc_RuntimeError,
                "Can't write to memory");
        return NULL;
    }
    if (!PyArg_ParseTupleAndKeywords(args, kwds, "OO&|i", kwlist,
                &value,
                PyArray_DescrConverter,
                &typecode, &offset)) {
        Py_XDECREF(typecode);
        return NULL;
    }

    mysize = self->ob_size;

    if (offset < 0 || (offset + typecode->elsize) > mysize) {
        PyErr_Format(PyExc_ValueError,
                "Need 0 <= offset <= %d for requested type "  \
                "but received offset = %d",
                mysize-typecode->elsize, offset);
        Py_DECREF(typecode);
        return NULL;
    }

    dptr = self->obval + offset;

    if (typecode->type_num == PyArray_OBJECT) {
        PyObject **temp;
        Py_INCREF(value);
        temp = (PyObject **)dptr;
        Py_XDECREF(*temp);
        memcpy(temp, &value, sizeof(PyObject *));
        Py_DECREF(typecode);
    }
    else {
        /* Copy data from value to correct place in dptr */
        src = PyArray_FromAny(value, typecode, 0, 0, CARRAY, NULL);
        if (src == NULL) return NULL;
        typecode->f->copyswap(dptr, PyArray_DATA(src),
                !PyArray_ISNBO(self->descr->byteorder),
                src);
        Py_DECREF(src);
    }
    Py_INCREF(Py_None);
    return Py_None;
}


static PyObject *
gentype_reduce(PyObject *self, PyObject *args)
{
    PyObject *ret=NULL, *obj=NULL, *mod=NULL;
    const char *buffer;
    Py_ssize_t buflen;

    /* Return a tuple of (callable object, arguments) */

    ret = PyTuple_New(2);
    if (ret == NULL) return NULL;
    if (PyObject_AsReadBuffer(self, (const void **)&buffer, &buflen)<0) {
        Py_DECREF(ret); return NULL;
    }
    mod = PyImport_ImportModule("numpy.core.multiarray");
    if (mod == NULL) return NULL;
    obj = PyObject_GetAttrString(mod, "scalar");
    Py_DECREF(mod);
    if (obj == NULL) return NULL;
    PyTuple_SET_ITEM(ret, 0, obj);
    obj = PyObject_GetAttrString((PyObject *)self, "dtype");
    if (PyArray_IsScalar(self, Object)) {
        mod = ((PyObjectScalarObject *)self)->obval;
        PyTuple_SET_ITEM(ret, 1,
                Py_BuildValue("NO", obj, mod));
    }
    else {
#ifndef Py_UNICODE_WIDE
        /* We need to expand the buffer so that we always write
           UCS4 to disk for pickle of unicode scalars.

           This could be in a unicode_reduce function, but
           that would require re-factoring.
           */
        int alloc=0;
        char *tmp;
        int newlen;

        if (PyArray_IsScalar(self, Unicode)) {
            tmp = _pya_malloc(buflen*2);
            if (tmp == NULL) {
                Py_DECREF(ret);
                return PyErr_NoMemory();
            }
            alloc = 1;
            newlen = PyUCS2Buffer_AsUCS4((Py_UNICODE *)buffer,
                    (PyArray_UCS4 *)tmp,
                    buflen / 2, buflen / 2);
            buflen = newlen*4;
            buffer = tmp;
        }
#endif
        mod = PyString_FromStringAndSize(buffer, buflen);
        if (mod == NULL) {
            Py_DECREF(ret);
#ifndef Py_UNICODE_WIDE
            ret = NULL;
            goto fail;
#else
            return NULL;
#endif
        }
        PyTuple_SET_ITEM(ret, 1,
                Py_BuildValue("NN", obj, mod));
#ifndef Py_UNICODE_WIDE
fail:
        if (alloc) _pya_free((char *)buffer);
#endif
    }
    return ret;
}

/* ignores everything */
static PyObject *
gentype_setstate(PyObject *self, PyObject *args)
{
    Py_INCREF(Py_None);
    return (Py_None);
}

static PyObject *
gentype_dump(PyObject *self, PyObject *args)
{
    PyObject *file=NULL;
    int ret;

    if (!PyArg_ParseTuple(args, "O", &file))
        return NULL;
    ret = PyArray_Dump(self, file, 2);
    if (ret < 0) return NULL;
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
gentype_dumps(PyObject *self, PyObject *args)
{
    if (!PyArg_ParseTuple(args, ""))
        return NULL;
    return PyArray_Dumps(self, 2);
}


/* setting flags cannot be done for scalars */
static PyObject *
gentype_setflags(PyObject *self, PyObject *args, PyObject *kwds)
{
    Py_INCREF(Py_None);
    return Py_None;
}

/* need to fill in doc-strings for these methods on import -- copy from
   array docstrings
*/
static PyMethodDef gentype_methods[] = {
    {"tolist",
        (PyCFunction)gentype_tolist,   1, NULL},
    {"item",
        (PyCFunction)gentype_item, METH_VARARGS, NULL},
    {"itemset",
        (PyCFunction)gentype_itemset, METH_VARARGS, NULL},
    {"tofile", (PyCFunction)gentype_tofile,
        METH_VARARGS|METH_KEYWORDS, NULL},
    {"tostring",
        (PyCFunction)gentype_tostring, METH_VARARGS, NULL},
    {"byteswap",
        (PyCFunction)gentype_byteswap,1, NULL},
    {"astype",
        (PyCFunction)gentype_astype, 1, NULL},
    {"getfield",
        (PyCFunction)gentype_getfield,
        METH_VARARGS | METH_KEYWORDS, NULL},
    {"setfield",
        (PyCFunction)gentype_setfield,
        METH_VARARGS | METH_KEYWORDS, NULL},
    {"copy",
        (PyCFunction)gentype_copy, 1, NULL},
    {"resize", (PyCFunction)gentype_resize,
        METH_VARARGS|METH_KEYWORDS, NULL},
    {"__array__",
        (PyCFunction)gentype_getarray, 1, doc_getarray},
    {"__array_wrap__",
        (PyCFunction)gentype_wraparray, 1, doc_sc_wraparray},

    /* for the copy module */
    {"__copy__",
        (PyCFunction)gentype_copy, 1, NULL},
    {"__deepcopy__",
        (PyCFunction)gentype___deepcopy__, 1, NULL},

    {"__reduce__",
        (PyCFunction) gentype_reduce, 1, NULL},
    /* For consistency does nothing */
    {"__setstate__",
        (PyCFunction) gentype_setstate, 1, NULL},

    {"dumps",
        (PyCFunction) gentype_dumps, 1, NULL},
    {"dump",
        (PyCFunction) gentype_dump, 1, NULL},

    /* Methods for array */
    {"fill",
        (PyCFunction)gentype_fill,
        METH_VARARGS, NULL},
    {"transpose",
        (PyCFunction)gentype_transpose,
        METH_VARARGS, NULL},
    {"take",
        (PyCFunction)gentype_take,
        METH_VARARGS|METH_KEYWORDS, NULL},
    {"put",
        (PyCFunction)gentype_put,
        METH_VARARGS|METH_KEYWORDS, NULL},
    {"repeat",
        (PyCFunction)gentype_repeat,
        METH_VARARGS|METH_KEYWORDS, NULL},
    {"choose",
        (PyCFunction)gentype_choose,
        METH_VARARGS|METH_KEYWORDS, NULL},
    {"sort",
        (PyCFunction)gentype_sort,
        METH_VARARGS, NULL},
    {"argsort",
        (PyCFunction)gentype_argsort,
        METH_VARARGS, NULL},
    {"searchsorted",
        (PyCFunction)gentype_searchsorted,
        METH_VARARGS, NULL},
    {"argmax",
        (PyCFunction)gentype_argmax,
        METH_VARARGS|METH_KEYWORDS, NULL},
    {"argmin",
        (PyCFunction)gentype_argmin,
        METH_VARARGS|METH_KEYWORDS, NULL},
    {"reshape",
        (PyCFunction)gentype_reshape,
        METH_VARARGS|METH_KEYWORDS, NULL},
    {"squeeze",
        (PyCFunction)gentype_squeeze,
        METH_VARARGS, NULL},
    {"view",
        (PyCFunction)gentype_view,
        METH_VARARGS, NULL},
    {"swapaxes",
        (PyCFunction)gentype_swapaxes,
        METH_VARARGS, NULL},
    {"max",
        (PyCFunction)gentype_max,
        METH_VARARGS|METH_KEYWORDS, NULL},
    {"min",
        (PyCFunction)gentype_min,
        METH_VARARGS|METH_KEYWORDS, NULL},
    {"ptp",
        (PyCFunction)gentype_ptp,
        METH_VARARGS|METH_KEYWORDS, NULL},
    {"mean",
        (PyCFunction)gentype_mean,
        METH_VARARGS|METH_KEYWORDS, NULL},
    {"trace",
        (PyCFunction)gentype_trace,
        METH_VARARGS|METH_KEYWORDS, NULL},
    {"diagonal",
        (PyCFunction)gentype_diagonal,
        METH_VARARGS|METH_KEYWORDS, NULL},
    {"clip",
        (PyCFunction)gentype_clip,
        METH_VARARGS|METH_KEYWORDS, NULL},
    {"conj",
        (PyCFunction)gentype_conj,
        METH_VARARGS, NULL},
    {"conjugate",
        (PyCFunction)gentype_conjugate,
        METH_VARARGS, NULL},
    {"nonzero",
        (PyCFunction)gentype_nonzero,
        METH_VARARGS, NULL},
    {"std",
        (PyCFunction)gentype_std,
        METH_VARARGS|METH_KEYWORDS, NULL},
    {"var",
        (PyCFunction)gentype_var,
        METH_VARARGS|METH_KEYWORDS, NULL},
    {"sum",
        (PyCFunction)gentype_sum,
        METH_VARARGS|METH_KEYWORDS, NULL},
    {"cumsum",
        (PyCFunction)gentype_cumsum,
        METH_VARARGS|METH_KEYWORDS, NULL},
    {"prod",
        (PyCFunction)gentype_prod,
        METH_VARARGS|METH_KEYWORDS, NULL},
    {"cumprod",
        (PyCFunction)gentype_cumprod,
        METH_VARARGS|METH_KEYWORDS, NULL},
    {"all",
        (PyCFunction)gentype_all,
        METH_VARARGS|METH_KEYWORDS, NULL},
    {"any",
        (PyCFunction)gentype_any,
        METH_VARARGS|METH_KEYWORDS, NULL},
    {"compress",
        (PyCFunction)gentype_compress,
        METH_VARARGS|METH_KEYWORDS, NULL},
    {"flatten",
        (PyCFunction)gentype_flatten,
        METH_VARARGS, NULL},
    {"ravel",
        (PyCFunction)gentype_ravel,
        METH_VARARGS, NULL},
    {"round",
        (PyCFunction)gentype_round,
        METH_VARARGS|METH_KEYWORDS, NULL},
    {"setflags",
        (PyCFunction)gentype_setflags,
        METH_VARARGS|METH_KEYWORDS, NULL},
    {"newbyteorder",
        (PyCFunction)gentype_newbyteorder,
        METH_VARARGS, NULL},
    {NULL, NULL}           /* sentinel */
};


static PyGetSetDef voidtype_getsets[] = {
    {"flags",
        (getter)voidtype_flags_get,
        (setter)0,
        "integer value of flags"},
    {"dtype",
        (getter)voidtype_dtypedescr_get,
        (setter)0,
        "dtype object"},
    {NULL, NULL}
};

static PyMethodDef voidtype_methods[] = {
    {"getfield",
        (PyCFunction)voidtype_getfield,
        METH_VARARGS | METH_KEYWORDS, NULL},
    {"setfield",
        (PyCFunction)voidtype_setfield,
        METH_VARARGS | METH_KEYWORDS, NULL},
    {NULL, NULL}
};

/************* As_mapping functions for void array scalar ************/

static Py_ssize_t
voidtype_length(PyVoidScalarObject *self)
{
    if (!self->descr->names) {
        return 0;
    }
    else { /* return the number of fields */
        return (Py_ssize_t) PyTuple_GET_SIZE(self->descr->names);
    }
}

static PyObject *
voidtype_item(PyVoidScalarObject *self, Py_ssize_t n)
{
    intp m;
    PyObject *flist=NULL, *fieldinfo;

    if (!(PyDescr_HASFIELDS(self->descr))) {
        PyErr_SetString(PyExc_IndexError,
                "can't index void scalar without fields");
        return NULL;
    }
    flist = self->descr->names;
    m = PyTuple_GET_SIZE(flist);
    if (n < 0) n += m;
    if (n < 0 || n >= m) {
        PyErr_Format(PyExc_IndexError, "invalid index (%d)", (int) n);
        return NULL;
    }
    fieldinfo = PyDict_GetItem(self->descr->fields,
            PyTuple_GET_ITEM(flist, n));
    return voidtype_getfield(self, fieldinfo, NULL);
}


/* get field by name or number */
static PyObject *
voidtype_subscript(PyVoidScalarObject *self, PyObject *ind)
{
    intp n;
    PyObject *fieldinfo;

    if (!(PyDescr_HASFIELDS(self->descr))) {
        PyErr_SetString(PyExc_IndexError,
                "can't index void scalar without fields");
        return NULL;
    }

    if (PyString_Check(ind) || PyUnicode_Check(ind)) {
        /* look up in fields */
        fieldinfo = PyDict_GetItem(self->descr->fields, ind);
        if (!fieldinfo) goto fail;
        return voidtype_getfield(self, fieldinfo, NULL);
    }

    /* try to convert it to a number */
    n = PyArray_PyIntAsIntp(ind);
    if (error_converting(n)) goto fail;

    return voidtype_item(self, (Py_ssize_t)n);

fail:
    PyErr_SetString(PyExc_IndexError, "invalid index");
    return NULL;
}

static int
voidtype_ass_item(PyVoidScalarObject *self, Py_ssize_t n, PyObject *val)
{
    intp m;
    PyObject *flist=NULL, *fieldinfo, *newtup;
    PyObject *res;

    if (!(PyDescr_HASFIELDS(self->descr))) {
        PyErr_SetString(PyExc_IndexError,
                "can't index void scalar without fields");
        return -1;
    }

    flist = self->descr->names;
    m = PyTuple_GET_SIZE(flist);
    if (n < 0) n += m;
    if (n < 0 || n >= m) goto fail;
    fieldinfo = PyDict_GetItem(self->descr->fields,
            PyTuple_GET_ITEM(flist, n));
    newtup = Py_BuildValue("(OOO)", val,
            PyTuple_GET_ITEM(fieldinfo, 0),
            PyTuple_GET_ITEM(fieldinfo, 1));
    res = voidtype_setfield(self, newtup, NULL);
    Py_DECREF(newtup);
    if (!res) return -1;
    Py_DECREF(res);
    return 0;

fail:
    PyErr_Format(PyExc_IndexError, "invalid index (%d)", (int) n);
    return -1;
}

static int
voidtype_ass_subscript(PyVoidScalarObject *self, PyObject *ind, PyObject *val)
{
    intp n;
    char *msg = "invalid index";
    PyObject *fieldinfo, *newtup;
    PyObject *res;

    if (!PyDescr_HASFIELDS(self->descr)) {
        PyErr_SetString(PyExc_IndexError,
                "can't index void scalar without fields");
        return -1;
    }

    if (PyString_Check(ind) || PyUnicode_Check(ind)) {
        /* look up in fields */
        fieldinfo = PyDict_GetItem(self->descr->fields, ind);
        if (!fieldinfo) goto fail;
        newtup = Py_BuildValue("(OOO)", val,
                PyTuple_GET_ITEM(fieldinfo, 0),
                PyTuple_GET_ITEM(fieldinfo, 1));
        res = voidtype_setfield(self, newtup, NULL);
        Py_DECREF(newtup);
        if (!res) return -1;
        Py_DECREF(res);
        return 0;
    }

    /* try to convert it to a number */
    n = PyArray_PyIntAsIntp(ind);
    if (error_converting(n)) goto fail;
    return voidtype_ass_item(self, (Py_ssize_t)n, val);

fail:
    PyErr_SetString(PyExc_IndexError, msg);
    return -1;
}

static PyMappingMethods voidtype_as_mapping = {
#if PY_VERSION_HEX >= 0x02050000
    (lenfunc)voidtype_length,                   /*mp_length*/
#else
    (inquiry)voidtype_length,                   /*mp_length*/
#endif
    (binaryfunc)voidtype_subscript,             /*mp_subscript*/
    (objobjargproc)voidtype_ass_subscript,      /*mp_ass_subscript*/
};


static PySequenceMethods voidtype_as_sequence = {
#if PY_VERSION_HEX >= 0x02050000
    (lenfunc)voidtype_length,                   /*sq_length*/
    0,                                          /*sq_concat*/
    0,                                          /*sq_repeat*/
    (ssizeargfunc)voidtype_item,                /*sq_item*/
    0,                                          /*sq_slice*/
    (ssizeobjargproc)voidtype_ass_item          /*sq_ass_item*/
#else
        (inquiry)voidtype_length,               /*sq_length*/
    0,                                          /*sq_concat*/
    0,                                          /*sq_repeat*/
    (intargfunc)voidtype_item,                  /*sq_item*/
    0,                                          /*sq_slice*/
    (intobjargproc)voidtype_ass_item            /*sq_ass_item*/
#endif
};



static Py_ssize_t
gentype_getreadbuf(PyObject *self, Py_ssize_t segment, void **ptrptr)
{
    int numbytes;
    PyArray_Descr *outcode;

    if (segment != 0) {
        PyErr_SetString(PyExc_SystemError,
                "Accessing non-existent array segment");
        return -1;
    }

    outcode = PyArray_DescrFromScalar(self);
    numbytes = outcode->elsize;
    *ptrptr = (void *)scalar_value(self, outcode);

#ifndef Py_UNICODE_WIDE
    if (outcode->type_num == NPY_UNICODE) {
        numbytes >>= 1;
    }
#endif
    Py_DECREF(outcode);
    return numbytes;
}

static Py_ssize_t
gentype_getsegcount(PyObject *self, Py_ssize_t *lenp)
{
    PyArray_Descr *outcode;

    outcode = PyArray_DescrFromScalar(self);
    if (lenp) {
        *lenp = outcode->elsize;
#ifndef Py_UNICODE_WIDE
        if (outcode->type_num == NPY_UNICODE) {
            *lenp >>= 1;
        }
#endif
    }
    Py_DECREF(outcode);
    return 1;
}

static Py_ssize_t
gentype_getcharbuf(PyObject *self, Py_ssize_t segment, constchar **ptrptr)
{
    if (PyArray_IsScalar(self, String) ||   \
            PyArray_IsScalar(self, Unicode))
        return gentype_getreadbuf(self, segment, (void **)ptrptr);
    else {
        PyErr_SetString(PyExc_TypeError,
                "Non-character array cannot be interpreted "\
                "as character buffer.");
        return -1;
    }
}


static PyBufferProcs gentype_as_buffer = {
    gentype_getreadbuf,         /*bf_getreadbuffer*/
    NULL,                       /*bf_getwritebuffer*/
    gentype_getsegcount,        /*bf_getsegcount*/
    gentype_getcharbuf,         /*bf_getcharbuffer*/
};


#define BASEFLAGS Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES
#define LEAFFLAGS  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_CHECKTYPES

static PyTypeObject PyGenericArrType_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                          /*ob_size*/
    "numpy.generic",            /*tp_name*/
    sizeof(PyObject),           /*tp_basicsize*/
};

static void
void_dealloc(PyVoidScalarObject *v)
{
    if (v->flags & OWNDATA)
        PyDataMem_FREE(v->obval);
    Py_XDECREF(v->descr);
    Py_XDECREF(v->base);
    v->ob_type->tp_free(v);
}

static void
object_arrtype_dealloc(PyObject *v)
{
    Py_XDECREF(((PyObjectScalarObject *)v)->obval);
    v->ob_type->tp_free(v);
}

/* string and unicode inherit from Python Type first and so GET_ITEM is different to get to the Python Type.
 */
/* ok is a work-around for a bug in complex_new that doesn't allocate
   memory from the sub-types memory allocator.
*/

#define _WORK(num)  \
    if (type->tp_bases && (PyTuple_GET_SIZE(type->tp_bases)==2)) { \
        PyTypeObject *sup; \
        /* We are inheriting from a Python type as well so \
           give it first dibs on conversion */ \
        sup = (PyTypeObject *)PyTuple_GET_ITEM(type->tp_bases, num); \
        robj = sup->tp_new(type, args, kwds); \
        if (robj != NULL) goto finish;              \
        if (PyTuple_GET_SIZE(args)!=1) return NULL; \
        PyErr_Clear(); \
        /* now do default conversion */ \
    }

#define _WORK1 _WORK(1)
#define _WORKz _WORK(0)
#define _WORK0

#line 1895
static PyObject *
byte_arrtype_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyObject *obj = NULL;
    PyObject *robj;
    PyObject *arr;
    PyArray_Descr *typecode = NULL;
    int itemsize;
    void *dest, *src;

    /* allow base-class (if any) to do conversion */
    /* If successful, this will jump to finish: */
    _WORK0

    if (!PyArg_ParseTuple(args, "|O", &obj)) {
        return NULL;
    }
    typecode = PyArray_DescrFromType(PyArray_BYTE);
    /* typecode is new reference and stolen by
       PyArray_FromAny but not PyArray_Scalar
    */
    if (obj == NULL) {
#if 0 == 0
        char *mem = malloc(sizeof(byte));

        memset(mem, 0, sizeof(byte));
        robj = PyArray_Scalar(mem, typecode, NULL);
        free(mem);
#elif 0 == 1
        robj = PyArray_Scalar(NULL, typecode, NULL);
#elif 0 == 2
        obj = Py_None;
        robj = PyArray_Scalar(&obj, typecode, NULL);
#endif
	Py_DECREF(typecode);
        goto finish;
    }

    arr = PyArray_FromAny(obj, typecode, 0, 0, FORCECAST, NULL);
    if ((arr == NULL) || (PyArray_NDIM(arr) > 0)) {
        return arr;
    }
    /* 0-d array */
    robj = PyArray_ToScalar(PyArray_DATA(arr), (NPY_AO *)arr);
    Py_DECREF(arr);  

finish:
    /* Normal return */
    if ((robj == NULL) || (robj->ob_type == type)) {
        return robj;
    }

    /* This return path occurs when the requested type is not created
       but another scalar object is created instead (i.e. when
       the base-class does the conversion in _WORK macro) */

    /* Need to allocate new type and copy data-area over */
    if (type->tp_itemsize) {
        itemsize = PyString_GET_SIZE(robj);
    }
    else {
        itemsize = 0;
    }
    obj = type->tp_alloc(type, itemsize);
    if (obj == NULL) {
        Py_DECREF(robj);
        return NULL;
    }
    /* typecode will be NULL */
    typecode = PyArray_DescrFromType(PyArray_BYTE);
    dest = scalar_value(obj, typecode);
    src = scalar_value(robj, typecode);
    Py_DECREF(typecode);
#if 0 == 0
    *((npy_byte *)dest) = *((npy_byte *)src);
#elif 0 == 1 /* unicode and strings */
    if (itemsize == 0) { /* unicode */
	itemsize = ((PyUnicodeObject *)robj)->length * sizeof(Py_UNICODE);
    }
    memcpy(dest, src, itemsize);
#elif 0 == 2 /* Object arrays */
    memcpy(dest, src, sizeof(void *));
    Py_INCREF(*((PyObject **)dest));
#endif
    Py_DECREF(robj);
    return obj;
}

#line 1895
static PyObject *
short_arrtype_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyObject *obj = NULL;
    PyObject *robj;
    PyObject *arr;
    PyArray_Descr *typecode = NULL;
    int itemsize;
    void *dest, *src;

    /* allow base-class (if any) to do conversion */
    /* If successful, this will jump to finish: */
    _WORK0

    if (!PyArg_ParseTuple(args, "|O", &obj)) {
        return NULL;
    }
    typecode = PyArray_DescrFromType(PyArray_SHORT);
    /* typecode is new reference and stolen by
       PyArray_FromAny but not PyArray_Scalar
    */
    if (obj == NULL) {
#if 0 == 0
        char *mem = malloc(sizeof(short));

        memset(mem, 0, sizeof(short));
        robj = PyArray_Scalar(mem, typecode, NULL);
        free(mem);
#elif 0 == 1
        robj = PyArray_Scalar(NULL, typecode, NULL);
#elif 0 == 2
        obj = Py_None;
        robj = PyArray_Scalar(&obj, typecode, NULL);
#endif
	Py_DECREF(typecode);
        goto finish;
    }

    arr = PyArray_FromAny(obj, typecode, 0, 0, FORCECAST, NULL);
    if ((arr == NULL) || (PyArray_NDIM(arr) > 0)) {
        return arr;
    }
    /* 0-d array */
    robj = PyArray_ToScalar(PyArray_DATA(arr), (NPY_AO *)arr);
    Py_DECREF(arr);  

finish:
    /* Normal return */
    if ((robj == NULL) || (robj->ob_type == type)) {
        return robj;
    }

    /* This return path occurs when the requested type is not created
       but another scalar object is created instead (i.e. when
       the base-class does the conversion in _WORK macro) */

    /* Need to allocate new type and copy data-area over */
    if (type->tp_itemsize) {
        itemsize = PyString_GET_SIZE(robj);
    }
    else {
        itemsize = 0;
    }
    obj = type->tp_alloc(type, itemsize);
    if (obj == NULL) {
        Py_DECREF(robj);
        return NULL;
    }
    /* typecode will be NULL */
    typecode = PyArray_DescrFromType(PyArray_SHORT);
    dest = scalar_value(obj, typecode);
    src = scalar_value(robj, typecode);
    Py_DECREF(typecode);
#if 0 == 0
    *((npy_short *)dest) = *((npy_short *)src);
#elif 0 == 1 /* unicode and strings */
    if (itemsize == 0) { /* unicode */
	itemsize = ((PyUnicodeObject *)robj)->length * sizeof(Py_UNICODE);
    }
    memcpy(dest, src, itemsize);
#elif 0 == 2 /* Object arrays */
    memcpy(dest, src, sizeof(void *));
    Py_INCREF(*((PyObject **)dest));
#endif
    Py_DECREF(robj);
    return obj;
}

#line 1895
static PyObject *
int_arrtype_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyObject *obj = NULL;
    PyObject *robj;
    PyObject *arr;
    PyArray_Descr *typecode = NULL;
    int itemsize;
    void *dest, *src;

    /* allow base-class (if any) to do conversion */
    /* If successful, this will jump to finish: */
    _WORK1

    if (!PyArg_ParseTuple(args, "|O", &obj)) {
        return NULL;
    }
    typecode = PyArray_DescrFromType(PyArray_INT);
    /* typecode is new reference and stolen by
       PyArray_FromAny but not PyArray_Scalar
    */
    if (obj == NULL) {
#if 0 == 0
        char *mem = malloc(sizeof(int));

        memset(mem, 0, sizeof(int));
        robj = PyArray_Scalar(mem, typecode, NULL);
        free(mem);
#elif 0 == 1
        robj = PyArray_Scalar(NULL, typecode, NULL);
#elif 0 == 2
        obj = Py_None;
        robj = PyArray_Scalar(&obj, typecode, NULL);
#endif
	Py_DECREF(typecode);
        goto finish;
    }

    arr = PyArray_FromAny(obj, typecode, 0, 0, FORCECAST, NULL);
    if ((arr == NULL) || (PyArray_NDIM(arr) > 0)) {
        return arr;
    }
    /* 0-d array */
    robj = PyArray_ToScalar(PyArray_DATA(arr), (NPY_AO *)arr);
    Py_DECREF(arr);  

finish:
    /* Normal return */
    if ((robj == NULL) || (robj->ob_type == type)) {
        return robj;
    }

    /* This return path occurs when the requested type is not created
       but another scalar object is created instead (i.e. when
       the base-class does the conversion in _WORK macro) */

    /* Need to allocate new type and copy data-area over */
    if (type->tp_itemsize) {
        itemsize = PyString_GET_SIZE(robj);
    }
    else {
        itemsize = 0;
    }
    obj = type->tp_alloc(type, itemsize);
    if (obj == NULL) {
        Py_DECREF(robj);
        return NULL;
    }
    /* typecode will be NULL */
    typecode = PyArray_DescrFromType(PyArray_INT);
    dest = scalar_value(obj, typecode);
    src = scalar_value(robj, typecode);
    Py_DECREF(typecode);
#if 0 == 0
    *((npy_int *)dest) = *((npy_int *)src);
#elif 0 == 1 /* unicode and strings */
    if (itemsize == 0) { /* unicode */
	itemsize = ((PyUnicodeObject *)robj)->length * sizeof(Py_UNICODE);
    }
    memcpy(dest, src, itemsize);
#elif 0 == 2 /* Object arrays */
    memcpy(dest, src, sizeof(void *));
    Py_INCREF(*((PyObject **)dest));
#endif
    Py_DECREF(robj);
    return obj;
}

#line 1895
static PyObject *
long_arrtype_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyObject *obj = NULL;
    PyObject *robj;
    PyObject *arr;
    PyArray_Descr *typecode = NULL;
    int itemsize;
    void *dest, *src;

    /* allow base-class (if any) to do conversion */
    /* If successful, this will jump to finish: */
    _WORK1

    if (!PyArg_ParseTuple(args, "|O", &obj)) {
        return NULL;
    }
    typecode = PyArray_DescrFromType(PyArray_LONG);
    /* typecode is new reference and stolen by
       PyArray_FromAny but not PyArray_Scalar
    */
    if (obj == NULL) {
#if 0 == 0
        char *mem = malloc(sizeof(long));

        memset(mem, 0, sizeof(long));
        robj = PyArray_Scalar(mem, typecode, NULL);
        free(mem);
#elif 0 == 1
        robj = PyArray_Scalar(NULL, typecode, NULL);
#elif 0 == 2
        obj = Py_None;
        robj = PyArray_Scalar(&obj, typecode, NULL);
#endif
	Py_DECREF(typecode);
        goto finish;
    }

    arr = PyArray_FromAny(obj, typecode, 0, 0, FORCECAST, NULL);
    if ((arr == NULL) || (PyArray_NDIM(arr) > 0)) {
        return arr;
    }
    /* 0-d array */
    robj = PyArray_ToScalar(PyArray_DATA(arr), (NPY_AO *)arr);
    Py_DECREF(arr);  

finish:
    /* Normal return */
    if ((robj == NULL) || (robj->ob_type == type)) {
        return robj;
    }

    /* This return path occurs when the requested type is not created
       but another scalar object is created instead (i.e. when
       the base-class does the conversion in _WORK macro) */

    /* Need to allocate new type and copy data-area over */
    if (type->tp_itemsize) {
        itemsize = PyString_GET_SIZE(robj);
    }
    else {
        itemsize = 0;
    }
    obj = type->tp_alloc(type, itemsize);
    if (obj == NULL) {
        Py_DECREF(robj);
        return NULL;
    }
    /* typecode will be NULL */
    typecode = PyArray_DescrFromType(PyArray_LONG);
    dest = scalar_value(obj, typecode);
    src = scalar_value(robj, typecode);
    Py_DECREF(typecode);
#if 0 == 0
    *((npy_long *)dest) = *((npy_long *)src);
#elif 0 == 1 /* unicode and strings */
    if (itemsize == 0) { /* unicode */
	itemsize = ((PyUnicodeObject *)robj)->length * sizeof(Py_UNICODE);
    }
    memcpy(dest, src, itemsize);
#elif 0 == 2 /* Object arrays */
    memcpy(dest, src, sizeof(void *));
    Py_INCREF(*((PyObject **)dest));
#endif
    Py_DECREF(robj);
    return obj;
}

#line 1895
static PyObject *
longlong_arrtype_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyObject *obj = NULL;
    PyObject *robj;
    PyObject *arr;
    PyArray_Descr *typecode = NULL;
    int itemsize;
    void *dest, *src;

    /* allow base-class (if any) to do conversion */
    /* If successful, this will jump to finish: */
    _WORK1

    if (!PyArg_ParseTuple(args, "|O", &obj)) {
        return NULL;
    }
    typecode = PyArray_DescrFromType(PyArray_LONGLONG);
    /* typecode is new reference and stolen by
       PyArray_FromAny but not PyArray_Scalar
    */
    if (obj == NULL) {
#if 0 == 0
        char *mem = malloc(sizeof(longlong));

        memset(mem, 0, sizeof(longlong));
        robj = PyArray_Scalar(mem, typecode, NULL);
        free(mem);
#elif 0 == 1
        robj = PyArray_Scalar(NULL, typecode, NULL);
#elif 0 == 2
        obj = Py_None;
        robj = PyArray_Scalar(&obj, typecode, NULL);
#endif
	Py_DECREF(typecode);
        goto finish;
    }

    arr = PyArray_FromAny(obj, typecode, 0, 0, FORCECAST, NULL);
    if ((arr == NULL) || (PyArray_NDIM(arr) > 0)) {
        return arr;
    }
    /* 0-d array */
    robj = PyArray_ToScalar(PyArray_DATA(arr), (NPY_AO *)arr);
    Py_DECREF(arr);  

finish:
    /* Normal return */
    if ((robj == NULL) || (robj->ob_type == type)) {
        return robj;
    }

    /* This return path occurs when the requested type is not created
       but another scalar object is created instead (i.e. when
       the base-class does the conversion in _WORK macro) */

    /* Need to allocate new type and copy data-area over */
    if (type->tp_itemsize) {
        itemsize = PyString_GET_SIZE(robj);
    }
    else {
        itemsize = 0;
    }
    obj = type->tp_alloc(type, itemsize);
    if (obj == NULL) {
        Py_DECREF(robj);
        return NULL;
    }
    /* typecode will be NULL */
    typecode = PyArray_DescrFromType(PyArray_LONGLONG);
    dest = scalar_value(obj, typecode);
    src = scalar_value(robj, typecode);
    Py_DECREF(typecode);
#if 0 == 0
    *((npy_longlong *)dest) = *((npy_longlong *)src);
#elif 0 == 1 /* unicode and strings */
    if (itemsize == 0) { /* unicode */
	itemsize = ((PyUnicodeObject *)robj)->length * sizeof(Py_UNICODE);
    }
    memcpy(dest, src, itemsize);
#elif 0 == 2 /* Object arrays */
    memcpy(dest, src, sizeof(void *));
    Py_INCREF(*((PyObject **)dest));
#endif
    Py_DECREF(robj);
    return obj;
}

#line 1895
static PyObject *
ubyte_arrtype_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyObject *obj = NULL;
    PyObject *robj;
    PyObject *arr;
    PyArray_Descr *typecode = NULL;
    int itemsize;
    void *dest, *src;

    /* allow base-class (if any) to do conversion */
    /* If successful, this will jump to finish: */
    _WORK0

    if (!PyArg_ParseTuple(args, "|O", &obj)) {
        return NULL;
    }
    typecode = PyArray_DescrFromType(PyArray_UBYTE);
    /* typecode is new reference and stolen by
       PyArray_FromAny but not PyArray_Scalar
    */
    if (obj == NULL) {
#if 0 == 0
        char *mem = malloc(sizeof(ubyte));

        memset(mem, 0, sizeof(ubyte));
        robj = PyArray_Scalar(mem, typecode, NULL);
        free(mem);
#elif 0 == 1
        robj = PyArray_Scalar(NULL, typecode, NULL);
#elif 0 == 2
        obj = Py_None;
        robj = PyArray_Scalar(&obj, typecode, NULL);
#endif
	Py_DECREF(typecode);
        goto finish;
    }

    arr = PyArray_FromAny(obj, typecode, 0, 0, FORCECAST, NULL);
    if ((arr == NULL) || (PyArray_NDIM(arr) > 0)) {
        return arr;
    }
    /* 0-d array */
    robj = PyArray_ToScalar(PyArray_DATA(arr), (NPY_AO *)arr);
    Py_DECREF(arr);  

finish:
    /* Normal return */
    if ((robj == NULL) || (robj->ob_type == type)) {
        return robj;
    }

    /* This return path occurs when the requested type is not created
       but another scalar object is created instead (i.e. when
       the base-class does the conversion in _WORK macro) */

    /* Need to allocate new type and copy data-area over */
    if (type->tp_itemsize) {
        itemsize = PyString_GET_SIZE(robj);
    }
    else {
        itemsize = 0;
    }
    obj = type->tp_alloc(type, itemsize);
    if (obj == NULL) {
        Py_DECREF(robj);
        return NULL;
    }
    /* typecode will be NULL */
    typecode = PyArray_DescrFromType(PyArray_UBYTE);
    dest = scalar_value(obj, typecode);
    src = scalar_value(robj, typecode);
    Py_DECREF(typecode);
#if 0 == 0
    *((npy_ubyte *)dest) = *((npy_ubyte *)src);
#elif 0 == 1 /* unicode and strings */
    if (itemsize == 0) { /* unicode */
	itemsize = ((PyUnicodeObject *)robj)->length * sizeof(Py_UNICODE);
    }
    memcpy(dest, src, itemsize);
#elif 0 == 2 /* Object arrays */
    memcpy(dest, src, sizeof(void *));
    Py_INCREF(*((PyObject **)dest));
#endif
    Py_DECREF(robj);
    return obj;
}

#line 1895
static PyObject *
ushort_arrtype_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyObject *obj = NULL;
    PyObject *robj;
    PyObject *arr;
    PyArray_Descr *typecode = NULL;
    int itemsize;
    void *dest, *src;

    /* allow base-class (if any) to do conversion */
    /* If successful, this will jump to finish: */
    _WORK0

    if (!PyArg_ParseTuple(args, "|O", &obj)) {
        return NULL;
    }
    typecode = PyArray_DescrFromType(PyArray_USHORT);
    /* typecode is new reference and stolen by
       PyArray_FromAny but not PyArray_Scalar
    */
    if (obj == NULL) {
#if 0 == 0
        char *mem = malloc(sizeof(ushort));

        memset(mem, 0, sizeof(ushort));
        robj = PyArray_Scalar(mem, typecode, NULL);
        free(mem);
#elif 0 == 1
        robj = PyArray_Scalar(NULL, typecode, NULL);
#elif 0 == 2
        obj = Py_None;
        robj = PyArray_Scalar(&obj, typecode, NULL);
#endif
	Py_DECREF(typecode);
        goto finish;
    }

    arr = PyArray_FromAny(obj, typecode, 0, 0, FORCECAST, NULL);
    if ((arr == NULL) || (PyArray_NDIM(arr) > 0)) {
        return arr;
    }
    /* 0-d array */
    robj = PyArray_ToScalar(PyArray_DATA(arr), (NPY_AO *)arr);
    Py_DECREF(arr);  

finish:
    /* Normal return */
    if ((robj == NULL) || (robj->ob_type == type)) {
        return robj;
    }

    /* This return path occurs when the requested type is not created
       but another scalar object is created instead (i.e. when
       the base-class does the conversion in _WORK macro) */

    /* Need to allocate new type and copy data-area over */
    if (type->tp_itemsize) {
        itemsize = PyString_GET_SIZE(robj);
    }
    else {
        itemsize = 0;
    }
    obj = type->tp_alloc(type, itemsize);
    if (obj == NULL) {
        Py_DECREF(robj);
        return NULL;
    }
    /* typecode will be NULL */
    typecode = PyArray_DescrFromType(PyArray_USHORT);
    dest = scalar_value(obj, typecode);
    src = scalar_value(robj, typecode);
    Py_DECREF(typecode);
#if 0 == 0
    *((npy_ushort *)dest) = *((npy_ushort *)src);
#elif 0 == 1 /* unicode and strings */
    if (itemsize == 0) { /* unicode */
	itemsize = ((PyUnicodeObject *)robj)->length * sizeof(Py_UNICODE);
    }
    memcpy(dest, src, itemsize);
#elif 0 == 2 /* Object arrays */
    memcpy(dest, src, sizeof(void *));
    Py_INCREF(*((PyObject **)dest));
#endif
    Py_DECREF(robj);
    return obj;
}

#line 1895
static PyObject *
uint_arrtype_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyObject *obj = NULL;
    PyObject *robj;
    PyObject *arr;
    PyArray_Descr *typecode = NULL;
    int itemsize;
    void *dest, *src;

    /* allow base-class (if any) to do conversion */
    /* If successful, this will jump to finish: */
    _WORK0

    if (!PyArg_ParseTuple(args, "|O", &obj)) {
        return NULL;
    }
    typecode = PyArray_DescrFromType(PyArray_UINT);
    /* typecode is new reference and stolen by
       PyArray_FromAny but not PyArray_Scalar
    */
    if (obj == NULL) {
#if 0 == 0
        char *mem = malloc(sizeof(uint));

        memset(mem, 0, sizeof(uint));
        robj = PyArray_Scalar(mem, typecode, NULL);
        free(mem);
#elif 0 == 1
        robj = PyArray_Scalar(NULL, typecode, NULL);
#elif 0 == 2
        obj = Py_None;
        robj = PyArray_Scalar(&obj, typecode, NULL);
#endif
	Py_DECREF(typecode);
        goto finish;
    }

    arr = PyArray_FromAny(obj, typecode, 0, 0, FORCECAST, NULL);
    if ((arr == NULL) || (PyArray_NDIM(arr) > 0)) {
        return arr;
    }
    /* 0-d array */
    robj = PyArray_ToScalar(PyArray_DATA(arr), (NPY_AO *)arr);
    Py_DECREF(arr);  

finish:
    /* Normal return */
    if ((robj == NULL) || (robj->ob_type == type)) {
        return robj;
    }

    /* This return path occurs when the requested type is not created
       but another scalar object is created instead (i.e. when
       the base-class does the conversion in _WORK macro) */

    /* Need to allocate new type and copy data-area over */
    if (type->tp_itemsize) {
        itemsize = PyString_GET_SIZE(robj);
    }
    else {
        itemsize = 0;
    }
    obj = type->tp_alloc(type, itemsize);
    if (obj == NULL) {
        Py_DECREF(robj);
        return NULL;
    }
    /* typecode will be NULL */
    typecode = PyArray_DescrFromType(PyArray_UINT);
    dest = scalar_value(obj, typecode);
    src = scalar_value(robj, typecode);
    Py_DECREF(typecode);
#if 0 == 0
    *((npy_uint *)dest) = *((npy_uint *)src);
#elif 0 == 1 /* unicode and strings */
    if (itemsize == 0) { /* unicode */
	itemsize = ((PyUnicodeObject *)robj)->length * sizeof(Py_UNICODE);
    }
    memcpy(dest, src, itemsize);
#elif 0 == 2 /* Object arrays */
    memcpy(dest, src, sizeof(void *));
    Py_INCREF(*((PyObject **)dest));
#endif
    Py_DECREF(robj);
    return obj;
}

#line 1895
static PyObject *
ulong_arrtype_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyObject *obj = NULL;
    PyObject *robj;
    PyObject *arr;
    PyArray_Descr *typecode = NULL;
    int itemsize;
    void *dest, *src;

    /* allow base-class (if any) to do conversion */
    /* If successful, this will jump to finish: */
    _WORK0

    if (!PyArg_ParseTuple(args, "|O", &obj)) {
        return NULL;
    }
    typecode = PyArray_DescrFromType(PyArray_ULONG);
    /* typecode is new reference and stolen by
       PyArray_FromAny but not PyArray_Scalar
    */
    if (obj == NULL) {
#if 0 == 0
        char *mem = malloc(sizeof(ulong));

        memset(mem, 0, sizeof(ulong));
        robj = PyArray_Scalar(mem, typecode, NULL);
        free(mem);
#elif 0 == 1
        robj = PyArray_Scalar(NULL, typecode, NULL);
#elif 0 == 2
        obj = Py_None;
        robj = PyArray_Scalar(&obj, typecode, NULL);
#endif
	Py_DECREF(typecode);
        goto finish;
    }

    arr = PyArray_FromAny(obj, typecode, 0, 0, FORCECAST, NULL);
    if ((arr == NULL) || (PyArray_NDIM(arr) > 0)) {
        return arr;
    }
    /* 0-d array */
    robj = PyArray_ToScalar(PyArray_DATA(arr), (NPY_AO *)arr);
    Py_DECREF(arr);  

finish:
    /* Normal return */
    if ((robj == NULL) || (robj->ob_type == type)) {
        return robj;
    }

    /* This return path occurs when the requested type is not created
       but another scalar object is created instead (i.e. when
       the base-class does the conversion in _WORK macro) */

    /* Need to allocate new type and copy data-area over */
    if (type->tp_itemsize) {
        itemsize = PyString_GET_SIZE(robj);
    }
    else {
        itemsize = 0;
    }
    obj = type->tp_alloc(type, itemsize);
    if (obj == NULL) {
        Py_DECREF(robj);
        return NULL;
    }
    /* typecode will be NULL */
    typecode = PyArray_DescrFromType(PyArray_ULONG);
    dest = scalar_value(obj, typecode);
    src = scalar_value(robj, typecode);
    Py_DECREF(typecode);
#if 0 == 0
    *((npy_ulong *)dest) = *((npy_ulong *)src);
#elif 0 == 1 /* unicode and strings */
    if (itemsize == 0) { /* unicode */
	itemsize = ((PyUnicodeObject *)robj)->length * sizeof(Py_UNICODE);
    }
    memcpy(dest, src, itemsize);
#elif 0 == 2 /* Object arrays */
    memcpy(dest, src, sizeof(void *));
    Py_INCREF(*((PyObject **)dest));
#endif
    Py_DECREF(robj);
    return obj;
}

#line 1895
static PyObject *
ulonglong_arrtype_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyObject *obj = NULL;
    PyObject *robj;
    PyObject *arr;
    PyArray_Descr *typecode = NULL;
    int itemsize;
    void *dest, *src;

    /* allow base-class (if any) to do conversion */
    /* If successful, this will jump to finish: */
    _WORK0

    if (!PyArg_ParseTuple(args, "|O", &obj)) {
        return NULL;
    }
    typecode = PyArray_DescrFromType(PyArray_ULONGLONG);
    /* typecode is new reference and stolen by
       PyArray_FromAny but not PyArray_Scalar
    */
    if (obj == NULL) {
#if 0 == 0
        char *mem = malloc(sizeof(ulonglong));

        memset(mem, 0, sizeof(ulonglong));
        robj = PyArray_Scalar(mem, typecode, NULL);
        free(mem);
#elif 0 == 1
        robj = PyArray_Scalar(NULL, typecode, NULL);
#elif 0 == 2
        obj = Py_None;
        robj = PyArray_Scalar(&obj, typecode, NULL);
#endif
	Py_DECREF(typecode);
        goto finish;
    }

    arr = PyArray_FromAny(obj, typecode, 0, 0, FORCECAST, NULL);
    if ((arr == NULL) || (PyArray_NDIM(arr) > 0)) {
        return arr;
    }
    /* 0-d array */
    robj = PyArray_ToScalar(PyArray_DATA(arr), (NPY_AO *)arr);
    Py_DECREF(arr);  

finish:
    /* Normal return */
    if ((robj == NULL) || (robj->ob_type == type)) {
        return robj;
    }

    /* This return path occurs when the requested type is not created
       but another scalar object is created instead (i.e. when
       the base-class does the conversion in _WORK macro) */

    /* Need to allocate new type and copy data-area over */
    if (type->tp_itemsize) {
        itemsize = PyString_GET_SIZE(robj);
    }
    else {
        itemsize = 0;
    }
    obj = type->tp_alloc(type, itemsize);
    if (obj == NULL) {
        Py_DECREF(robj);
        return NULL;
    }
    /* typecode will be NULL */
    typecode = PyArray_DescrFromType(PyArray_ULONGLONG);
    dest = scalar_value(obj, typecode);
    src = scalar_value(robj, typecode);
    Py_DECREF(typecode);
#if 0 == 0
    *((npy_ulonglong *)dest) = *((npy_ulonglong *)src);
#elif 0 == 1 /* unicode and strings */
    if (itemsize == 0) { /* unicode */
	itemsize = ((PyUnicodeObject *)robj)->length * sizeof(Py_UNICODE);
    }
    memcpy(dest, src, itemsize);
#elif 0 == 2 /* Object arrays */
    memcpy(dest, src, sizeof(void *));
    Py_INCREF(*((PyObject **)dest));
#endif
    Py_DECREF(robj);
    return obj;
}

#line 1895
static PyObject *
float_arrtype_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyObject *obj = NULL;
    PyObject *robj;
    PyObject *arr;
    PyArray_Descr *typecode = NULL;
    int itemsize;
    void *dest, *src;

    /* allow base-class (if any) to do conversion */
    /* If successful, this will jump to finish: */
    _WORK0

    if (!PyArg_ParseTuple(args, "|O", &obj)) {
        return NULL;
    }
    typecode = PyArray_DescrFromType(PyArray_FLOAT);
    /* typecode is new reference and stolen by
       PyArray_FromAny but not PyArray_Scalar
    */
    if (obj == NULL) {
#if 0 == 0
        char *mem = malloc(sizeof(float));

        memset(mem, 0, sizeof(float));
        robj = PyArray_Scalar(mem, typecode, NULL);
        free(mem);
#elif 0 == 1
        robj = PyArray_Scalar(NULL, typecode, NULL);
#elif 0 == 2
        obj = Py_None;
        robj = PyArray_Scalar(&obj, typecode, NULL);
#endif
	Py_DECREF(typecode);
        goto finish;
    }

    arr = PyArray_FromAny(obj, typecode, 0, 0, FORCECAST, NULL);
    if ((arr == NULL) || (PyArray_NDIM(arr) > 0)) {
        return arr;
    }
    /* 0-d array */
    robj = PyArray_ToScalar(PyArray_DATA(arr), (NPY_AO *)arr);
    Py_DECREF(arr);  

finish:
    /* Normal return */
    if ((robj == NULL) || (robj->ob_type == type)) {
        return robj;
    }

    /* This return path occurs when the requested type is not created
       but another scalar object is created instead (i.e. when
       the base-class does the conversion in _WORK macro) */

    /* Need to allocate new type and copy data-area over */
    if (type->tp_itemsize) {
        itemsize = PyString_GET_SIZE(robj);
    }
    else {
        itemsize = 0;
    }
    obj = type->tp_alloc(type, itemsize);
    if (obj == NULL) {
        Py_DECREF(robj);
        return NULL;
    }
    /* typecode will be NULL */
    typecode = PyArray_DescrFromType(PyArray_FLOAT);
    dest = scalar_value(obj, typecode);
    src = scalar_value(robj, typecode);
    Py_DECREF(typecode);
#if 0 == 0
    *((npy_float *)dest) = *((npy_float *)src);
#elif 0 == 1 /* unicode and strings */
    if (itemsize == 0) { /* unicode */
	itemsize = ((PyUnicodeObject *)robj)->length * sizeof(Py_UNICODE);
    }
    memcpy(dest, src, itemsize);
#elif 0 == 2 /* Object arrays */
    memcpy(dest, src, sizeof(void *));
    Py_INCREF(*((PyObject **)dest));
#endif
    Py_DECREF(robj);
    return obj;
}

#line 1895
static PyObject *
double_arrtype_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyObject *obj = NULL;
    PyObject *robj;
    PyObject *arr;
    PyArray_Descr *typecode = NULL;
    int itemsize;
    void *dest, *src;

    /* allow base-class (if any) to do conversion */
    /* If successful, this will jump to finish: */
    _WORK1

    if (!PyArg_ParseTuple(args, "|O", &obj)) {
        return NULL;
    }
    typecode = PyArray_DescrFromType(PyArray_DOUBLE);
    /* typecode is new reference and stolen by
       PyArray_FromAny but not PyArray_Scalar
    */
    if (obj == NULL) {
#if 0 == 0
        char *mem = malloc(sizeof(double));

        memset(mem, 0, sizeof(double));
        robj = PyArray_Scalar(mem, typecode, NULL);
        free(mem);
#elif 0 == 1
        robj = PyArray_Scalar(NULL, typecode, NULL);
#elif 0 == 2
        obj = Py_None;
        robj = PyArray_Scalar(&obj, typecode, NULL);
#endif
	Py_DECREF(typecode);
        goto finish;
    }

    arr = PyArray_FromAny(obj, typecode, 0, 0, FORCECAST, NULL);
    if ((arr == NULL) || (PyArray_NDIM(arr) > 0)) {
        return arr;
    }
    /* 0-d array */
    robj = PyArray_ToScalar(PyArray_DATA(arr), (NPY_AO *)arr);
    Py_DECREF(arr);  

finish:
    /* Normal return */
    if ((robj == NULL) || (robj->ob_type == type)) {
        return robj;
    }

    /* This return path occurs when the requested type is not created
       but another scalar object is created instead (i.e. when
       the base-class does the conversion in _WORK macro) */

    /* Need to allocate new type and copy data-area over */
    if (type->tp_itemsize) {
        itemsize = PyString_GET_SIZE(robj);
    }
    else {
        itemsize = 0;
    }
    obj = type->tp_alloc(type, itemsize);
    if (obj == NULL) {
        Py_DECREF(robj);
        return NULL;
    }
    /* typecode will be NULL */
    typecode = PyArray_DescrFromType(PyArray_DOUBLE);
    dest = scalar_value(obj, typecode);
    src = scalar_value(robj, typecode);
    Py_DECREF(typecode);
#if 0 == 0
    *((npy_double *)dest) = *((npy_double *)src);
#elif 0 == 1 /* unicode and strings */
    if (itemsize == 0) { /* unicode */
	itemsize = ((PyUnicodeObject *)robj)->length * sizeof(Py_UNICODE);
    }
    memcpy(dest, src, itemsize);
#elif 0 == 2 /* Object arrays */
    memcpy(dest, src, sizeof(void *));
    Py_INCREF(*((PyObject **)dest));
#endif
    Py_DECREF(robj);
    return obj;
}

#line 1895
static PyObject *
longdouble_arrtype_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyObject *obj = NULL;
    PyObject *robj;
    PyObject *arr;
    PyArray_Descr *typecode = NULL;
    int itemsize;
    void *dest, *src;

    /* allow base-class (if any) to do conversion */
    /* If successful, this will jump to finish: */
    _WORK0

    if (!PyArg_ParseTuple(args, "|O", &obj)) {
        return NULL;
    }
    typecode = PyArray_DescrFromType(PyArray_LONGDOUBLE);
    /* typecode is new reference and stolen by
       PyArray_FromAny but not PyArray_Scalar
    */
    if (obj == NULL) {
#if 0 == 0
        char *mem = malloc(sizeof(longdouble));

        memset(mem, 0, sizeof(longdouble));
        robj = PyArray_Scalar(mem, typecode, NULL);
        free(mem);
#elif 0 == 1
        robj = PyArray_Scalar(NULL, typecode, NULL);
#elif 0 == 2
        obj = Py_None;
        robj = PyArray_Scalar(&obj, typecode, NULL);
#endif
	Py_DECREF(typecode);
        goto finish;
    }

    arr = PyArray_FromAny(obj, typecode, 0, 0, FORCECAST, NULL);
    if ((arr == NULL) || (PyArray_NDIM(arr) > 0)) {
        return arr;
    }
    /* 0-d array */
    robj = PyArray_ToScalar(PyArray_DATA(arr), (NPY_AO *)arr);
    Py_DECREF(arr);  

finish:
    /* Normal return */
    if ((robj == NULL) || (robj->ob_type == type)) {
        return robj;
    }

    /* This return path occurs when the requested type is not created
       but another scalar object is created instead (i.e. when
       the base-class does the conversion in _WORK macro) */

    /* Need to allocate new type and copy data-area over */
    if (type->tp_itemsize) {
        itemsize = PyString_GET_SIZE(robj);
    }
    else {
        itemsize = 0;
    }
    obj = type->tp_alloc(type, itemsize);
    if (obj == NULL) {
        Py_DECREF(robj);
        return NULL;
    }
    /* typecode will be NULL */
    typecode = PyArray_DescrFromType(PyArray_LONGDOUBLE);
    dest = scalar_value(obj, typecode);
    src = scalar_value(robj, typecode);
    Py_DECREF(typecode);
#if 0 == 0
    *((npy_longdouble *)dest) = *((npy_longdouble *)src);
#elif 0 == 1 /* unicode and strings */
    if (itemsize == 0) { /* unicode */
	itemsize = ((PyUnicodeObject *)robj)->length * sizeof(Py_UNICODE);
    }
    memcpy(dest, src, itemsize);
#elif 0 == 2 /* Object arrays */
    memcpy(dest, src, sizeof(void *));
    Py_INCREF(*((PyObject **)dest));
#endif
    Py_DECREF(robj);
    return obj;
}

#line 1895
static PyObject *
cfloat_arrtype_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyObject *obj = NULL;
    PyObject *robj;
    PyObject *arr;
    PyArray_Descr *typecode = NULL;
    int itemsize;
    void *dest, *src;

    /* allow base-class (if any) to do conversion */
    /* If successful, this will jump to finish: */
    _WORK0

    if (!PyArg_ParseTuple(args, "|O", &obj)) {
        return NULL;
    }
    typecode = PyArray_DescrFromType(PyArray_CFLOAT);
    /* typecode is new reference and stolen by
       PyArray_FromAny but not PyArray_Scalar
    */
    if (obj == NULL) {
#if 0 == 0
        char *mem = malloc(sizeof(cfloat));

        memset(mem, 0, sizeof(cfloat));
        robj = PyArray_Scalar(mem, typecode, NULL);
        free(mem);
#elif 0 == 1
        robj = PyArray_Scalar(NULL, typecode, NULL);
#elif 0 == 2
        obj = Py_None;
        robj = PyArray_Scalar(&obj, typecode, NULL);
#endif
	Py_DECREF(typecode);
        goto finish;
    }

    arr = PyArray_FromAny(obj, typecode, 0, 0, FORCECAST, NULL);
    if ((arr == NULL) || (PyArray_NDIM(arr) > 0)) {
        return arr;
    }
    /* 0-d array */
    robj = PyArray_ToScalar(PyArray_DATA(arr), (NPY_AO *)arr);
    Py_DECREF(arr);  

finish:
    /* Normal return */
    if ((robj == NULL) || (robj->ob_type == type)) {
        return robj;
    }

    /* This return path occurs when the requested type is not created
       but another scalar object is created instead (i.e. when
       the base-class does the conversion in _WORK macro) */

    /* Need to allocate new type and copy data-area over */
    if (type->tp_itemsize) {
        itemsize = PyString_GET_SIZE(robj);
    }
    else {
        itemsize = 0;
    }
    obj = type->tp_alloc(type, itemsize);
    if (obj == NULL) {
        Py_DECREF(robj);
        return NULL;
    }
    /* typecode will be NULL */
    typecode = PyArray_DescrFromType(PyArray_CFLOAT);
    dest = scalar_value(obj, typecode);
    src = scalar_value(robj, typecode);
    Py_DECREF(typecode);
#if 0 == 0
    *((npy_cfloat *)dest) = *((npy_cfloat *)src);
#elif 0 == 1 /* unicode and strings */
    if (itemsize == 0) { /* unicode */
	itemsize = ((PyUnicodeObject *)robj)->length * sizeof(Py_UNICODE);
    }
    memcpy(dest, src, itemsize);
#elif 0 == 2 /* Object arrays */
    memcpy(dest, src, sizeof(void *));
    Py_INCREF(*((PyObject **)dest));
#endif
    Py_DECREF(robj);
    return obj;
}

#line 1895
static PyObject *
cdouble_arrtype_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyObject *obj = NULL;
    PyObject *robj;
    PyObject *arr;
    PyArray_Descr *typecode = NULL;
    int itemsize;
    void *dest, *src;

    /* allow base-class (if any) to do conversion */
    /* If successful, this will jump to finish: */
    _WORK0

    if (!PyArg_ParseTuple(args, "|O", &obj)) {
        return NULL;
    }
    typecode = PyArray_DescrFromType(PyArray_CDOUBLE);
    /* typecode is new reference and stolen by
       PyArray_FromAny but not PyArray_Scalar
    */
    if (obj == NULL) {
#if 0 == 0
        char *mem = malloc(sizeof(cdouble));

        memset(mem, 0, sizeof(cdouble));
        robj = PyArray_Scalar(mem, typecode, NULL);
        free(mem);
#elif 0 == 1
        robj = PyArray_Scalar(NULL, typecode, NULL);
#elif 0 == 2
        obj = Py_None;
        robj = PyArray_Scalar(&obj, typecode, NULL);
#endif
	Py_DECREF(typecode);
        goto finish;
    }

    arr = PyArray_FromAny(obj, typecode, 0, 0, FORCECAST, NULL);
    if ((arr == NULL) || (PyArray_NDIM(arr) > 0)) {
        return arr;
    }
    /* 0-d array */
    robj = PyArray_ToScalar(PyArray_DATA(arr), (NPY_AO *)arr);
    Py_DECREF(arr);  

finish:
    /* Normal return */
    if ((robj == NULL) || (robj->ob_type == type)) {
        return robj;
    }

    /* This return path occurs when the requested type is not created
       but another scalar object is created instead (i.e. when
       the base-class does the conversion in _WORK macro) */

    /* Need to allocate new type and copy data-area over */
    if (type->tp_itemsize) {
        itemsize = PyString_GET_SIZE(robj);
    }
    else {
        itemsize = 0;
    }
    obj = type->tp_alloc(type, itemsize);
    if (obj == NULL) {
        Py_DECREF(robj);
        return NULL;
    }
    /* typecode will be NULL */
    typecode = PyArray_DescrFromType(PyArray_CDOUBLE);
    dest = scalar_value(obj, typecode);
    src = scalar_value(robj, typecode);
    Py_DECREF(typecode);
#if 0 == 0
    *((npy_cdouble *)dest) = *((npy_cdouble *)src);
#elif 0 == 1 /* unicode and strings */
    if (itemsize == 0) { /* unicode */
	itemsize = ((PyUnicodeObject *)robj)->length * sizeof(Py_UNICODE);
    }
    memcpy(dest, src, itemsize);
#elif 0 == 2 /* Object arrays */
    memcpy(dest, src, sizeof(void *));
    Py_INCREF(*((PyObject **)dest));
#endif
    Py_DECREF(robj);
    return obj;
}

#line 1895
static PyObject *
clongdouble_arrtype_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyObject *obj = NULL;
    PyObject *robj;
    PyObject *arr;
    PyArray_Descr *typecode = NULL;
    int itemsize;
    void *dest, *src;

    /* allow base-class (if any) to do conversion */
    /* If successful, this will jump to finish: */
    _WORK0

    if (!PyArg_ParseTuple(args, "|O", &obj)) {
        return NULL;
    }
    typecode = PyArray_DescrFromType(PyArray_CLONGDOUBLE);
    /* typecode is new reference and stolen by
       PyArray_FromAny but not PyArray_Scalar
    */
    if (obj == NULL) {
#if 0 == 0
        char *mem = malloc(sizeof(clongdouble));

        memset(mem, 0, sizeof(clongdouble));
        robj = PyArray_Scalar(mem, typecode, NULL);
        free(mem);
#elif 0 == 1
        robj = PyArray_Scalar(NULL, typecode, NULL);
#elif 0 == 2
        obj = Py_None;
        robj = PyArray_Scalar(&obj, typecode, NULL);
#endif
	Py_DECREF(typecode);
        goto finish;
    }

    arr = PyArray_FromAny(obj, typecode, 0, 0, FORCECAST, NULL);
    if ((arr == NULL) || (PyArray_NDIM(arr) > 0)) {
        return arr;
    }
    /* 0-d array */
    robj = PyArray_ToScalar(PyArray_DATA(arr), (NPY_AO *)arr);
    Py_DECREF(arr);  

finish:
    /* Normal return */
    if ((robj == NULL) || (robj->ob_type == type)) {
        return robj;
    }

    /* This return path occurs when the requested type is not created
       but another scalar object is created instead (i.e. when
       the base-class does the conversion in _WORK macro) */

    /* Need to allocate new type and copy data-area over */
    if (type->tp_itemsize) {
        itemsize = PyString_GET_SIZE(robj);
    }
    else {
        itemsize = 0;
    }
    obj = type->tp_alloc(type, itemsize);
    if (obj == NULL) {
        Py_DECREF(robj);
        return NULL;
    }
    /* typecode will be NULL */
    typecode = PyArray_DescrFromType(PyArray_CLONGDOUBLE);
    dest = scalar_value(obj, typecode);
    src = scalar_value(robj, typecode);
    Py_DECREF(typecode);
#if 0 == 0
    *((npy_clongdouble *)dest) = *((npy_clongdouble *)src);
#elif 0 == 1 /* unicode and strings */
    if (itemsize == 0) { /* unicode */
	itemsize = ((PyUnicodeObject *)robj)->length * sizeof(Py_UNICODE);
    }
    memcpy(dest, src, itemsize);
#elif 0 == 2 /* Object arrays */
    memcpy(dest, src, sizeof(void *));
    Py_INCREF(*((PyObject **)dest));
#endif
    Py_DECREF(robj);
    return obj;
}

#line 1895
static PyObject *
string_arrtype_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyObject *obj = NULL;
    PyObject *robj;
    PyObject *arr;
    PyArray_Descr *typecode = NULL;
    int itemsize;
    void *dest, *src;

    /* allow base-class (if any) to do conversion */
    /* If successful, this will jump to finish: */
    _WORKz

    if (!PyArg_ParseTuple(args, "|O", &obj)) {
        return NULL;
    }
    typecode = PyArray_DescrFromType(PyArray_STRING);
    /* typecode is new reference and stolen by
       PyArray_FromAny but not PyArray_Scalar
    */
    if (obj == NULL) {
#if 1 == 0
        char *mem = malloc(sizeof(string));

        memset(mem, 0, sizeof(string));
        robj = PyArray_Scalar(mem, typecode, NULL);
        free(mem);
#elif 1 == 1
        robj = PyArray_Scalar(NULL, typecode, NULL);
#elif 1 == 2
        obj = Py_None;
        robj = PyArray_Scalar(&obj, typecode, NULL);
#endif
	Py_DECREF(typecode);
        goto finish;
    }

    arr = PyArray_FromAny(obj, typecode, 0, 0, FORCECAST, NULL);
    if ((arr == NULL) || (PyArray_NDIM(arr) > 0)) {
        return arr;
    }
    /* 0-d array */
    robj = PyArray_ToScalar(PyArray_DATA(arr), (NPY_AO *)arr);
    Py_DECREF(arr);  

finish:
    /* Normal return */
    if ((robj == NULL) || (robj->ob_type == type)) {
        return robj;
    }

    /* This return path occurs when the requested type is not created
       but another scalar object is created instead (i.e. when
       the base-class does the conversion in _WORK macro) */

    /* Need to allocate new type and copy data-area over */
    if (type->tp_itemsize) {
        itemsize = PyString_GET_SIZE(robj);
    }
    else {
        itemsize = 0;
    }
    obj = type->tp_alloc(type, itemsize);
    if (obj == NULL) {
        Py_DECREF(robj);
        return NULL;
    }
    /* typecode will be NULL */
    typecode = PyArray_DescrFromType(PyArray_STRING);
    dest = scalar_value(obj, typecode);
    src = scalar_value(robj, typecode);
    Py_DECREF(typecode);
#if 1 == 0
    *((npy_string *)dest) = *((npy_string *)src);
#elif 1 == 1 /* unicode and strings */
    if (itemsize == 0) { /* unicode */
	itemsize = ((PyUnicodeObject *)robj)->length * sizeof(Py_UNICODE);
    }
    memcpy(dest, src, itemsize);
#elif 1 == 2 /* Object arrays */
    memcpy(dest, src, sizeof(void *));
    Py_INCREF(*((PyObject **)dest));
#endif
    Py_DECREF(robj);
    return obj;
}

#line 1895
static PyObject *
unicode_arrtype_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyObject *obj = NULL;
    PyObject *robj;
    PyObject *arr;
    PyArray_Descr *typecode = NULL;
    int itemsize;
    void *dest, *src;

    /* allow base-class (if any) to do conversion */
    /* If successful, this will jump to finish: */
    _WORKz

    if (!PyArg_ParseTuple(args, "|O", &obj)) {
        return NULL;
    }
    typecode = PyArray_DescrFromType(PyArray_UNICODE);
    /* typecode is new reference and stolen by
       PyArray_FromAny but not PyArray_Scalar
    */
    if (obj == NULL) {
#if 1 == 0
        char *mem = malloc(sizeof(unicode));

        memset(mem, 0, sizeof(unicode));
        robj = PyArray_Scalar(mem, typecode, NULL);
        free(mem);
#elif 1 == 1
        robj = PyArray_Scalar(NULL, typecode, NULL);
#elif 1 == 2
        obj = Py_None;
        robj = PyArray_Scalar(&obj, typecode, NULL);
#endif
	Py_DECREF(typecode);
        goto finish;
    }

    arr = PyArray_FromAny(obj, typecode, 0, 0, FORCECAST, NULL);
    if ((arr == NULL) || (PyArray_NDIM(arr) > 0)) {
        return arr;
    }
    /* 0-d array */
    robj = PyArray_ToScalar(PyArray_DATA(arr), (NPY_AO *)arr);
    Py_DECREF(arr);  

finish:
    /* Normal return */
    if ((robj == NULL) || (robj->ob_type == type)) {
        return robj;
    }

    /* This return path occurs when the requested type is not created
       but another scalar object is created instead (i.e. when
       the base-class does the conversion in _WORK macro) */

    /* Need to allocate new type and copy data-area over */
    if (type->tp_itemsize) {
        itemsize = PyString_GET_SIZE(robj);
    }
    else {
        itemsize = 0;
    }
    obj = type->tp_alloc(type, itemsize);
    if (obj == NULL) {
        Py_DECREF(robj);
        return NULL;
    }
    /* typecode will be NULL */
    typecode = PyArray_DescrFromType(PyArray_UNICODE);
    dest = scalar_value(obj, typecode);
    src = scalar_value(robj, typecode);
    Py_DECREF(typecode);
#if 1 == 0
    *((npy_unicode *)dest) = *((npy_unicode *)src);
#elif 1 == 1 /* unicode and strings */
    if (itemsize == 0) { /* unicode */
	itemsize = ((PyUnicodeObject *)robj)->length * sizeof(Py_UNICODE);
    }
    memcpy(dest, src, itemsize);
#elif 1 == 2 /* Object arrays */
    memcpy(dest, src, sizeof(void *));
    Py_INCREF(*((PyObject **)dest));
#endif
    Py_DECREF(robj);
    return obj;
}

#line 1895
static PyObject *
object_arrtype_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyObject *obj = NULL;
    PyObject *robj;
    PyObject *arr;
    PyArray_Descr *typecode = NULL;
    int itemsize;
    void *dest, *src;

    /* allow base-class (if any) to do conversion */
    /* If successful, this will jump to finish: */
    _WORK1

    if (!PyArg_ParseTuple(args, "|O", &obj)) {
        return NULL;
    }
    typecode = PyArray_DescrFromType(PyArray_OBJECT);
    /* typecode is new reference and stolen by
       PyArray_FromAny but not PyArray_Scalar
    */
    if (obj == NULL) {
#if 2 == 0
        char *mem = malloc(sizeof(object));

        memset(mem, 0, sizeof(object));
        robj = PyArray_Scalar(mem, typecode, NULL);
        free(mem);
#elif 2 == 1
        robj = PyArray_Scalar(NULL, typecode, NULL);
#elif 2 == 2
        obj = Py_None;
        robj = PyArray_Scalar(&obj, typecode, NULL);
#endif
	Py_DECREF(typecode);
        goto finish;
    }

    arr = PyArray_FromAny(obj, typecode, 0, 0, FORCECAST, NULL);
    if ((arr == NULL) || (PyArray_NDIM(arr) > 0)) {
        return arr;
    }
    /* 0-d array */
    robj = PyArray_ToScalar(PyArray_DATA(arr), (NPY_AO *)arr);
    Py_DECREF(arr);  

finish:
    /* Normal return */
    if ((robj == NULL) || (robj->ob_type == type)) {
        return robj;
    }

    /* This return path occurs when the requested type is not created
       but another scalar object is created instead (i.e. when
       the base-class does the conversion in _WORK macro) */

    /* Need to allocate new type and copy data-area over */
    if (type->tp_itemsize) {
        itemsize = PyString_GET_SIZE(robj);
    }
    else {
        itemsize = 0;
    }
    obj = type->tp_alloc(type, itemsize);
    if (obj == NULL) {
        Py_DECREF(robj);
        return NULL;
    }
    /* typecode will be NULL */
    typecode = PyArray_DescrFromType(PyArray_OBJECT);
    dest = scalar_value(obj, typecode);
    src = scalar_value(robj, typecode);
    Py_DECREF(typecode);
#if 2 == 0
    *((npy_object *)dest) = *((npy_object *)src);
#elif 2 == 1 /* unicode and strings */
    if (itemsize == 0) { /* unicode */
	itemsize = ((PyUnicodeObject *)robj)->length * sizeof(Py_UNICODE);
    }
    memcpy(dest, src, itemsize);
#elif 2 == 2 /* Object arrays */
    memcpy(dest, src, sizeof(void *));
    Py_INCREF(*((PyObject **)dest));
#endif
    Py_DECREF(robj);
    return obj;
}


#undef _WORK1
#undef _WORKz
#undef _WORK0
#undef _WORK

/* bool->tp_new only returns Py_True or Py_False */
static PyObject *
bool_arrtype_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyObject *obj=NULL;
    PyObject *arr;

    if (!PyArg_ParseTuple(args, "|O", &obj)) return NULL;
    if (obj == NULL)
        PyArrayScalar_RETURN_FALSE;
    if (obj == Py_False)
        PyArrayScalar_RETURN_FALSE;
    if (obj == Py_True)
        PyArrayScalar_RETURN_TRUE;
    arr = PyArray_FROM_OTF(obj, PyArray_BOOL, FORCECAST);
    if (arr && 0 == PyArray_NDIM(arr)) {
        Bool val = *((Bool *)PyArray_DATA(arr));
        Py_DECREF(arr);
        PyArrayScalar_RETURN_BOOL_FROM_LONG(val);
    }
    return PyArray_Return((PyArrayObject *)arr);
}

static PyObject *
bool_arrtype_and(PyObject *a, PyObject *b)
{
    if (PyArray_IsScalar(a, Bool) && PyArray_IsScalar(b, Bool))
        PyArrayScalar_RETURN_BOOL_FROM_LONG
            ((a == PyArrayScalar_True)&(b == PyArrayScalar_True));
    return PyGenericArrType_Type.tp_as_number->nb_and(a, b);
}

static PyObject *
bool_arrtype_or(PyObject *a, PyObject *b)
{
    if (PyArray_IsScalar(a, Bool) && PyArray_IsScalar(b, Bool))
        PyArrayScalar_RETURN_BOOL_FROM_LONG
            ((a == PyArrayScalar_True)|(b == PyArrayScalar_True));
    return PyGenericArrType_Type.tp_as_number->nb_or(a, b);
}

static PyObject *
bool_arrtype_xor(PyObject *a, PyObject *b)
{
    if (PyArray_IsScalar(a, Bool) && PyArray_IsScalar(b, Bool))
        PyArrayScalar_RETURN_BOOL_FROM_LONG
            ((a == PyArrayScalar_True)^(b == PyArrayScalar_True));
    return PyGenericArrType_Type.tp_as_number->nb_xor(a, b);
}

static int
bool_arrtype_nonzero(PyObject *a)
{
    return a == PyArrayScalar_True;
}

#if PY_VERSION_HEX >= 0x02050000
#line 2051
static PyNumberMethods byte_arrtype_as_number;
static PyObject *
byte_index(PyObject *self)
{
    return PyInt_FromLong(PyArrayScalar_VAL(self, Byte));
}

#line 2051
static PyNumberMethods short_arrtype_as_number;
static PyObject *
short_index(PyObject *self)
{
    return PyInt_FromLong(PyArrayScalar_VAL(self, Short));
}

#line 2051
static PyNumberMethods int_arrtype_as_number;
static PyObject *
int_index(PyObject *self)
{
    return PyInt_FromLong(PyArrayScalar_VAL(self, Int));
}

#line 2051
static PyNumberMethods long_arrtype_as_number;
static PyObject *
long_index(PyObject *self)
{
    return PyInt_FromLong(PyArrayScalar_VAL(self, Long));
}

#line 2051
static PyNumberMethods ubyte_arrtype_as_number;
static PyObject *
ubyte_index(PyObject *self)
{
    return PyInt_FromLong(PyArrayScalar_VAL(self, UByte));
}

#line 2051
static PyNumberMethods ushort_arrtype_as_number;
static PyObject *
ushort_index(PyObject *self)
{
    return PyInt_FromLong(PyArrayScalar_VAL(self, UShort));
}

#line 2051
static PyNumberMethods longlong_arrtype_as_number;
static PyObject *
longlong_index(PyObject *self)
{
    return PyLong_FromLongLong(PyArrayScalar_VAL(self, LongLong));
}

#line 2051
static PyNumberMethods uint_arrtype_as_number;
static PyObject *
uint_index(PyObject *self)
{
    return PyLong_FromUnsignedLong(PyArrayScalar_VAL(self, UInt));
}

#line 2051
static PyNumberMethods ulong_arrtype_as_number;
static PyObject *
ulong_index(PyObject *self)
{
    return PyLong_FromUnsignedLong(PyArrayScalar_VAL(self, ULong));
}

#line 2051
static PyNumberMethods ulonglong_arrtype_as_number;
static PyObject *
ulonglong_index(PyObject *self)
{
    return PyLong_FromUnsignedLongLong(PyArrayScalar_VAL(self, ULongLong));
}

static PyObject *
bool_index(PyObject *a)
{
    return PyInt_FromLong(PyArrayScalar_VAL(a, Bool));
}
#endif

/* Arithmetic methods -- only so we can override &, |, ^. */
static PyNumberMethods bool_arrtype_as_number = {
    0,                                      /* nb_add */
    0,                                      /* nb_subtract */
    0,                                      /* nb_multiply */
    0,                                      /* nb_divide */
    0,                                      /* nb_remainder */
    0,                                      /* nb_divmod */
    0,                                      /* nb_power */
    0,                                      /* nb_negative */
    0,                                      /* nb_positive */
    0,                                      /* nb_absolute */
    (inquiry)bool_arrtype_nonzero,          /* nb_nonzero */
    0,                                      /* nb_invert */
    0,                                      /* nb_lshift */
    0,                                      /* nb_rshift */
    (binaryfunc)bool_arrtype_and,           /* nb_and */
    (binaryfunc)bool_arrtype_xor,           /* nb_xor */
    (binaryfunc)bool_arrtype_or,            /* nb_or */
};

static PyObject *
void_arrtype_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyObject *obj, *arr;
    ulonglong memu=1;
    PyObject *new=NULL;
    char *destptr;

    if (!PyArg_ParseTuple(args, "O", &obj)) return NULL;
    /* For a VOID scalar first see if obj is an integer or long
       and create new memory of that size (filled with 0) for the scalar
       */

    if (PyLong_Check(obj) || PyInt_Check(obj) || \
            PyArray_IsScalar(obj, Integer) ||
            (PyArray_Check(obj) && PyArray_NDIM(obj)==0 &&      \
             PyArray_ISINTEGER(obj))) {
        new = obj->ob_type->tp_as_number->nb_long(obj);
    }
    if (new && PyLong_Check(new)) {
        PyObject *ret;
        memu = PyLong_AsUnsignedLongLong(new);
        Py_DECREF(new);
        if (PyErr_Occurred() || (memu > MAX_INT)) {
            PyErr_Clear();
            PyErr_Format(PyExc_OverflowError,
                    "size must be smaller than %d",
                    (int) MAX_INT);
            return NULL;
        }
        destptr = PyDataMem_NEW((int) memu);
        if (destptr == NULL) return PyErr_NoMemory();
        ret = type->tp_alloc(type, 0);
        if (ret == NULL) {
            PyDataMem_FREE(destptr);
            return PyErr_NoMemory();
        }
        ((PyVoidScalarObject *)ret)->obval = destptr;
        ((PyVoidScalarObject *)ret)->ob_size = (int) memu;
        ((PyVoidScalarObject *)ret)->descr = \
                                             PyArray_DescrNewFromType(PyArray_VOID);
        ((PyVoidScalarObject *)ret)->descr->elsize = (int) memu;
        ((PyVoidScalarObject *)ret)->flags = BEHAVED | OWNDATA;
        ((PyVoidScalarObject *)ret)->base = NULL;
        memset(destptr, '\0', (size_t) memu);
        return ret;
    }

    arr = PyArray_FROM_OTF(obj, PyArray_VOID, FORCECAST);
    return PyArray_Return((PyArrayObject *)arr);
}


/****************  Define Hash functions ********************/

#line 2145
static long
bool_arrtype_hash(PyObject *obj)
{
    return (long)(((PyBoolScalarObject *)obj)->obval);
}

#line 2145
static long
ubyte_arrtype_hash(PyObject *obj)
{
    return (long)(((PyUByteScalarObject *)obj)->obval);
}

#line 2145
static long
ushort_arrtype_hash(PyObject *obj)
{
    return (long)(((PyUShortScalarObject *)obj)->obval);
}


#line 2156
static long
byte_arrtype_hash(PyObject *obj)
{
    long x = (long)(((PyByteScalarObject *)obj)->obval);
    if (x == -1) x=-2;
    return x;
}

#line 2156
static long
short_arrtype_hash(PyObject *obj)
{
    long x = (long)(((PyShortScalarObject *)obj)->obval);
    if (x == -1) x=-2;
    return x;
}

#line 2156
static long
uint_arrtype_hash(PyObject *obj)
{
    long x = (long)(((PyUIntScalarObject *)obj)->obval);
    if (x == -1) x=-2;
    return x;
}

#line 2156
static long
ulong_arrtype_hash(PyObject *obj)
{
    long x = (long)(((PyULongScalarObject *)obj)->obval);
    if (x == -1) x=-2;
    return x;
}


#if SIZEOF_INT != SIZEOF_LONG
static long
int_arrtype_hash(PyObject *obj)
{
    long x = (long)(((PyIntScalarObject *)obj)->obval);
    if (x == -1) x=-2;
    return x;
}
#endif

#line 2180
#if SIZEOF_LONG != SIZEOF_LONGLONG
/* we assume SIZEOF_LONGLONG=2*SIZEOF_LONG */
static long
longlong_arrtype_hash(PyObject *obj)
{
    long y;
    longlong x = (((PyLongLongScalarObject *)obj)->obval);

    if ((x <= LONG_MAX)&& (x >= LONG_MIN)) {
        y = (long) x;
    }
    else {
        union Mask {
            long hashvals[2];
            longlong v;
        } both;

        both.v = x;
        y = both.hashvals[0] + (1000003)*both.hashvals[1];
    }
    if (y == -1) y = -2;
    return y;
}
#endif

#line 2180
#if SIZEOF_LONG != SIZEOF_LONGLONG
/* we assume SIZEOF_LONGLONG=2*SIZEOF_LONG */
static long
ulonglong_arrtype_hash(PyObject *obj)
{
    long y;
    ulonglong x = (((PyULongLongScalarObject *)obj)->obval);

    if ((x <= LONG_MAX)) {
        y = (long) x;
    }
    else {
        union Mask {
            long hashvals[2];
            ulonglong v;
        } both;

        both.v = x;
        y = both.hashvals[0] + (1000003)*both.hashvals[1];
    }
    if (y == -1) y = -2;
    return y;
}
#endif


#if SIZEOF_LONG==SIZEOF_LONGLONG
static long
ulonglong_arrtype_hash(PyObject *obj)
{
    long x = (long)(((PyULongLongScalarObject *)obj)->obval);
    if (x == -1) x=-2;
    return x;
}
#endif



/* Wrong thing to do for longdouble, but....*/
#line 2223
static long
float_arrtype_hash(PyObject *obj)
{
    return _Py_HashDouble((double) ((PyFloatScalarObject *)obj)->obval);
}

/* borrowed from complex_hash */
static long
cfloat_arrtype_hash(PyObject *obj)
{
    long hashreal, hashimag, combined;
    hashreal = _Py_HashDouble((double)                              \
            (((PyCFloatScalarObject *)obj)->obval).real);

    if (hashreal == -1) return -1;
    hashimag = _Py_HashDouble((double)                              \
            (((PyCFloatScalarObject *)obj)->obval).imag);
    if (hashimag == -1) return -1;

    combined = hashreal + 1000003 * hashimag;
    if (combined == -1) combined = -2;
    return combined;
}

#line 2223
static long
longdouble_arrtype_hash(PyObject *obj)
{
    return _Py_HashDouble((double) ((PyLongDoubleScalarObject *)obj)->obval);
}

/* borrowed from complex_hash */
static long
clongdouble_arrtype_hash(PyObject *obj)
{
    long hashreal, hashimag, combined;
    hashreal = _Py_HashDouble((double)                              \
            (((PyCLongDoubleScalarObject *)obj)->obval).real);

    if (hashreal == -1) return -1;
    hashimag = _Py_HashDouble((double)                              \
            (((PyCLongDoubleScalarObject *)obj)->obval).imag);
    if (hashimag == -1) return -1;

    combined = hashreal + 1000003 * hashimag;
    if (combined == -1) combined = -2;
    return combined;
}


static long
object_arrtype_hash(PyObject *obj)
{
    return PyObject_Hash(((PyObjectScalarObject *)obj)->obval);
}

/* just hash the pointer */
static long
void_arrtype_hash(PyObject *obj)
{
    return _Py_HashPointer((void *)(((PyVoidScalarObject *)obj)->obval));
}

/*object arrtype getattro and setattro */
static PyObject *
object_arrtype_getattro(PyObjectScalarObject *obj, PyObject *attr) {
    PyObject *res;

    /* first look in object and then hand off to generic type */

    res = PyObject_GenericGetAttr(obj->obval, attr);
    if (res) return res;
    PyErr_Clear();
    return  PyObject_GenericGetAttr((PyObject *)obj, attr);
}

static int
object_arrtype_setattro(PyObjectScalarObject *obj, PyObject *attr, PyObject *val) {
    int res;
    /* first look in object and then hand off to generic type */

    res = PyObject_GenericSetAttr(obj->obval, attr, val);
    if (res >= 0) return res;
    PyErr_Clear();
    return PyObject_GenericSetAttr((PyObject *)obj, attr, val);
}

static PyObject *
object_arrtype_concat(PyObjectScalarObject *self, PyObject *other)
{
    return PySequence_Concat(self->obval, other);
}

static Py_ssize_t
object_arrtype_length(PyObjectScalarObject *self)
{
    return PyObject_Length(self->obval);
}

static PyObject *
object_arrtype_repeat(PyObjectScalarObject *self, Py_ssize_t count)
{
    return PySequence_Repeat(self->obval, count);
}

static PyObject *
object_arrtype_subscript(PyObjectScalarObject *self, PyObject *key)
{
    return PyObject_GetItem(self->obval, key);
}

static int
object_arrtype_ass_subscript(PyObjectScalarObject *self, PyObject *key,
                             PyObject *value)
{
    return PyObject_SetItem(self->obval, key, value);
}

static int
object_arrtype_contains(PyObjectScalarObject *self, PyObject *ob)
{
    return PySequence_Contains(self->obval, ob);
}

static PyObject *
object_arrtype_inplace_concat(PyObjectScalarObject *self, PyObject *o)
{
    return PySequence_InPlaceConcat(self->obval, o);
}

static PyObject *
object_arrtype_inplace_repeat(PyObjectScalarObject *self, Py_ssize_t count)
{
    return PySequence_InPlaceRepeat(self->obval, count);
}

static PySequenceMethods object_arrtype_as_sequence = {
#if PY_VERSION_HEX >= 0x02050000
    (lenfunc)object_arrtype_length,                     /*sq_length*/
    (binaryfunc)object_arrtype_concat,                  /*sq_concat*/
    (ssizeargfunc)object_arrtype_repeat,                /*sq_repeat*/
    0,                                                  /*sq_item*/
    0,                                                  /*sq_slice*/
    0,                                                  /* sq_ass_item */
    0,                                                  /* sq_ass_slice */
    (objobjproc)object_arrtype_contains,                /* sq_contains */
    (binaryfunc)object_arrtype_inplace_concat,          /* sq_inplace_concat */
    (ssizeargfunc)object_arrtype_inplace_repeat,        /* sq_inplace_repeat */
#else
    (inquiry)object_arrtype_length,                     /*sq_length*/
    (binaryfunc)object_arrtype_concat,                  /*sq_concat*/
    (intargfunc)object_arrtype_repeat,                  /*sq_repeat*/
    0,                                                  /*sq_item*/
    0,                                                  /*sq_slice*/
    0,                                                  /* sq_ass_item */
    0,                                                  /* sq_ass_slice */
    (objobjproc)object_arrtype_contains,                /* sq_contains */
    (binaryfunc)object_arrtype_inplace_concat,          /* sq_inplace_concat */
    (intargfunc)object_arrtype_inplace_repeat,          /* sq_inplace_repeat */
#endif
};

static PyMappingMethods object_arrtype_as_mapping = {
#if PY_VERSION_HEX >= 0x02050000
    (lenfunc)object_arrtype_length,
    (binaryfunc)object_arrtype_subscript,
    (objobjargproc)object_arrtype_ass_subscript,
#else
    (inquiry)object_arrtype_length,
    (binaryfunc)object_arrtype_subscript,
    (objobjargproc)object_arrtype_ass_subscript,
#endif
};

static Py_ssize_t
object_arrtype_getsegcount(PyObjectScalarObject *self, Py_ssize_t *lenp)
{
    Py_ssize_t newlen;
    int cnt;
    PyBufferProcs *pb = self->obval->ob_type->tp_as_buffer;

    if (pb == NULL || \
            pb->bf_getsegcount == NULL || \
            (cnt = (*pb->bf_getsegcount)(self->obval, &newlen)) != 1)
        return 0;

    if (lenp)
        *lenp = newlen;

    return cnt;
}

static Py_ssize_t
object_arrtype_getreadbuf(PyObjectScalarObject *self, Py_ssize_t segment, void **ptrptr)
{
    PyBufferProcs *pb = self->obval->ob_type->tp_as_buffer;

    if (pb == NULL || \
            pb->bf_getreadbuffer == NULL ||
            pb->bf_getsegcount == NULL) {
        PyErr_SetString(PyExc_TypeError,
                "expected a readable buffer object");
        return -1;
    }

    return (*pb->bf_getreadbuffer)(self->obval, segment, ptrptr);
}

static Py_ssize_t
object_arrtype_getwritebuf(PyObjectScalarObject *self, Py_ssize_t segment, void **ptrptr)
{
    PyBufferProcs *pb = self->obval->ob_type->tp_as_buffer;

    if (pb == NULL || \
            pb->bf_getwritebuffer == NULL ||
            pb->bf_getsegcount == NULL) {
        PyErr_SetString(PyExc_TypeError,
                "expected a writeable buffer object");
        return -1;
    }

    return (*pb->bf_getwritebuffer)(self->obval, segment, ptrptr);
}

static Py_ssize_t
object_arrtype_getcharbuf(PyObjectScalarObject *self, Py_ssize_t segment,
                          constchar **ptrptr)
{
    PyBufferProcs *pb = self->obval->ob_type->tp_as_buffer;

    if (pb == NULL || \
            pb->bf_getcharbuffer == NULL ||
            pb->bf_getsegcount == NULL) {
        PyErr_SetString(PyExc_TypeError,
                "expected a character buffer object");
        return -1;
    }

    return (*pb->bf_getcharbuffer)(self->obval, segment, ptrptr);
}

static PyBufferProcs object_arrtype_as_buffer = {
#if PY_VERSION_HEX >= 0x02050000
    (readbufferproc)object_arrtype_getreadbuf,
    (writebufferproc)object_arrtype_getwritebuf,
    (segcountproc)object_arrtype_getsegcount,
    (charbufferproc)object_arrtype_getcharbuf,
#else
    (getreadbufferproc)object_arrtype_getreadbuf,
    (getwritebufferproc)object_arrtype_getwritebuf,
    (getsegcountproc)object_arrtype_getsegcount,
    (getcharbufferproc)object_arrtype_getcharbuf,
#endif
};

static PyObject *
object_arrtype_call(PyObjectScalarObject *obj, PyObject *args, PyObject *kwds)
{
        return PyObject_Call(obj->obval, args, kwds);
}

static PyTypeObject PyObjectArrType_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                        /*ob_size*/
    "numpy.object_",                          /*tp_name*/
    sizeof(PyObjectScalarObject),             /*tp_basicsize*/
    0,                                        /* tp_itemsize */
    (destructor)object_arrtype_dealloc,       /* tp_dealloc */
    0,                                        /* tp_print */
    0,                                        /* tp_getattr */
    0,                                        /* tp_setattr */
    0,                                        /* tp_compare */
    0,                                        /* tp_repr */
    0,                                        /* tp_as_number */
    &object_arrtype_as_sequence,              /* tp_as_sequence */
    &object_arrtype_as_mapping,               /* tp_as_mapping */
    0,                                        /* tp_hash */
    (ternaryfunc)object_arrtype_call,         /* tp_call */
    0,                                        /* tp_str */
    (getattrofunc)object_arrtype_getattro,    /* tp_getattro */
    (setattrofunc)object_arrtype_setattro,    /* tp_setattro */
    &object_arrtype_as_buffer,                /* tp_as_buffer */
    0,                                        /* tp_flags */
};


static PyObject *
add_new_axes_0d(PyArrayObject *,  int);

static int
count_new_axes_0d(PyObject *);

static PyObject *
gen_arrtype_subscript(PyObject *self, PyObject *key)
{
    /* Only [...], [...,<???>], [<???>, ...],
       is allowed for indexing a scalar

       These return a new N-d array with a copy of
       the data where N is the number of None's in <???>.

     */
    PyObject *res, *ret;
    int N;

    if (key == Py_Ellipsis || key == Py_None ||
            PyTuple_Check(key)) {
        res = PyArray_FromScalar(self, NULL);
    }
    else {
        PyErr_SetString(PyExc_IndexError,
                "invalid index to scalar variable.");
        return NULL;
    }

    if (key == Py_Ellipsis)
        return res;

    if (key == Py_None) {
        ret = add_new_axes_0d((PyArrayObject *)res, 1);
        Py_DECREF(res);
        return ret;
    }
    /* Must be a Tuple */

    N = count_new_axes_0d(key);
    if (N < 0) return NULL;
    ret = add_new_axes_0d((PyArrayObject *)res, N);
    Py_DECREF(res);
    return ret;
}


#line 2536
static PyTypeObject PyBoolArrType_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                        /*ob_size*/
    "numpy.bool_",                       /*tp_name*/
    sizeof(PyBoolScalarObject),             /*tp_basicsize*/
};

#line 2536
static PyTypeObject PyStringArrType_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                        /*ob_size*/
    "numpy.string_",                       /*tp_name*/
    sizeof(PyStringScalarObject),             /*tp_basicsize*/
};

#line 2536
static PyTypeObject PyUnicodeArrType_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                        /*ob_size*/
    "numpy.unicode_",                       /*tp_name*/
    sizeof(PyUnicodeScalarObject),             /*tp_basicsize*/
};

#line 2536
static PyTypeObject PyVoidArrType_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                        /*ob_size*/
    "numpy.void",                       /*tp_name*/
    sizeof(PyVoidScalarObject),             /*tp_basicsize*/
};


#line 2549
#if BITSOF_CHAR == 8
#define _THIS_SIZE "8"
#elif BITSOF_CHAR == 16
#define _THIS_SIZE "16"
#elif BITSOF_CHAR == 32
#define _THIS_SIZE "32"
#elif BITSOF_CHAR == 64
#define _THIS_SIZE "64"
#elif BITSOF_CHAR == 80
#define _THIS_SIZE "80"
#elif BITSOF_CHAR == 96
#define _THIS_SIZE "96"
#elif BITSOF_CHAR == 128
#define _THIS_SIZE "128"
#elif BITSOF_CHAR == 256
#define _THIS_SIZE "256"
#endif
static PyTypeObject PyByteArrType_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                          /*ob_size*/
    "numpy.int" _THIS_SIZE,                  /*tp_name*/
    sizeof(PyByteScalarObject),               /*tp_basicsize*/
};

#undef _THIS_SIZE

#line 2549
#if BITSOF_SHORT == 8
#define _THIS_SIZE "8"
#elif BITSOF_SHORT == 16
#define _THIS_SIZE "16"
#elif BITSOF_SHORT == 32
#define _THIS_SIZE "32"
#elif BITSOF_SHORT == 64
#define _THIS_SIZE "64"
#elif BITSOF_SHORT == 80
#define _THIS_SIZE "80"
#elif BITSOF_SHORT == 96
#define _THIS_SIZE "96"
#elif BITSOF_SHORT == 128
#define _THIS_SIZE "128"
#elif BITSOF_SHORT == 256
#define _THIS_SIZE "256"
#endif
static PyTypeObject PyShortArrType_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                          /*ob_size*/
    "numpy.int" _THIS_SIZE,                  /*tp_name*/
    sizeof(PyShortScalarObject),               /*tp_basicsize*/
};

#undef _THIS_SIZE

#line 2549
#if BITSOF_INT == 8
#define _THIS_SIZE "8"
#elif BITSOF_INT == 16
#define _THIS_SIZE "16"
#elif BITSOF_INT == 32
#define _THIS_SIZE "32"
#elif BITSOF_INT == 64
#define _THIS_SIZE "64"
#elif BITSOF_INT == 80
#define _THIS_SIZE "80"
#elif BITSOF_INT == 96
#define _THIS_SIZE "96"
#elif BITSOF_INT == 128
#define _THIS_SIZE "128"
#elif BITSOF_INT == 256
#define _THIS_SIZE "256"
#endif
static PyTypeObject PyIntArrType_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                          /*ob_size*/
    "numpy.int" _THIS_SIZE,                  /*tp_name*/
    sizeof(PyIntScalarObject),               /*tp_basicsize*/
};

#undef _THIS_SIZE

#line 2549
#if BITSOF_LONG == 8
#define _THIS_SIZE "8"
#elif BITSOF_LONG == 16
#define _THIS_SIZE "16"
#elif BITSOF_LONG == 32
#define _THIS_SIZE "32"
#elif BITSOF_LONG == 64
#define _THIS_SIZE "64"
#elif BITSOF_LONG == 80
#define _THIS_SIZE "80"
#elif BITSOF_LONG == 96
#define _THIS_SIZE "96"
#elif BITSOF_LONG == 128
#define _THIS_SIZE "128"
#elif BITSOF_LONG == 256
#define _THIS_SIZE "256"
#endif
static PyTypeObject PyLongArrType_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                          /*ob_size*/
    "numpy.int" _THIS_SIZE,                  /*tp_name*/
    sizeof(PyLongScalarObject),               /*tp_basicsize*/
};

#undef _THIS_SIZE

#line 2549
#if BITSOF_LONGLONG == 8
#define _THIS_SIZE "8"
#elif BITSOF_LONGLONG == 16
#define _THIS_SIZE "16"
#elif BITSOF_LONGLONG == 32
#define _THIS_SIZE "32"
#elif BITSOF_LONGLONG == 64
#define _THIS_SIZE "64"
#elif BITSOF_LONGLONG == 80
#define _THIS_SIZE "80"
#elif BITSOF_LONGLONG == 96
#define _THIS_SIZE "96"
#elif BITSOF_LONGLONG == 128
#define _THIS_SIZE "128"
#elif BITSOF_LONGLONG == 256
#define _THIS_SIZE "256"
#endif
static PyTypeObject PyLongLongArrType_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                          /*ob_size*/
    "numpy.int" _THIS_SIZE,                  /*tp_name*/
    sizeof(PyLongLongScalarObject),               /*tp_basicsize*/
};

#undef _THIS_SIZE

#line 2549
#if BITSOF_CHAR == 8
#define _THIS_SIZE "8"
#elif BITSOF_CHAR == 16
#define _THIS_SIZE "16"
#elif BITSOF_CHAR == 32
#define _THIS_SIZE "32"
#elif BITSOF_CHAR == 64
#define _THIS_SIZE "64"
#elif BITSOF_CHAR == 80
#define _THIS_SIZE "80"
#elif BITSOF_CHAR == 96
#define _THIS_SIZE "96"
#elif BITSOF_CHAR == 128
#define _THIS_SIZE "128"
#elif BITSOF_CHAR == 256
#define _THIS_SIZE "256"
#endif
static PyTypeObject PyUByteArrType_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                          /*ob_size*/
    "numpy.uint" _THIS_SIZE,                  /*tp_name*/
    sizeof(PyUByteScalarObject),               /*tp_basicsize*/
};

#undef _THIS_SIZE

#line 2549
#if BITSOF_SHORT == 8
#define _THIS_SIZE "8"
#elif BITSOF_SHORT == 16
#define _THIS_SIZE "16"
#elif BITSOF_SHORT == 32
#define _THIS_SIZE "32"
#elif BITSOF_SHORT == 64
#define _THIS_SIZE "64"
#elif BITSOF_SHORT == 80
#define _THIS_SIZE "80"
#elif BITSOF_SHORT == 96
#define _THIS_SIZE "96"
#elif BITSOF_SHORT == 128
#define _THIS_SIZE "128"
#elif BITSOF_SHORT == 256
#define _THIS_SIZE "256"
#endif
static PyTypeObject PyUShortArrType_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                          /*ob_size*/
    "numpy.uint" _THIS_SIZE,                  /*tp_name*/
    sizeof(PyUShortScalarObject),               /*tp_basicsize*/
};

#undef _THIS_SIZE

#line 2549
#if BITSOF_INT == 8
#define _THIS_SIZE "8"
#elif BITSOF_INT == 16
#define _THIS_SIZE "16"
#elif BITSOF_INT == 32
#define _THIS_SIZE "32"
#elif BITSOF_INT == 64
#define _THIS_SIZE "64"
#elif BITSOF_INT == 80
#define _THIS_SIZE "80"
#elif BITSOF_INT == 96
#define _THIS_SIZE "96"
#elif BITSOF_INT == 128
#define _THIS_SIZE "128"
#elif BITSOF_INT == 256
#define _THIS_SIZE "256"
#endif
static PyTypeObject PyUIntArrType_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                          /*ob_size*/
    "numpy.uint" _THIS_SIZE,                  /*tp_name*/
    sizeof(PyUIntScalarObject),               /*tp_basicsize*/
};

#undef _THIS_SIZE

#line 2549
#if BITSOF_LONG == 8
#define _THIS_SIZE "8"
#elif BITSOF_LONG == 16
#define _THIS_SIZE "16"
#elif BITSOF_LONG == 32
#define _THIS_SIZE "32"
#elif BITSOF_LONG == 64
#define _THIS_SIZE "64"
#elif BITSOF_LONG == 80
#define _THIS_SIZE "80"
#elif BITSOF_LONG == 96
#define _THIS_SIZE "96"
#elif BITSOF_LONG == 128
#define _THIS_SIZE "128"
#elif BITSOF_LONG == 256
#define _THIS_SIZE "256"
#endif
static PyTypeObject PyULongArrType_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                          /*ob_size*/
    "numpy.uint" _THIS_SIZE,                  /*tp_name*/
    sizeof(PyULongScalarObject),               /*tp_basicsize*/
};

#undef _THIS_SIZE

#line 2549
#if BITSOF_LONGLONG == 8
#define _THIS_SIZE "8"
#elif BITSOF_LONGLONG == 16
#define _THIS_SIZE "16"
#elif BITSOF_LONGLONG == 32
#define _THIS_SIZE "32"
#elif BITSOF_LONGLONG == 64
#define _THIS_SIZE "64"
#elif BITSOF_LONGLONG == 80
#define _THIS_SIZE "80"
#elif BITSOF_LONGLONG == 96
#define _THIS_SIZE "96"
#elif BITSOF_LONGLONG == 128
#define _THIS_SIZE "128"
#elif BITSOF_LONGLONG == 256
#define _THIS_SIZE "256"
#endif
static PyTypeObject PyULongLongArrType_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                          /*ob_size*/
    "numpy.uint" _THIS_SIZE,                  /*tp_name*/
    sizeof(PyULongLongScalarObject),               /*tp_basicsize*/
};

#undef _THIS_SIZE

#line 2549
#if BITSOF_FLOAT == 8
#define _THIS_SIZE "8"
#elif BITSOF_FLOAT == 16
#define _THIS_SIZE "16"
#elif BITSOF_FLOAT == 32
#define _THIS_SIZE "32"
#elif BITSOF_FLOAT == 64
#define _THIS_SIZE "64"
#elif BITSOF_FLOAT == 80
#define _THIS_SIZE "80"
#elif BITSOF_FLOAT == 96
#define _THIS_SIZE "96"
#elif BITSOF_FLOAT == 128
#define _THIS_SIZE "128"
#elif BITSOF_FLOAT == 256
#define _THIS_SIZE "256"
#endif
static PyTypeObject PyFloatArrType_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                          /*ob_size*/
    "numpy.float" _THIS_SIZE,                  /*tp_name*/
    sizeof(PyFloatScalarObject),               /*tp_basicsize*/
};

#undef _THIS_SIZE

#line 2549
#if BITSOF_DOUBLE == 8
#define _THIS_SIZE "8"
#elif BITSOF_DOUBLE == 16
#define _THIS_SIZE "16"
#elif BITSOF_DOUBLE == 32
#define _THIS_SIZE "32"
#elif BITSOF_DOUBLE == 64
#define _THIS_SIZE "64"
#elif BITSOF_DOUBLE == 80
#define _THIS_SIZE "80"
#elif BITSOF_DOUBLE == 96
#define _THIS_SIZE "96"
#elif BITSOF_DOUBLE == 128
#define _THIS_SIZE "128"
#elif BITSOF_DOUBLE == 256
#define _THIS_SIZE "256"
#endif
static PyTypeObject PyDoubleArrType_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                          /*ob_size*/
    "numpy.float" _THIS_SIZE,                  /*tp_name*/
    sizeof(PyDoubleScalarObject),               /*tp_basicsize*/
};

#undef _THIS_SIZE

#line 2549
#if BITSOF_LONGDOUBLE == 8
#define _THIS_SIZE "8"
#elif BITSOF_LONGDOUBLE == 16
#define _THIS_SIZE "16"
#elif BITSOF_LONGDOUBLE == 32
#define _THIS_SIZE "32"
#elif BITSOF_LONGDOUBLE == 64
#define _THIS_SIZE "64"
#elif BITSOF_LONGDOUBLE == 80
#define _THIS_SIZE "80"
#elif BITSOF_LONGDOUBLE == 96
#define _THIS_SIZE "96"
#elif BITSOF_LONGDOUBLE == 128
#define _THIS_SIZE "128"
#elif BITSOF_LONGDOUBLE == 256
#define _THIS_SIZE "256"
#endif
static PyTypeObject PyLongDoubleArrType_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                          /*ob_size*/
    "numpy.float" _THIS_SIZE,                  /*tp_name*/
    sizeof(PyLongDoubleScalarObject),               /*tp_basicsize*/
};

#undef _THIS_SIZE



static PyMappingMethods gentype_as_mapping = {
    NULL,
    (binaryfunc)gen_arrtype_subscript,
    NULL
};


#line 2589
#if BITSOF_FLOAT == 16
#define _THIS_SIZE2 "16"
#define _THIS_SIZE1 "32"
#elif BITSOF_FLOAT == 32
#define _THIS_SIZE2 "32"
#define _THIS_SIZE1 "64"
#elif BITSOF_FLOAT == 64
#define _THIS_SIZE2 "64"
#define _THIS_SIZE1 "128"
#elif BITSOF_FLOAT == 80
#define _THIS_SIZE2 "80"
#define _THIS_SIZE1 "160"
#elif BITSOF_FLOAT == 96
#define _THIS_SIZE2 "96"
#define _THIS_SIZE1 "192"
#elif BITSOF_FLOAT == 128
#define _THIS_SIZE2 "128"
#define _THIS_SIZE1 "256"
#elif BITSOF_FLOAT == 256
#define _THIS_SIZE2 "256"
#define _THIS_SIZE1 "512"
#endif
static PyTypeObject PyCFloatArrType_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                              /*ob_size*/
    "numpy.complex" _THIS_SIZE1,                     /*tp_name*/
    sizeof(PyCFloatScalarObject),                   /*tp_basicsize*/
    0,                                              /*tp_itemsize*/
    0,                                              /*tp_dealloc*/
    0,                                              /*tp_print*/
    0,                                              /*tp_getattr*/
    0,                                              /*tp_setattr*/
    0,                                              /*tp_compare*/
    0,                                              /*tp_repr*/
    0,                                              /*tp_as_number*/
    0,                                              /*tp_as_sequence*/
    0,                                              /*tp_as_mapping*/
    0,                                              /*tp_hash */
    0,                                              /*tp_call*/
    0,                                              /*tp_str*/
    0,                                              /*tp_getattro*/
    0,                                              /*tp_setattro*/
    0,                                              /*tp_as_buffer*/
    Py_TPFLAGS_DEFAULT,                             /*tp_flags*/
    "Composed of two " _THIS_SIZE2 " bit floats",   /* tp_doc */
};
#undef _THIS_SIZE1
#undef _THIS_SIZE2


#line 2589
#if BITSOF_DOUBLE == 16
#define _THIS_SIZE2 "16"
#define _THIS_SIZE1 "32"
#elif BITSOF_DOUBLE == 32
#define _THIS_SIZE2 "32"
#define _THIS_SIZE1 "64"
#elif BITSOF_DOUBLE == 64
#define _THIS_SIZE2 "64"
#define _THIS_SIZE1 "128"
#elif BITSOF_DOUBLE == 80
#define _THIS_SIZE2 "80"
#define _THIS_SIZE1 "160"
#elif BITSOF_DOUBLE == 96
#define _THIS_SIZE2 "96"
#define _THIS_SIZE1 "192"
#elif BITSOF_DOUBLE == 128
#define _THIS_SIZE2 "128"
#define _THIS_SIZE1 "256"
#elif BITSOF_DOUBLE == 256
#define _THIS_SIZE2 "256"
#define _THIS_SIZE1 "512"
#endif
static PyTypeObject PyCDoubleArrType_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                              /*ob_size*/
    "numpy.complex" _THIS_SIZE1,                     /*tp_name*/
    sizeof(PyCDoubleScalarObject),                   /*tp_basicsize*/
    0,                                              /*tp_itemsize*/
    0,                                              /*tp_dealloc*/
    0,                                              /*tp_print*/
    0,                                              /*tp_getattr*/
    0,                                              /*tp_setattr*/
    0,                                              /*tp_compare*/
    0,                                              /*tp_repr*/
    0,                                              /*tp_as_number*/
    0,                                              /*tp_as_sequence*/
    0,                                              /*tp_as_mapping*/
    0,                                              /*tp_hash */
    0,                                              /*tp_call*/
    0,                                              /*tp_str*/
    0,                                              /*tp_getattro*/
    0,                                              /*tp_setattro*/
    0,                                              /*tp_as_buffer*/
    Py_TPFLAGS_DEFAULT,                             /*tp_flags*/
    "Composed of two " _THIS_SIZE2 " bit floats",   /* tp_doc */
};
#undef _THIS_SIZE1
#undef _THIS_SIZE2


#line 2589
#if BITSOF_LONGDOUBLE == 16
#define _THIS_SIZE2 "16"
#define _THIS_SIZE1 "32"
#elif BITSOF_LONGDOUBLE == 32
#define _THIS_SIZE2 "32"
#define _THIS_SIZE1 "64"
#elif BITSOF_LONGDOUBLE == 64
#define _THIS_SIZE2 "64"
#define _THIS_SIZE1 "128"
#elif BITSOF_LONGDOUBLE == 80
#define _THIS_SIZE2 "80"
#define _THIS_SIZE1 "160"
#elif BITSOF_LONGDOUBLE == 96
#define _THIS_SIZE2 "96"
#define _THIS_SIZE1 "192"
#elif BITSOF_LONGDOUBLE == 128
#define _THIS_SIZE2 "128"
#define _THIS_SIZE1 "256"
#elif BITSOF_LONGDOUBLE == 256
#define _THIS_SIZE2 "256"
#define _THIS_SIZE1 "512"
#endif
static PyTypeObject PyCLongDoubleArrType_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                              /*ob_size*/
    "numpy.complex" _THIS_SIZE1,                     /*tp_name*/
    sizeof(PyCLongDoubleScalarObject),                   /*tp_basicsize*/
    0,                                              /*tp_itemsize*/
    0,                                              /*tp_dealloc*/
    0,                                              /*tp_print*/
    0,                                              /*tp_getattr*/
    0,                                              /*tp_setattr*/
    0,                                              /*tp_compare*/
    0,                                              /*tp_repr*/
    0,                                              /*tp_as_number*/
    0,                                              /*tp_as_sequence*/
    0,                                              /*tp_as_mapping*/
    0,                                              /*tp_hash */
    0,                                              /*tp_call*/
    0,                                              /*tp_str*/
    0,                                              /*tp_getattro*/
    0,                                              /*tp_setattro*/
    0,                                              /*tp_as_buffer*/
    Py_TPFLAGS_DEFAULT,                             /*tp_flags*/
    "Composed of two " _THIS_SIZE2 " bit floats",   /* tp_doc */
};
#undef _THIS_SIZE1
#undef _THIS_SIZE2




static PyNumberMethods longdoubletype_as_number;
static PyNumberMethods clongdoubletype_as_number;


static void
initialize_numeric_types(void)
{
    PyGenericArrType_Type.tp_dealloc = (destructor)gentype_dealloc;
    PyGenericArrType_Type.tp_as_number = &gentype_as_number;
    PyGenericArrType_Type.tp_as_buffer = &gentype_as_buffer;
    PyGenericArrType_Type.tp_as_mapping = &gentype_as_mapping;
    PyGenericArrType_Type.tp_flags = BASEFLAGS;
    PyGenericArrType_Type.tp_methods = gentype_methods;
    PyGenericArrType_Type.tp_getset = gentype_getsets;
    PyGenericArrType_Type.tp_new = NULL;
    PyGenericArrType_Type.tp_alloc = gentype_alloc;
    PyGenericArrType_Type.tp_free = _pya_free;
    PyGenericArrType_Type.tp_repr = gentype_repr;
    PyGenericArrType_Type.tp_str = gentype_str;
    PyGenericArrType_Type.tp_richcompare = gentype_richcompare;

    PyBoolArrType_Type.tp_as_number = &bool_arrtype_as_number;
#if PY_VERSION_HEX >= 0x02050000
    /* need to add dummy versions with filled-in nb_index
       in-order for PyType_Ready to fill in .__index__() method
     */
    #line 2671
    PyByteArrType_Type.tp_as_number = &byte_arrtype_as_number;
    PyByteArrType_Type.tp_as_number->nb_index = (unaryfunc)byte_index;

    
#line 2671
    PyShortArrType_Type.tp_as_number = &short_arrtype_as_number;
    PyShortArrType_Type.tp_as_number->nb_index = (unaryfunc)short_index;

    
#line 2671
    PyIntArrType_Type.tp_as_number = &int_arrtype_as_number;
    PyIntArrType_Type.tp_as_number->nb_index = (unaryfunc)int_index;

    
#line 2671
    PyLongArrType_Type.tp_as_number = &long_arrtype_as_number;
    PyLongArrType_Type.tp_as_number->nb_index = (unaryfunc)long_index;

    
#line 2671
    PyLongLongArrType_Type.tp_as_number = &longlong_arrtype_as_number;
    PyLongLongArrType_Type.tp_as_number->nb_index = (unaryfunc)longlong_index;

    
#line 2671
    PyUByteArrType_Type.tp_as_number = &ubyte_arrtype_as_number;
    PyUByteArrType_Type.tp_as_number->nb_index = (unaryfunc)ubyte_index;

    
#line 2671
    PyUShortArrType_Type.tp_as_number = &ushort_arrtype_as_number;
    PyUShortArrType_Type.tp_as_number->nb_index = (unaryfunc)ushort_index;

    
#line 2671
    PyUIntArrType_Type.tp_as_number = &uint_arrtype_as_number;
    PyUIntArrType_Type.tp_as_number->nb_index = (unaryfunc)uint_index;

    
#line 2671
    PyULongArrType_Type.tp_as_number = &ulong_arrtype_as_number;
    PyULongArrType_Type.tp_as_number->nb_index = (unaryfunc)ulong_index;

    
#line 2671
    PyULongLongArrType_Type.tp_as_number = &ulonglong_arrtype_as_number;
    PyULongLongArrType_Type.tp_as_number->nb_index = (unaryfunc)ulonglong_index;

    
    PyBoolArrType_Type.tp_as_number->nb_index = (unaryfunc)bool_index;
#endif

    PyStringArrType_Type.tp_alloc = NULL;
    PyStringArrType_Type.tp_free = NULL;

    PyStringArrType_Type.tp_repr = stringtype_repr;
    PyStringArrType_Type.tp_str = stringtype_str;

    PyUnicodeArrType_Type.tp_repr = unicodetype_repr;
    PyUnicodeArrType_Type.tp_str = unicodetype_str;

    PyVoidArrType_Type.tp_methods = voidtype_methods;
    PyVoidArrType_Type.tp_getset = voidtype_getsets;
    PyVoidArrType_Type.tp_as_mapping = &voidtype_as_mapping;
    PyVoidArrType_Type.tp_as_sequence = &voidtype_as_sequence;

    #line 2696
    PyNumberArrType_Type.tp_flags = BASEFLAGS;
    
#line 2696
    PyIntegerArrType_Type.tp_flags = BASEFLAGS;
    
#line 2696
    PySignedIntegerArrType_Type.tp_flags = BASEFLAGS;
    
#line 2696
    PyUnsignedIntegerArrType_Type.tp_flags = BASEFLAGS;
    
#line 2696
    PyInexactArrType_Type.tp_flags = BASEFLAGS;
    
#line 2696
    PyFloatingArrType_Type.tp_flags = BASEFLAGS;
    
#line 2696
    PyComplexFloatingArrType_Type.tp_flags = BASEFLAGS;
    
#line 2696
    PyFlexibleArrType_Type.tp_flags = BASEFLAGS;
    
#line 2696
    PyCharacterArrType_Type.tp_flags = BASEFLAGS;
    

    #line 2703
    PyBoolArrType_Type.tp_flags = BASEFLAGS;
    PyBoolArrType_Type.tp_new = bool_arrtype_new;
    PyBoolArrType_Type.tp_richcompare = gentype_richcompare;
    
#line 2703
    PyByteArrType_Type.tp_flags = BASEFLAGS;
    PyByteArrType_Type.tp_new = byte_arrtype_new;
    PyByteArrType_Type.tp_richcompare = gentype_richcompare;
    
#line 2703
    PyShortArrType_Type.tp_flags = BASEFLAGS;
    PyShortArrType_Type.tp_new = short_arrtype_new;
    PyShortArrType_Type.tp_richcompare = gentype_richcompare;
    
#line 2703
    PyIntArrType_Type.tp_flags = BASEFLAGS;
    PyIntArrType_Type.tp_new = int_arrtype_new;
    PyIntArrType_Type.tp_richcompare = gentype_richcompare;
    
#line 2703
    PyLongArrType_Type.tp_flags = BASEFLAGS;
    PyLongArrType_Type.tp_new = long_arrtype_new;
    PyLongArrType_Type.tp_richcompare = gentype_richcompare;
    
#line 2703
    PyLongLongArrType_Type.tp_flags = BASEFLAGS;
    PyLongLongArrType_Type.tp_new = longlong_arrtype_new;
    PyLongLongArrType_Type.tp_richcompare = gentype_richcompare;
    
#line 2703
    PyUByteArrType_Type.tp_flags = BASEFLAGS;
    PyUByteArrType_Type.tp_new = ubyte_arrtype_new;
    PyUByteArrType_Type.tp_richcompare = gentype_richcompare;
    
#line 2703
    PyUShortArrType_Type.tp_flags = BASEFLAGS;
    PyUShortArrType_Type.tp_new = ushort_arrtype_new;
    PyUShortArrType_Type.tp_richcompare = gentype_richcompare;
    
#line 2703
    PyUIntArrType_Type.tp_flags = BASEFLAGS;
    PyUIntArrType_Type.tp_new = uint_arrtype_new;
    PyUIntArrType_Type.tp_richcompare = gentype_richcompare;
    
#line 2703
    PyULongArrType_Type.tp_flags = BASEFLAGS;
    PyULongArrType_Type.tp_new = ulong_arrtype_new;
    PyULongArrType_Type.tp_richcompare = gentype_richcompare;
    
#line 2703
    PyULongLongArrType_Type.tp_flags = BASEFLAGS;
    PyULongLongArrType_Type.tp_new = ulonglong_arrtype_new;
    PyULongLongArrType_Type.tp_richcompare = gentype_richcompare;
    
#line 2703
    PyFloatArrType_Type.tp_flags = BASEFLAGS;
    PyFloatArrType_Type.tp_new = float_arrtype_new;
    PyFloatArrType_Type.tp_richcompare = gentype_richcompare;
    
#line 2703
    PyDoubleArrType_Type.tp_flags = BASEFLAGS;
    PyDoubleArrType_Type.tp_new = double_arrtype_new;
    PyDoubleArrType_Type.tp_richcompare = gentype_richcompare;
    
#line 2703
    PyLongDoubleArrType_Type.tp_flags = BASEFLAGS;
    PyLongDoubleArrType_Type.tp_new = longdouble_arrtype_new;
    PyLongDoubleArrType_Type.tp_richcompare = gentype_richcompare;
    
#line 2703
    PyCFloatArrType_Type.tp_flags = BASEFLAGS;
    PyCFloatArrType_Type.tp_new = cfloat_arrtype_new;
    PyCFloatArrType_Type.tp_richcompare = gentype_richcompare;
    
#line 2703
    PyCDoubleArrType_Type.tp_flags = BASEFLAGS;
    PyCDoubleArrType_Type.tp_new = cdouble_arrtype_new;
    PyCDoubleArrType_Type.tp_richcompare = gentype_richcompare;
    
#line 2703
    PyCLongDoubleArrType_Type.tp_flags = BASEFLAGS;
    PyCLongDoubleArrType_Type.tp_new = clongdouble_arrtype_new;
    PyCLongDoubleArrType_Type.tp_richcompare = gentype_richcompare;
    
#line 2703
    PyStringArrType_Type.tp_flags = BASEFLAGS;
    PyStringArrType_Type.tp_new = string_arrtype_new;
    PyStringArrType_Type.tp_richcompare = gentype_richcompare;
    
#line 2703
    PyUnicodeArrType_Type.tp_flags = BASEFLAGS;
    PyUnicodeArrType_Type.tp_new = unicode_arrtype_new;
    PyUnicodeArrType_Type.tp_richcompare = gentype_richcompare;
    
#line 2703
    PyVoidArrType_Type.tp_flags = BASEFLAGS;
    PyVoidArrType_Type.tp_new = void_arrtype_new;
    PyVoidArrType_Type.tp_richcompare = gentype_richcompare;
    
#line 2703
    PyObjectArrType_Type.tp_flags = BASEFLAGS;
    PyObjectArrType_Type.tp_new = object_arrtype_new;
    PyObjectArrType_Type.tp_richcompare = gentype_richcompare;
    

    #line 2712
    PyBoolArrType_Type.tp_hash = bool_arrtype_hash;
    
#line 2712
    PyByteArrType_Type.tp_hash = byte_arrtype_hash;
    
#line 2712
    PyShortArrType_Type.tp_hash = short_arrtype_hash;
    
#line 2712
    PyUByteArrType_Type.tp_hash = ubyte_arrtype_hash;
    
#line 2712
    PyUShortArrType_Type.tp_hash = ushort_arrtype_hash;
    
#line 2712
    PyUIntArrType_Type.tp_hash = uint_arrtype_hash;
    
#line 2712
    PyULongArrType_Type.tp_hash = ulong_arrtype_hash;
    
#line 2712
    PyULongLongArrType_Type.tp_hash = ulonglong_arrtype_hash;
    
#line 2712
    PyFloatArrType_Type.tp_hash = float_arrtype_hash;
    
#line 2712
    PyLongDoubleArrType_Type.tp_hash = longdouble_arrtype_hash;
    
#line 2712
    PyCFloatArrType_Type.tp_hash = cfloat_arrtype_hash;
    
#line 2712
    PyCLongDoubleArrType_Type.tp_hash = clongdouble_arrtype_hash;
    
#line 2712
    PyVoidArrType_Type.tp_hash = void_arrtype_hash;
    
#line 2712
    PyObjectArrType_Type.tp_hash = object_arrtype_hash;
    

#if SIZEOF_INT != SIZEOF_LONG
    /* We won't be inheriting from Python Int type. */
    PyIntArrType_Type.tp_hash = int_arrtype_hash;
#endif

#if SIZEOF_LONG != SIZEOF_LONGLONG
    /* We won't be inheriting from Python Int type. */
    PyLongLongArrType_Type.tp_hash = longlong_arrtype_hash;
#endif

    #line 2728
    PyFloatArrType_Type.tp_repr = floattype_repr;
    PyCFloatArrType_Type.tp_repr = cfloattype_repr;

    PyDoubleArrType_Type.tp_repr = doubletype_repr;
    PyCDoubleArrType_Type.tp_repr  = cdoubletype_repr;
    
#line 2728
    PyFloatArrType_Type.tp_str = floattype_str;
    PyCFloatArrType_Type.tp_str = cfloattype_str;

    PyDoubleArrType_Type.tp_str = doubletype_str;
    PyCDoubleArrType_Type.tp_str  = cdoubletype_str;
    

    /* These need to be coded specially because getitem does not
       return a normal Python type
     */
    PyLongDoubleArrType_Type.tp_as_number = &longdoubletype_as_number;
    PyCLongDoubleArrType_Type.tp_as_number = &clongdoubletype_as_number;

    #line 2745
    PyLongDoubleArrType_Type.tp_as_number->nb_int = longdoubletype_int;
    PyCLongDoubleArrType_Type.tp_as_number->nb_int = clongdoubletype_int;
    
#line 2745
    PyLongDoubleArrType_Type.tp_as_number->nb_long = longdoubletype_long;
    PyCLongDoubleArrType_Type.tp_as_number->nb_long = clongdoubletype_long;
    
#line 2745
    PyLongDoubleArrType_Type.tp_as_number->nb_hex = longdoubletype_hex;
    PyCLongDoubleArrType_Type.tp_as_number->nb_hex = clongdoubletype_hex;
    
#line 2745
    PyLongDoubleArrType_Type.tp_as_number->nb_oct = longdoubletype_oct;
    PyCLongDoubleArrType_Type.tp_as_number->nb_oct = clongdoubletype_oct;
    
#line 2745
    PyLongDoubleArrType_Type.tp_as_number->nb_float = longdoubletype_float;
    PyCLongDoubleArrType_Type.tp_as_number->nb_float = clongdoubletype_float;
    
#line 2745
    PyLongDoubleArrType_Type.tp_repr = longdoubletype_repr;
    PyCLongDoubleArrType_Type.tp_repr = clongdoubletype_repr;
    
#line 2745
    PyLongDoubleArrType_Type.tp_str = longdoubletype_str;
    PyCLongDoubleArrType_Type.tp_str = clongdoubletype_str;
    

    PyStringArrType_Type.tp_itemsize = sizeof(char);
    PyVoidArrType_Type.tp_dealloc = (destructor) void_dealloc;

    PyArrayIter_Type.tp_iter = PyObject_SelfIter;
    PyArrayMapIter_Type.tp_iter = PyObject_SelfIter;
}


/* the order of this table is important */
static PyTypeObject *typeobjects[] = {
    &PyBoolArrType_Type,
    &PyByteArrType_Type,
    &PyUByteArrType_Type,
    &PyShortArrType_Type,
    &PyUShortArrType_Type,
    &PyIntArrType_Type,
    &PyUIntArrType_Type,
    &PyLongArrType_Type,
    &PyULongArrType_Type,
    &PyLongLongArrType_Type,
    &PyULongLongArrType_Type,
    &PyFloatArrType_Type,
    &PyDoubleArrType_Type,
    &PyLongDoubleArrType_Type,
    &PyCFloatArrType_Type,
    &PyCDoubleArrType_Type,
    &PyCLongDoubleArrType_Type,
    &PyObjectArrType_Type,
    &PyStringArrType_Type,
    &PyUnicodeArrType_Type,
    &PyVoidArrType_Type
};

static int
_typenum_fromtypeobj(PyObject *type, int user)
{
    int typenum, i;

    typenum = PyArray_NOTYPE;
    i = 0;
    while(i < PyArray_NTYPES) {
        if (type == (PyObject *)typeobjects[i]) {
            typenum = i;
            break;
        }
        i++;
    }

    if (!user) return typenum;

    /* Search any registered types */
    i = 0;
    while (i < PyArray_NUMUSERTYPES) {
        if (type == (PyObject *)(userdescrs[i]->typeobj)) {
            typenum = i + PyArray_USERDEF;
            break;
        }
        i++;
    }
    return typenum;
}

static PyArray_Descr *
_descr_from_subtype(PyObject *type)
{
    PyObject *mro;
    mro = ((PyTypeObject *)type)->tp_mro;
    if (PyTuple_GET_SIZE(mro) < 2) {
        return PyArray_DescrFromType(PyArray_OBJECT);
    }
    return PyArray_DescrFromTypeObject(PyTuple_GET_ITEM(mro, 1));
}

/*New reference */
/*NUMPY_API
 */
static PyArray_Descr *
PyArray_DescrFromTypeObject(PyObject *type)
{
    int typenum;
    PyArray_Descr *new, *conv=NULL;

    /* if it's a builtin type, then use the typenumber */
    typenum = _typenum_fromtypeobj(type,1);
    if (typenum != PyArray_NOTYPE) {
        new = PyArray_DescrFromType(typenum);
        return new;
    }

    /* Check the generic types */
    if ((type == (PyObject *) &PyNumberArrType_Type) ||             \
            (type == (PyObject *) &PyInexactArrType_Type) ||            \
            (type == (PyObject *) &PyFloatingArrType_Type))
        typenum = PyArray_DOUBLE;
    else if (type == (PyObject *)&PyComplexFloatingArrType_Type)
        typenum = PyArray_CDOUBLE;
    else if ((type == (PyObject *)&PyIntegerArrType_Type) ||        \
            (type == (PyObject *)&PySignedIntegerArrType_Type))
        typenum = PyArray_LONG;
    else if (type == (PyObject *) &PyUnsignedIntegerArrType_Type)
        typenum = PyArray_ULONG;
    else if (type == (PyObject *) &PyCharacterArrType_Type)
        typenum = PyArray_STRING;
    else if ((type == (PyObject *) &PyGenericArrType_Type) || \
            (type == (PyObject *) &PyFlexibleArrType_Type))
        typenum = PyArray_VOID;

    if (typenum != PyArray_NOTYPE) {
        return PyArray_DescrFromType(typenum);
    }

    /* Otherwise --- type is a sub-type of an array scalar
       not corresponding to a registered data-type object.
     */

    /* Do special thing for VOID sub-types
     */
    if (PyType_IsSubtype((PyTypeObject *)type, &PyVoidArrType_Type)) {
        new = PyArray_DescrNewFromType(PyArray_VOID);

        conv = _arraydescr_fromobj(type);
        if (conv) {
            new->fields = conv->fields;
            Py_INCREF(new->fields);
            new->names = conv->names;
            Py_INCREF(new->names);
            new->elsize = conv->elsize;
            new->subarray = conv->subarray;
            conv->subarray = NULL;
            Py_DECREF(conv);
        }
        Py_XDECREF(new->typeobj);
        new->typeobj = (PyTypeObject *)type;
        Py_INCREF(type);
        return new;
    }
    return _descr_from_subtype(type);
}

/*NUMPY_API
  Return the tuple of ordered field names from a dictionary.
*/
static PyObject *
PyArray_FieldNames(PyObject *fields)
{
    PyObject *tup;
    PyObject *ret;
    PyObject *_numpy_internal;

    if (!PyDict_Check(fields)) {
        PyErr_SetString(PyExc_TypeError,
                "Fields must be a dictionary");
        return NULL;
    }
    _numpy_internal = PyImport_ImportModule("numpy.core._internal");
    if (_numpy_internal == NULL) return NULL;
    tup = PyObject_CallMethod(_numpy_internal, "_makenames_list", "O", fields);
    Py_DECREF(_numpy_internal);
    if (tup == NULL) return NULL;
    ret = PyTuple_GET_ITEM(tup, 0);
    ret = PySequence_Tuple(ret);
    Py_DECREF(tup);
    return ret;
}

/* New reference */
/*NUMPY_API
 Return descr object from array scalar.
*/
static PyArray_Descr *
PyArray_DescrFromScalar(PyObject *sc)
{
    int type_num;
    PyArray_Descr *descr;

    if (PyArray_IsScalar(sc, Void)) {
        descr = ((PyVoidScalarObject *)sc)->descr;
        Py_INCREF(descr);
        return descr;
    }
    descr = PyArray_DescrFromTypeObject((PyObject *)sc->ob_type);
    if (descr->elsize == 0) {
        PyArray_DESCR_REPLACE(descr);
        type_num = descr->type_num;
        if (type_num == PyArray_STRING)
            descr->elsize = PyString_GET_SIZE(sc);
        else if (type_num == PyArray_UNICODE) {
            descr->elsize = PyUnicode_GET_DATA_SIZE(sc);
#ifndef Py_UNICODE_WIDE
            descr->elsize <<= 1;
#endif
        }
        else {
            descr->elsize =
                ((PyVoidScalarObject *)sc)->ob_size;
            descr->fields = PyObject_GetAttrString(sc, "fields");
            if (!descr->fields || !PyDict_Check(descr->fields) ||
                    (descr->fields == Py_None)) {
                Py_XDECREF(descr->fields);
                descr->fields = NULL;
            }
            if (descr->fields)
                descr->names = PyArray_FieldNames(descr->fields);
            PyErr_Clear();
        }
    }
    return descr;
}

/* New reference */
/*NUMPY_API
 Get a typeobject from a type-number -- can return NULL.
*/
static PyObject *
PyArray_TypeObjectFromType(int type)
{
    PyArray_Descr *descr;
    PyObject *obj;

    descr = PyArray_DescrFromType(type);
    if (descr == NULL) return NULL;
    obj = (PyObject *)descr->typeobj;
    Py_XINCREF(obj);
    Py_DECREF(descr);
    return obj;
}

