#line 1 "numpy/core/src/umathmodule.c.src"

/*
 *****************************************************************************
 **       This file was autogenerated from a template  DO NOT EDIT!!!!      **
 **       Changes should be made to the original source (.src) file         **
 *****************************************************************************
 */

#line 1
/* -*- c -*- */

/*
 *****************************************************************************
 **                            INCLUDES                                     **
 *****************************************************************************
 */
#include "Python.h"
#include "numpy/noprefix.h"
#define _UMATHMODULE
#include "numpy/ufuncobject.h"
#include "abstract.h"
#include "config.h"
#include <math.h>

/*
 *****************************************************************************
 **                     BASIC MATH FUNCTIONS                                **
 *****************************************************************************
 */

/* A whole slew of basic math functions are provided originally
   by Konrad Hinsen. */

#if !defined(__STDC__) && !defined(_MSC_VER)
extern double fmod (double, double);
extern double frexp (double, int *);
extern double ldexp (double, int);
extern double modf (double, double *);
#endif
#ifndef M_PI
#define M_PI 3.14159265358979323846264338328
#endif


#if defined(DISTUTILS_USE_SDK)
/* win32 on AMD64 build architecture */
/* See also http://projects.scipy.org/scipy/numpy/ticket/164 */
#ifndef HAVE_FABSF
#ifdef fabsf
#undef fabsf
#endif
static float fabsf(float x)
{
    return (float)fabs((double)(x));
}
#endif
#ifndef HAVE_HYPOTF
static float hypotf(float x, float y)
{
    return (float)hypot((double)(x), (double)(y));
}
#endif
#ifndef HAVE_RINTF
#ifndef HAVE_RINT
static double rint (double x);
#endif
static float rintf(float x)
{
    return (float)rint((double)(x));
}
#endif
#ifndef HAVE_FREXPF
static float frexpf(float x, int * i)
{
    return (float)frexp((double)(x), i);
}
#endif
#ifndef HAVE_LDEXPF
static float ldexpf(float x, int i)
{
    return (float)ldexp((double)(x), i);
}
#endif
#define tanhf nc_tanhf
#endif

#ifndef HAVE_INVERSE_HYPERBOLIC
static double acosh(double x)
{
    return 2*log(sqrt((x+1.0)/2)+sqrt((x-1.0)/2));
}

double log1p(double);
static double asinh(double xx)
{
    double x, d;
    int sign;
    if (xx < 0.0) {
        sign = -1;
        x = -xx;
    }
    else {
        sign = 1;
        x = xx;
    }
    if (x > 1e8) {
        d = x;
    } else {
        d = sqrt(x*x + 1);
    }
    return sign*log1p(x*(1.0 + x/(d+1)));
}

static double atanh(double x)
{
    return 0.5*log1p(2.0*x/(1.0-x));
}
#endif

#if !defined(HAVE_INVERSE_HYPERBOLIC_FLOAT)
#ifdef HAVE_FLOAT_FUNCS
#ifdef log1pf
#undef log1pf
#endif
#ifdef logf
#undef logf
#endif
#ifdef sqrtf
#undef sqrtf
#endif
float log1pf(float);
#ifdef DISTUTILS_USE_SDK
DL_IMPORT(float) logf(float);
DL_IMPORT(float) sqrtf(float);
#else
/* should these be extern?: */
float logf(float);
float sqrtf(float);
#endif
#ifdef acoshf
#undef acoshf
#endif
static float acoshf(float x)
{
    return 2*logf(sqrtf((x+1)/2)+sqrtf((x-1)/2));
}

#ifdef asinhf
#undef asinhf
#endif
static float asinhf(float xx)
{
    float x, d;
    int sign;
    if (xx < 0) {
        sign = -1;
        x = -xx;
    }
    else {
        sign = 1;
        x = xx;
    }
    if (x > 1e5) {
        d = x;
    } else {
        d = sqrtf(x*x + 1);
    }
    return sign*log1pf(x*(1 + x/(d+1)));
}

#ifdef atanhf
#undef atanhf
#endif
static float atanhf(float x)
{
    return log1pf(2*x/(1-x))/2;
}
#else
#ifdef acoshf
#undef acoshf
#endif
static float acoshf(float x)
{
    return (float)acosh((double)(x));
}

#ifdef asinhf
#undef asinhf
#endif
static float asinhf(float x)
{
    return (float)asinh((double)(x));
}

#ifdef atanhf
#undef atanhf
#endif
static float atanhf(float x)
{
    return (float)atanh((double)(x));
}
#endif
#endif


#if !defined(HAVE_INVERSE_HYPERBOLIC_LONGDOUBLE)
#ifdef HAVE_LONGDOUBLE_FUNCS
#ifdef logl
#undef logl
#endif
#ifdef sqrtl
#undef sqrtl
#endif
#ifdef log1pl
#undef log1pl
#endif
longdouble logl(longdouble);
longdouble sqrtl(longdouble);
longdouble log1pl(longdouble);
#ifdef acoshl
#undef acoshl
#endif
static longdouble acoshl(longdouble x)
{
    return 2*logl(sqrtl((x+1.0)/2)+sqrtl((x-1.0)/2));
}

#ifdef asinhl
#undef asinhl
#endif
static longdouble asinhl(longdouble xx)
{
    longdouble x, d;
    int sign;
    if (xx < 0.0) {
        sign = -1;
        x = -xx;
    }
    else {
        sign = 1;
        x = xx;
    }
    if (x > 1e17) {
        d = x;
    } else {
        d = sqrtl(x*x + 1);
    }
    return sign*log1pl(x*(1.0 + x/(d+1)));
}

#ifdef atanhl
#undef atanhl
#endif
static longdouble atanhl(longdouble x)
{
    return 0.5*log1pl(2.0*x/(1.0-x));
}

#else

#ifdef acoshl
#undef acoshl
#endif
static longdouble acoshl(longdouble x)
{
    return (longdouble)acosh((double)(x));
}

#ifdef asinhl
#undef asinhl
#endif
static longdouble asinhl(longdouble x)
{
    return (longdouble)asinh((double)(x));
}

#ifdef atanhl
#undef atanhl
#endif
static longdouble atanhl(longdouble x)
{
    return (longdouble)atanh((double)(x));
}

#endif
#endif


#ifdef HAVE_HYPOT
#if !defined(NeXT) && !defined(_MSC_VER)
extern double hypot(double, double);
#endif
#else
static double hypot(double x, double y)
{
    double yx;

    x = fabs(x);
    y = fabs(y);
    if (x < y) {
        double temp = x;
        x = y;
        y = temp;
    }
    if (x == 0.)
        return 0.;
    else {
        yx = y/x;
        return x*sqrt(1.+yx*yx);
    }
}
#endif


#ifndef HAVE_RINT
static double
rint (double x)
{
    double y, r;

    y = floor(x);
    r = x - y;

    if (r > 0.5) goto rndup;

    /* Round to nearest even */
    if (r==0.5) {
        r = y - 2.0*floor(0.5*y);
        if (r==1.0) {
        rndup:
            y+=1.0;
        }
    }
    return y;
}
#endif





/* Define isnan, isinf, isfinite, signbit if needed */
/* Use fpclassify if possible */
/* isnan, isinf --
   these will use macros and then fpclassify if available before
   defaulting to a dumb convert-to-double version...

   isfinite -- define a macro if not already available
   signbit -- if macro available use it, otherwise define a function
   and a dumb convert-to-double version for other types.
*/

#if defined(fpclassify)

#if !defined(isnan)
#define isnan(x) (fpclassify(x) == FP_NAN)
#endif
#if !defined(isinf)
#define isinf(x) (fpclassify(x) == FP_INFINITE)
#endif

#else  /* check to see if already have a function like this */

#if !defined(HAVE_ISNAN)

#if !defined(isnan)
#include "_isnan.c"
#endif
#endif /* HAVE_ISNAN */

#if !defined(HAVE_ISINF)
#if !defined(isinf)
#define isinf(x) (!isnan((x)) && isnan((x)-(x)))
#endif
#endif /* HAVE_ISINF */

#endif /* defined(fpclassify) */


/* Define signbit if needed */
#if !defined(signbit)
#include "_signbit.c"
#endif

/* Now defined the extended type macros */

#if !defined(isnan)

#if !defined(HAVE_LONGDOUBLE_FUNCS) || !defined(HAVE_ISNAN)
#define isnanl(x) isnan((double)(x))
#endif

#if !defined(HAVE_FLOAT_FUNCS) || !defined(HAVE_ISNAN)
#define isnanf(x) isnan((double)(x))
#endif

#else /* !defined(isnan) */

#define isnanl(x) isnan((x))
#define isnanf(x) isnan((x))

#endif /* !defined(isnan) */


#if !defined(isinf)

#if !defined(HAVE_LONGDOUBLE_FUNCS) || !defined(HAVE_ISINF)
#define isinfl(x) (!isnanl((x)) && isnanl((x)-(x)))
#endif

#if !defined(HAVE_FLOAT_FUNCS) || !defined(HAVE_ISINF)
#define isinff(x) (!isnanf((x)) && isnanf((x)-(x)))
#endif

#else /* !defined(isinf) */

#define isinfl(x) isinf((x))
#define isinff(x) isinf((x))

#endif /* !defined(isinf) */


#if !defined(signbit)
#define signbitl(x) ((longdouble) signbit((double)(x)))
#define signbitf(x) ((float) signbit((double) (x)))
#else
#define signbitl(x) signbit((x))
#define signbitf(x) signbit((x))
#endif

#if !defined(isfinite)
#define isfinite(x) (!(isinf((x)) || isnan((x))))
#endif
#define isfinitef(x) (!(isinff((x)) || isnanf((x))))
#define isfinitel(x) (!(isinfl((x)) || isnanl((x))))

float degreesf(float x) {
    return x * (float)(180.0/M_PI);
}
double degrees(double x) {
    return x * (180.0/M_PI);
}
longdouble degreesl(longdouble x) {
    return x * (180.0L/M_PI);
}

float radiansf(float x) {
    return x * (float)(M_PI/180.0);
}
double radians(double x) {
    return x * (M_PI/180.0);
}
longdouble radiansl(longdouble x) {
    return x * (M_PI/180.0L);
}

/* First, the C functions that do the real work */

/* if C99 extensions not available then define dummy functions that use the
   double versions for

   sin, cos, tan
   sinh, cosh, tanh,
   fabs, floor, ceil, fmod, sqrt, log10, log, exp, fabs
   asin, acos, atan,
   asinh, acosh, atanh

   hypot, atan2, pow
*/

#line 469

#ifndef HAVE_LONGDOUBLE_FUNCS
#ifdef sinl
#undef sinl
#endif
longdouble sinl(longdouble x) {
    return (longdouble) sin((double)x);
}
#endif

#line 469

#ifndef HAVE_LONGDOUBLE_FUNCS
#ifdef cosl
#undef cosl
#endif
longdouble cosl(longdouble x) {
    return (longdouble) cos((double)x);
}
#endif

#line 469

#ifndef HAVE_LONGDOUBLE_FUNCS
#ifdef tanl
#undef tanl
#endif
longdouble tanl(longdouble x) {
    return (longdouble) tan((double)x);
}
#endif

#line 469

#ifndef HAVE_LONGDOUBLE_FUNCS
#ifdef sinhl
#undef sinhl
#endif
longdouble sinhl(longdouble x) {
    return (longdouble) sinh((double)x);
}
#endif

#line 469

#ifndef HAVE_LONGDOUBLE_FUNCS
#ifdef coshl
#undef coshl
#endif
longdouble coshl(longdouble x) {
    return (longdouble) cosh((double)x);
}
#endif

#line 469

#ifndef HAVE_LONGDOUBLE_FUNCS
#ifdef tanhl
#undef tanhl
#endif
longdouble tanhl(longdouble x) {
    return (longdouble) tanh((double)x);
}
#endif

#line 469

#ifndef HAVE_LONGDOUBLE_FUNCS
#ifdef fabsl
#undef fabsl
#endif
longdouble fabsl(longdouble x) {
    return (longdouble) fabs((double)x);
}
#endif

#line 469

#ifndef HAVE_LONGDOUBLE_FUNCS
#ifdef floorl
#undef floorl
#endif
longdouble floorl(longdouble x) {
    return (longdouble) floor((double)x);
}
#endif

#line 469

#ifndef HAVE_LONGDOUBLE_FUNCS
#ifdef ceill
#undef ceill
#endif
longdouble ceill(longdouble x) {
    return (longdouble) ceil((double)x);
}
#endif

#line 469

#ifndef HAVE_LONGDOUBLE_FUNCS
#ifdef sqrtl
#undef sqrtl
#endif
longdouble sqrtl(longdouble x) {
    return (longdouble) sqrt((double)x);
}
#endif

#line 469

#ifndef HAVE_LONGDOUBLE_FUNCS
#ifdef log10l
#undef log10l
#endif
longdouble log10l(longdouble x) {
    return (longdouble) log10((double)x);
}
#endif

#line 469

#ifndef HAVE_LONGDOUBLE_FUNCS
#ifdef logl
#undef logl
#endif
longdouble logl(longdouble x) {
    return (longdouble) log((double)x);
}
#endif

#line 469

#ifndef HAVE_LONGDOUBLE_FUNCS
#ifdef expl
#undef expl
#endif
longdouble expl(longdouble x) {
    return (longdouble) exp((double)x);
}
#endif

#line 469

#ifndef HAVE_LONGDOUBLE_FUNCS
#ifdef asinl
#undef asinl
#endif
longdouble asinl(longdouble x) {
    return (longdouble) asin((double)x);
}
#endif

#line 469

#ifndef HAVE_LONGDOUBLE_FUNCS
#ifdef acosl
#undef acosl
#endif
longdouble acosl(longdouble x) {
    return (longdouble) acos((double)x);
}
#endif

#line 469

#ifndef HAVE_LONGDOUBLE_FUNCS
#ifdef atanl
#undef atanl
#endif
longdouble atanl(longdouble x) {
    return (longdouble) atan((double)x);
}
#endif

#line 469

#ifndef HAVE_LONGDOUBLE_FUNCS
#ifdef rintl
#undef rintl
#endif
longdouble rintl(longdouble x) {
    return (longdouble) rint((double)x);
}
#endif

#line 469

#ifndef HAVE_FLOAT_FUNCS
#ifdef sinf
#undef sinf
#endif
float sinf(float x) {
    return (float) sin((double)x);
}
#endif

#line 469

#ifndef HAVE_FLOAT_FUNCS
#ifdef cosf
#undef cosf
#endif
float cosf(float x) {
    return (float) cos((double)x);
}
#endif

#line 469

#ifndef HAVE_FLOAT_FUNCS
#ifdef tanf
#undef tanf
#endif
float tanf(float x) {
    return (float) tan((double)x);
}
#endif

#line 469

#ifndef HAVE_FLOAT_FUNCS
#ifdef sinhf
#undef sinhf
#endif
float sinhf(float x) {
    return (float) sinh((double)x);
}
#endif

#line 469

#ifndef HAVE_FLOAT_FUNCS
#ifdef coshf
#undef coshf
#endif
float coshf(float x) {
    return (float) cosh((double)x);
}
#endif

#line 469

#ifndef HAVE_FLOAT_FUNCS
#ifdef tanhf
#undef tanhf
#endif
float tanhf(float x) {
    return (float) tanh((double)x);
}
#endif

#line 469

#ifndef HAVE_FLOAT_FUNCS
#ifdef fabsf
#undef fabsf
#endif
float fabsf(float x) {
    return (float) fabs((double)x);
}
#endif

#line 469

#ifndef HAVE_FLOAT_FUNCS
#ifdef floorf
#undef floorf
#endif
float floorf(float x) {
    return (float) floor((double)x);
}
#endif

#line 469

#ifndef HAVE_FLOAT_FUNCS
#ifdef ceilf
#undef ceilf
#endif
float ceilf(float x) {
    return (float) ceil((double)x);
}
#endif

#line 469

#ifndef HAVE_FLOAT_FUNCS
#ifdef sqrtf
#undef sqrtf
#endif
float sqrtf(float x) {
    return (float) sqrt((double)x);
}
#endif

#line 469

#ifndef HAVE_FLOAT_FUNCS
#ifdef log10f
#undef log10f
#endif
float log10f(float x) {
    return (float) log10((double)x);
}
#endif

#line 469

#ifndef HAVE_FLOAT_FUNCS
#ifdef logf
#undef logf
#endif
float logf(float x) {
    return (float) log((double)x);
}
#endif

#line 469

#ifndef HAVE_FLOAT_FUNCS
#ifdef expf
#undef expf
#endif
float expf(float x) {
    return (float) exp((double)x);
}
#endif

#line 469

#ifndef HAVE_FLOAT_FUNCS
#ifdef asinf
#undef asinf
#endif
float asinf(float x) {
    return (float) asin((double)x);
}
#endif

#line 469

#ifndef HAVE_FLOAT_FUNCS
#ifdef acosf
#undef acosf
#endif
float acosf(float x) {
    return (float) acos((double)x);
}
#endif

#line 469

#ifndef HAVE_FLOAT_FUNCS
#ifdef atanf
#undef atanf
#endif
float atanf(float x) {
    return (float) atan((double)x);
}
#endif

#line 469

#ifndef HAVE_FLOAT_FUNCS
#ifdef rintf
#undef rintf
#endif
float rintf(float x) {
    return (float) rint((double)x);
}
#endif


#line 487
#ifndef HAVE_LONGDOUBLE_FUNCS
#ifdef atan2l
#undef atan2l
#endif
longdouble atan2l(longdouble x, longdouble y) {
    return (longdouble) atan2((double)x, (double) y);
}
#endif

#line 487
#ifndef HAVE_LONGDOUBLE_FUNCS
#ifdef hypotl
#undef hypotl
#endif
longdouble hypotl(longdouble x, longdouble y) {
    return (longdouble) hypot((double)x, (double) y);
}
#endif

#line 487
#ifndef HAVE_LONGDOUBLE_FUNCS
#ifdef powl
#undef powl
#endif
longdouble powl(longdouble x, longdouble y) {
    return (longdouble) pow((double)x, (double) y);
}
#endif

#line 487
#ifndef HAVE_LONGDOUBLE_FUNCS
#ifdef fmodl
#undef fmodl
#endif
longdouble fmodl(longdouble x, longdouble y) {
    return (longdouble) fmod((double)x, (double) y);
}
#endif

#line 487
#ifndef HAVE_FLOAT_FUNCS
#ifdef atan2f
#undef atan2f
#endif
float atan2f(float x, float y) {
    return (float) atan2((double)x, (double) y);
}
#endif

#line 487
#ifndef HAVE_FLOAT_FUNCS
#ifdef hypotf
#undef hypotf
#endif
float hypotf(float x, float y) {
    return (float) hypot((double)x, (double) y);
}
#endif

#line 487
#ifndef HAVE_FLOAT_FUNCS
#ifdef powf
#undef powf
#endif
float powf(float x, float y) {
    return (float) pow((double)x, (double) y);
}
#endif

#line 487
#ifndef HAVE_FLOAT_FUNCS
#ifdef fmodf
#undef fmodf
#endif
float fmodf(float x, float y) {
    return (float) fmod((double)x, (double) y);
}
#endif


#line 503
#ifndef HAVE_LONGDOUBLE_FUNCS
#ifdef modfl
#undef modfl
#endif
longdouble modfl(longdouble x, longdouble *iptr) {
    double nx, niptr, y;
    nx = (double) x;
    y = modf(nx, &niptr);
    *iptr = (longdouble) niptr;
    return (longdouble) y;
}
#endif

#line 503
#ifndef HAVE_FLOAT_FUNCS
#ifdef modff
#undef modff
#endif
float modff(float x, float *iptr) {
    double nx, niptr, y;
    nx = (double) x;
    y = modf(nx, &niptr);
    *iptr = (float) niptr;
    return (float) y;
}
#endif




#ifndef HAVE_LOG1P
double log1p(double x)
{
    double u = 1. + x;
    if (u == 1.0) {
        return x;
    } else {
        return log(u) * x / (u-1.);
    }
}
#endif

#if !defined(HAVE_LOG1P) || !defined(HAVE_LONGDOUBLE_FUNCS)
#ifdef log1pl
#undef log1pl
#endif
longdouble log1pl(longdouble x)
{
    longdouble u = 1. + x;
    if (u == 1.0) {
        return x;
    } else {
        return logl(u) * x / (u-1.);
    }
}
#endif

#if !defined(HAVE_LOG1P) || !defined(HAVE_FLOAT_FUNCS)
#ifdef log1pf
#undef log1pf
#endif
float log1pf(float x)
{
    float u = 1 + x;
    if (u == 1) {
        return x;
    } else {
        return logf(u) * x / (u-1);
    }
}
#endif

#ifndef HAVE_EXPM1
static double expm1(double x)
{
    double u = exp(x);
    if (u == 1.0) {
        return x;
    } else if (u-1.0 == -1.0) {
        return -1;
    } else {
        return (u-1.0) * x/log(u);
    }
}
#endif

#if !defined(HAVE_EXPM1) || !defined(HAVE_LONGDOUBLE_FUNCS)
#ifdef expml1
#undef expml1
#endif
static longdouble expm1l(longdouble x)
{
    longdouble u = expl(x);
    if (u == 1.0) {
        return x;
    } else if (u-1.0 == -1.0) {
        return -1;
    } else {
        return (u-1.0) * x/logl(u);
    }
}
#endif

#if !defined(HAVE_EXPM1) || !defined(HAVE_FLOAT_FUNCS)
#ifdef expm1f
#undef expm1f
#endif
static float expm1f(float x)
{
    float u = expf(x);
    if (u == 1) {
        return x;
    } else if (u-1 == -1) {
        return -1;
    } else {
        return (u-1) * x/logf(u);
    }
}
#endif


/*
 *****************************************************************************
 **                           COMPLEX FUNCTIONS                             **
 *****************************************************************************
 */


/* Don't pass structures between functions (only pointers) because how
   structures are passed is compiler dependent and could cause
   segfaults if ufuncobject.c is compiled with a different compiler
   than an extension that makes use of the UFUNC API
*/

#line 628

/* constants */
static cfloat nc_1f = {1., 0.};
static cfloat nc_halff = {0.5, 0.};
static cfloat nc_if = {0., 1.};
static cfloat nc_i2f = {0., 0.5};
/*
  static cfloat nc_mif = {0., -1.};
  static cfloat nc_pi2f = {M_PI/2., 0.};
*/

static void
nc_sumf(cfloat *a, cfloat *b, cfloat *r)
{
    r->real = a->real + b->real;
    r->imag = a->imag + b->imag;
    return;
}

static void
nc_difff(cfloat *a, cfloat *b, cfloat *r)
{
    r->real = a->real - b->real;
    r->imag = a->imag - b->imag;
    return;
}

static void
nc_negf(cfloat *a, cfloat *r)
{
    r->real = -a->real;
    r->imag = -a->imag;
    return;
}

static void
nc_prodf(cfloat *a, cfloat *b, cfloat *r)
{
    register float ar=a->real, br=b->real, ai=a->imag, bi=b->imag;
    r->real = ar*br - ai*bi;
    r->imag = ar*bi + ai*br;
    return;
}

static void
nc_quotf(cfloat *a, cfloat *b, cfloat *r)
{

    register float ar=a->real, br=b->real, ai=a->imag, bi=b->imag;
    register float d = br*br + bi*bi;
    r->real = (ar*br + ai*bi)/d;
    r->imag = (ai*br - ar*bi)/d;
    return;
}

static void
nc_sqrtf(cfloat *x, cfloat *r)
{
    float s,d;
    if (x->real == 0. && x->imag == 0.)
        *r = *x;
    else {
        s = sqrtf((fabsf(x->real) + hypotf(x->real,x->imag))/2);
        d = x->imag/(2*s);
        if (x->real > 0) {
            r->real = s;
            r->imag = d;
        }
        else if (x->imag >= 0) {
            r->real = d;
            r->imag = s;
        }
        else {
            r->real = -d;
            r->imag = -s;
        }
    }
    return;
}

static void
nc_rintf(cfloat *x, cfloat *r)
{
    r->real = rintf(x->real);
    r->imag = rintf(x->imag);
}

static void
nc_logf(cfloat *x, cfloat *r)
{
    float l = hypotf(x->real,x->imag);
    r->imag = atan2f(x->imag, x->real);
    r->real = logf(l);
    return;
}

static void
nc_log1pf(cfloat *x, cfloat *r)
{
    float l = hypotf(x->real + 1,x->imag);
    r->imag = atan2f(x->imag, x->real + 1);
    r->real = logf(l);
    return;
}

static void
nc_expf(cfloat *x, cfloat *r)
{
    float a = expf(x->real);
    r->real = a*cosf(x->imag);
    r->imag = a*sinf(x->imag);
    return;
}

static void
nc_expm1f(cfloat *x, cfloat *r)
{
    float a = expf(x->real);
    r->real = a*cosf(x->imag) - 1;
    r->imag = a*sinf(x->imag);
    return;
}

static void
nc_powf(cfloat *a, cfloat *b, cfloat *r)
{
    intp n;
    float ar=a->real, br=b->real, ai=a->imag, bi=b->imag;

    if (br == 0. && bi == 0.) {
        r->real = 1.;
        r->imag = 0.;
        return;
    }
    if (ar == 0. && ai == 0.) {
        r->real = 0.;
        r->imag = 0.;
        return;
    }
    if (bi == 0 && (n=(intp)br) == br) {
        if (n > -100 && n < 100) {
            cfloat p, aa;
            intp mask = 1;
            if (n < 0) n = -n;
            aa = nc_1f;
            p.real = ar; p.imag = ai;
            while (1) {
                if (n & mask)
                    nc_prodf(&aa,&p,&aa);
                mask <<= 1;
                if (n < mask || mask <= 0) break;
                nc_prodf(&p,&p,&p);
            }
            r->real = aa.real; r->imag = aa.imag;
            if (br < 0) nc_quotf(&nc_1f, r, r);
            return;
        }
    }
    /* complexobect.c uses an inline version of this formula
       investigate whether this had better performance or accuracy */
    nc_logf(a, r);
    nc_prodf(r, b, r);
    nc_expf(r, r);
    return;
}


static void
nc_prodif(cfloat *x, cfloat *r)
{
    float xr = x->real;
    r->real = -x->imag;
    r->imag = xr;
    return;
}


static void
nc_acosf(cfloat *x, cfloat *r)
{
    nc_prodf(x,x,r);
    nc_difff(&nc_1f, r, r);
    nc_sqrtf(r, r);
    nc_prodif(r, r);
    nc_sumf(x, r, r);
    nc_logf(r, r);
    nc_prodif(r, r);
    nc_negf(r, r);
    return;
    /* return nc_neg(nc_prodi(nc_log(nc_sum(x,nc_prod(nc_i,
       nc_sqrt(nc_diff(nc_1,nc_prod(x,x))))))));
    */
}

static void
nc_acoshf(cfloat *x, cfloat *r)
{
    cfloat t;

    nc_sumf(x, &nc_1f, &t);
    nc_sqrtf(&t, &t);
    nc_difff(x, &nc_1f, r);
    nc_sqrtf(r, r);
    nc_prodf(&t, r, r);
    nc_sumf(x, r, r);
    nc_logf(r, r);
    return;
    /*
     * log(x + sqrt(x + 1)*sqrt(x - 1)
     */
}

static void
nc_asinf(cfloat *x, cfloat *r)
{
    cfloat a, *pa=&a;
    nc_prodf(x, x, r);
    nc_difff(&nc_1f, r, r);
    nc_sqrtf(r, r);
    nc_prodif(x, pa);
    nc_sumf(pa, r, r);
    nc_logf(r, r);
    nc_prodif(r, r);
    nc_negf(r, r);
    return;
    /*
      return nc_neg(nc_prodi(nc_log(nc_sum(nc_prod(nc_i,x),
      nc_sqrt(nc_diff(nc_1,nc_prod(x,x)))))));
    */
}


static void
nc_asinhf(cfloat *x, cfloat *r)
{
    nc_prodf(x, x, r);
    nc_sumf(&nc_1f, r, r);
    nc_sqrtf(r, r);
    nc_sumf(r, x, r);
    nc_logf(r, r);
    return;
    /*
     * log(x + sqrt(1 + x**2))
     */
}

static void
nc_atanf(cfloat *x, cfloat *r)
{
    cfloat a, *pa=&a;
    nc_difff(&nc_if, x, pa);
    nc_sumf(&nc_if, x, r);
    nc_quotf(r, pa, r);
    nc_logf(r,r);
    nc_prodf(&nc_i2f, r, r);
    return;
    /*
      return nc_prod(nc_i2,nc_log(nc_quot(nc_sum(nc_i,x),nc_diff(nc_i,x))));
    */
}

static void
nc_atanhf(cfloat *x, cfloat *r)
{
    cfloat a, *pa=&a;
    nc_difff(&nc_1f, x, r);
    nc_sumf(&nc_1f, x, pa);
    nc_quotf(pa, r, r);
    nc_logf(r, r);
    nc_prodf(&nc_halff, r, r);
    return;
    /*
      return nc_prod(nc_half,nc_log(nc_quot(nc_sum(nc_1,x),nc_diff(nc_1,x))));
    */
}

static void
nc_cosf(cfloat *x, cfloat *r)
{
    float xr=x->real, xi=x->imag;
    r->real = cosf(xr)*coshf(xi);
    r->imag = -sinf(xr)*sinhf(xi);
    return;
}

static void
nc_coshf(cfloat *x, cfloat *r)
{
    float xr=x->real, xi=x->imag;
    r->real = cosf(xi)*coshf(xr);
    r->imag = sinf(xi)*sinhf(xr);
    return;
}


#define M_LOG10_E 0.434294481903251827651128918916605082294397

static void
nc_log10f(cfloat *x, cfloat *r)
{
    nc_logf(x, r);
    r->real *= (float) M_LOG10_E;
    r->imag *= (float) M_LOG10_E;
    return;
}

static void
nc_sinf(cfloat *x, cfloat *r)
{
    float xr=x->real, xi=x->imag;
    r->real = sinf(xr)*coshf(xi);
    r->imag = cosf(xr)*sinhf(xi);
    return;
}

static void
nc_sinhf(cfloat *x, cfloat *r)
{
    float xr=x->real, xi=x->imag;
    r->real = cosf(xi)*sinhf(xr);
    r->imag = sinf(xi)*coshf(xr);
    return;
}

static void
nc_tanf(cfloat *x, cfloat *r)
{
    float sr,cr,shi,chi;
    float rs,is,rc,ic;
    float d;
    float xr=x->real, xi=x->imag;
    sr = sinf(xr);
    cr = cosf(xr);
    shi = sinhf(xi);
    chi = coshf(xi);
    rs = sr*chi;
    is = cr*shi;
    rc = cr*chi;
    ic = -sr*shi;
    d = rc*rc + ic*ic;
    r->real = (rs*rc+is*ic)/d;
    r->imag = (is*rc-rs*ic)/d;
    return;
}

static void
nc_tanhf(cfloat *x, cfloat *r)
{
    float si,ci,shr,chr;
    float rs,is,rc,ic;
    float d;
    float xr=x->real, xi=x->imag;
    si = sinf(xi);
    ci = cosf(xi);
    shr = sinhf(xr);
    chr = coshf(xr);
    rs = ci*shr;
    is = si*chr;
    rc = ci*chr;
    ic = si*shr;
    d = rc*rc + ic*ic;
    r->real = (rs*rc+is*ic)/d;
    r->imag = (is*rc-rs*ic)/d;
    return;
}


#line 628

/* constants */
static cdouble nc_1 = {1., 0.};
static cdouble nc_half = {0.5, 0.};
static cdouble nc_i = {0., 1.};
static cdouble nc_i2 = {0., 0.5};
/*
  static cdouble nc_mi = {0., -1.};
  static cdouble nc_pi2 = {M_PI/2., 0.};
*/

static void
nc_sum(cdouble *a, cdouble *b, cdouble *r)
{
    r->real = a->real + b->real;
    r->imag = a->imag + b->imag;
    return;
}

static void
nc_diff(cdouble *a, cdouble *b, cdouble *r)
{
    r->real = a->real - b->real;
    r->imag = a->imag - b->imag;
    return;
}

static void
nc_neg(cdouble *a, cdouble *r)
{
    r->real = -a->real;
    r->imag = -a->imag;
    return;
}

static void
nc_prod(cdouble *a, cdouble *b, cdouble *r)
{
    register double ar=a->real, br=b->real, ai=a->imag, bi=b->imag;
    r->real = ar*br - ai*bi;
    r->imag = ar*bi + ai*br;
    return;
}

static void
nc_quot(cdouble *a, cdouble *b, cdouble *r)
{

    register double ar=a->real, br=b->real, ai=a->imag, bi=b->imag;
    register double d = br*br + bi*bi;
    r->real = (ar*br + ai*bi)/d;
    r->imag = (ai*br - ar*bi)/d;
    return;
}

static void
nc_sqrt(cdouble *x, cdouble *r)
{
    double s,d;
    if (x->real == 0. && x->imag == 0.)
        *r = *x;
    else {
        s = sqrt((fabs(x->real) + hypot(x->real,x->imag))/2);
        d = x->imag/(2*s);
        if (x->real > 0) {
            r->real = s;
            r->imag = d;
        }
        else if (x->imag >= 0) {
            r->real = d;
            r->imag = s;
        }
        else {
            r->real = -d;
            r->imag = -s;
        }
    }
    return;
}

static void
nc_rint(cdouble *x, cdouble *r)
{
    r->real = rint(x->real);
    r->imag = rint(x->imag);
}

static void
nc_log(cdouble *x, cdouble *r)
{
    double l = hypot(x->real,x->imag);
    r->imag = atan2(x->imag, x->real);
    r->real = log(l);
    return;
}

static void
nc_log1p(cdouble *x, cdouble *r)
{
    double l = hypot(x->real + 1,x->imag);
    r->imag = atan2(x->imag, x->real + 1);
    r->real = log(l);
    return;
}

static void
nc_exp(cdouble *x, cdouble *r)
{
    double a = exp(x->real);
    r->real = a*cos(x->imag);
    r->imag = a*sin(x->imag);
    return;
}

static void
nc_expm1(cdouble *x, cdouble *r)
{
    double a = exp(x->real);
    r->real = a*cos(x->imag) - 1;
    r->imag = a*sin(x->imag);
    return;
}

static void
nc_pow(cdouble *a, cdouble *b, cdouble *r)
{
    intp n;
    double ar=a->real, br=b->real, ai=a->imag, bi=b->imag;

    if (br == 0. && bi == 0.) {
        r->real = 1.;
        r->imag = 0.;
        return;
    }
    if (ar == 0. && ai == 0.) {
        r->real = 0.;
        r->imag = 0.;
        return;
    }
    if (bi == 0 && (n=(intp)br) == br) {
        if (n > -100 && n < 100) {
            cdouble p, aa;
            intp mask = 1;
            if (n < 0) n = -n;
            aa = nc_1;
            p.real = ar; p.imag = ai;
            while (1) {
                if (n & mask)
                    nc_prod(&aa,&p,&aa);
                mask <<= 1;
                if (n < mask || mask <= 0) break;
                nc_prod(&p,&p,&p);
            }
            r->real = aa.real; r->imag = aa.imag;
            if (br < 0) nc_quot(&nc_1, r, r);
            return;
        }
    }
    /* complexobect.c uses an inline version of this formula
       investigate whether this had better performance or accuracy */
    nc_log(a, r);
    nc_prod(r, b, r);
    nc_exp(r, r);
    return;
}


static void
nc_prodi(cdouble *x, cdouble *r)
{
    double xr = x->real;
    r->real = -x->imag;
    r->imag = xr;
    return;
}


static void
nc_acos(cdouble *x, cdouble *r)
{
    nc_prod(x,x,r);
    nc_diff(&nc_1, r, r);
    nc_sqrt(r, r);
    nc_prodi(r, r);
    nc_sum(x, r, r);
    nc_log(r, r);
    nc_prodi(r, r);
    nc_neg(r, r);
    return;
    /* return nc_neg(nc_prodi(nc_log(nc_sum(x,nc_prod(nc_i,
       nc_sqrt(nc_diff(nc_1,nc_prod(x,x))))))));
    */
}

static void
nc_acosh(cdouble *x, cdouble *r)
{
    cdouble t;

    nc_sum(x, &nc_1, &t);
    nc_sqrt(&t, &t);
    nc_diff(x, &nc_1, r);
    nc_sqrt(r, r);
    nc_prod(&t, r, r);
    nc_sum(x, r, r);
    nc_log(r, r);
    return;
    /*
     * log(x + sqrt(x + 1)*sqrt(x - 1)
     */
}

static void
nc_asin(cdouble *x, cdouble *r)
{
    cdouble a, *pa=&a;
    nc_prod(x, x, r);
    nc_diff(&nc_1, r, r);
    nc_sqrt(r, r);
    nc_prodi(x, pa);
    nc_sum(pa, r, r);
    nc_log(r, r);
    nc_prodi(r, r);
    nc_neg(r, r);
    return;
    /*
      return nc_neg(nc_prodi(nc_log(nc_sum(nc_prod(nc_i,x),
      nc_sqrt(nc_diff(nc_1,nc_prod(x,x)))))));
    */
}


static void
nc_asinh(cdouble *x, cdouble *r)
{
    nc_prod(x, x, r);
    nc_sum(&nc_1, r, r);
    nc_sqrt(r, r);
    nc_sum(r, x, r);
    nc_log(r, r);
    return;
    /*
     * log(x + sqrt(1 + x**2))
     */
}

static void
nc_atan(cdouble *x, cdouble *r)
{
    cdouble a, *pa=&a;
    nc_diff(&nc_i, x, pa);
    nc_sum(&nc_i, x, r);
    nc_quot(r, pa, r);
    nc_log(r,r);
    nc_prod(&nc_i2, r, r);
    return;
    /*
      return nc_prod(nc_i2,nc_log(nc_quot(nc_sum(nc_i,x),nc_diff(nc_i,x))));
    */
}

static void
nc_atanh(cdouble *x, cdouble *r)
{
    cdouble a, *pa=&a;
    nc_diff(&nc_1, x, r);
    nc_sum(&nc_1, x, pa);
    nc_quot(pa, r, r);
    nc_log(r, r);
    nc_prod(&nc_half, r, r);
    return;
    /*
      return nc_prod(nc_half,nc_log(nc_quot(nc_sum(nc_1,x),nc_diff(nc_1,x))));
    */
}

static void
nc_cos(cdouble *x, cdouble *r)
{
    double xr=x->real, xi=x->imag;
    r->real = cos(xr)*cosh(xi);
    r->imag = -sin(xr)*sinh(xi);
    return;
}

static void
nc_cosh(cdouble *x, cdouble *r)
{
    double xr=x->real, xi=x->imag;
    r->real = cos(xi)*cosh(xr);
    r->imag = sin(xi)*sinh(xr);
    return;
}


#define M_LOG10_E 0.434294481903251827651128918916605082294397

static void
nc_log10(cdouble *x, cdouble *r)
{
    nc_log(x, r);
    r->real *= (double) M_LOG10_E;
    r->imag *= (double) M_LOG10_E;
    return;
}

static void
nc_sin(cdouble *x, cdouble *r)
{
    double xr=x->real, xi=x->imag;
    r->real = sin(xr)*cosh(xi);
    r->imag = cos(xr)*sinh(xi);
    return;
}

static void
nc_sinh(cdouble *x, cdouble *r)
{
    double xr=x->real, xi=x->imag;
    r->real = cos(xi)*sinh(xr);
    r->imag = sin(xi)*cosh(xr);
    return;
}

static void
nc_tan(cdouble *x, cdouble *r)
{
    double sr,cr,shi,chi;
    double rs,is,rc,ic;
    double d;
    double xr=x->real, xi=x->imag;
    sr = sin(xr);
    cr = cos(xr);
    shi = sinh(xi);
    chi = cosh(xi);
    rs = sr*chi;
    is = cr*shi;
    rc = cr*chi;
    ic = -sr*shi;
    d = rc*rc + ic*ic;
    r->real = (rs*rc+is*ic)/d;
    r->imag = (is*rc-rs*ic)/d;
    return;
}

static void
nc_tanh(cdouble *x, cdouble *r)
{
    double si,ci,shr,chr;
    double rs,is,rc,ic;
    double d;
    double xr=x->real, xi=x->imag;
    si = sin(xi);
    ci = cos(xi);
    shr = sinh(xr);
    chr = cosh(xr);
    rs = ci*shr;
    is = si*chr;
    rc = ci*chr;
    ic = si*shr;
    d = rc*rc + ic*ic;
    r->real = (rs*rc+is*ic)/d;
    r->imag = (is*rc-rs*ic)/d;
    return;
}


#line 628

/* constants */
static clongdouble nc_1l = {1., 0.};
static clongdouble nc_halfl = {0.5, 0.};
static clongdouble nc_il = {0., 1.};
static clongdouble nc_i2l = {0., 0.5};
/*
  static clongdouble nc_mil = {0., -1.};
  static clongdouble nc_pi2l = {M_PI/2., 0.};
*/

static void
nc_suml(clongdouble *a, clongdouble *b, clongdouble *r)
{
    r->real = a->real + b->real;
    r->imag = a->imag + b->imag;
    return;
}

static void
nc_diffl(clongdouble *a, clongdouble *b, clongdouble *r)
{
    r->real = a->real - b->real;
    r->imag = a->imag - b->imag;
    return;
}

static void
nc_negl(clongdouble *a, clongdouble *r)
{
    r->real = -a->real;
    r->imag = -a->imag;
    return;
}

static void
nc_prodl(clongdouble *a, clongdouble *b, clongdouble *r)
{
    register longdouble ar=a->real, br=b->real, ai=a->imag, bi=b->imag;
    r->real = ar*br - ai*bi;
    r->imag = ar*bi + ai*br;
    return;
}

static void
nc_quotl(clongdouble *a, clongdouble *b, clongdouble *r)
{

    register longdouble ar=a->real, br=b->real, ai=a->imag, bi=b->imag;
    register longdouble d = br*br + bi*bi;
    r->real = (ar*br + ai*bi)/d;
    r->imag = (ai*br - ar*bi)/d;
    return;
}

static void
nc_sqrtl(clongdouble *x, clongdouble *r)
{
    longdouble s,d;
    if (x->real == 0. && x->imag == 0.)
        *r = *x;
    else {
        s = sqrtl((fabsl(x->real) + hypotl(x->real,x->imag))/2);
        d = x->imag/(2*s);
        if (x->real > 0) {
            r->real = s;
            r->imag = d;
        }
        else if (x->imag >= 0) {
            r->real = d;
            r->imag = s;
        }
        else {
            r->real = -d;
            r->imag = -s;
        }
    }
    return;
}

static void
nc_rintl(clongdouble *x, clongdouble *r)
{
    r->real = rintl(x->real);
    r->imag = rintl(x->imag);
}

static void
nc_logl(clongdouble *x, clongdouble *r)
{
    longdouble l = hypotl(x->real,x->imag);
    r->imag = atan2l(x->imag, x->real);
    r->real = logl(l);
    return;
}

static void
nc_log1pl(clongdouble *x, clongdouble *r)
{
    longdouble l = hypotl(x->real + 1,x->imag);
    r->imag = atan2l(x->imag, x->real + 1);
    r->real = logl(l);
    return;
}

static void
nc_expl(clongdouble *x, clongdouble *r)
{
    longdouble a = expl(x->real);
    r->real = a*cosl(x->imag);
    r->imag = a*sinl(x->imag);
    return;
}

static void
nc_expm1l(clongdouble *x, clongdouble *r)
{
    longdouble a = expl(x->real);
    r->real = a*cosl(x->imag) - 1;
    r->imag = a*sinl(x->imag);
    return;
}

static void
nc_powl(clongdouble *a, clongdouble *b, clongdouble *r)
{
    intp n;
    longdouble ar=a->real, br=b->real, ai=a->imag, bi=b->imag;

    if (br == 0. && bi == 0.) {
        r->real = 1.;
        r->imag = 0.;
        return;
    }
    if (ar == 0. && ai == 0.) {
        r->real = 0.;
        r->imag = 0.;
        return;
    }
    if (bi == 0 && (n=(intp)br) == br) {
        if (n > -100 && n < 100) {
            clongdouble p, aa;
            intp mask = 1;
            if (n < 0) n = -n;
            aa = nc_1l;
            p.real = ar; p.imag = ai;
            while (1) {
                if (n & mask)
                    nc_prodl(&aa,&p,&aa);
                mask <<= 1;
                if (n < mask || mask <= 0) break;
                nc_prodl(&p,&p,&p);
            }
            r->real = aa.real; r->imag = aa.imag;
            if (br < 0) nc_quotl(&nc_1l, r, r);
            return;
        }
    }
    /* complexobect.c uses an inline version of this formula
       investigate whether this had better performance or accuracy */
    nc_logl(a, r);
    nc_prodl(r, b, r);
    nc_expl(r, r);
    return;
}


static void
nc_prodil(clongdouble *x, clongdouble *r)
{
    longdouble xr = x->real;
    r->real = -x->imag;
    r->imag = xr;
    return;
}


static void
nc_acosl(clongdouble *x, clongdouble *r)
{
    nc_prodl(x,x,r);
    nc_diffl(&nc_1l, r, r);
    nc_sqrtl(r, r);
    nc_prodil(r, r);
    nc_suml(x, r, r);
    nc_logl(r, r);
    nc_prodil(r, r);
    nc_negl(r, r);
    return;
    /* return nc_neg(nc_prodi(nc_log(nc_sum(x,nc_prod(nc_i,
       nc_sqrt(nc_diff(nc_1,nc_prod(x,x))))))));
    */
}

static void
nc_acoshl(clongdouble *x, clongdouble *r)
{
    clongdouble t;

    nc_suml(x, &nc_1l, &t);
    nc_sqrtl(&t, &t);
    nc_diffl(x, &nc_1l, r);
    nc_sqrtl(r, r);
    nc_prodl(&t, r, r);
    nc_suml(x, r, r);
    nc_logl(r, r);
    return;
    /*
     * log(x + sqrt(x + 1)*sqrt(x - 1)
     */
}

static void
nc_asinl(clongdouble *x, clongdouble *r)
{
    clongdouble a, *pa=&a;
    nc_prodl(x, x, r);
    nc_diffl(&nc_1l, r, r);
    nc_sqrtl(r, r);
    nc_prodil(x, pa);
    nc_suml(pa, r, r);
    nc_logl(r, r);
    nc_prodil(r, r);
    nc_negl(r, r);
    return;
    /*
      return nc_neg(nc_prodi(nc_log(nc_sum(nc_prod(nc_i,x),
      nc_sqrt(nc_diff(nc_1,nc_prod(x,x)))))));
    */
}


static void
nc_asinhl(clongdouble *x, clongdouble *r)
{
    nc_prodl(x, x, r);
    nc_suml(&nc_1l, r, r);
    nc_sqrtl(r, r);
    nc_suml(r, x, r);
    nc_logl(r, r);
    return;
    /*
     * log(x + sqrt(1 + x**2))
     */
}

static void
nc_atanl(clongdouble *x, clongdouble *r)
{
    clongdouble a, *pa=&a;
    nc_diffl(&nc_il, x, pa);
    nc_suml(&nc_il, x, r);
    nc_quotl(r, pa, r);
    nc_logl(r,r);
    nc_prodl(&nc_i2l, r, r);
    return;
    /*
      return nc_prod(nc_i2,nc_log(nc_quot(nc_sum(nc_i,x),nc_diff(nc_i,x))));
    */
}

static void
nc_atanhl(clongdouble *x, clongdouble *r)
{
    clongdouble a, *pa=&a;
    nc_diffl(&nc_1l, x, r);
    nc_suml(&nc_1l, x, pa);
    nc_quotl(pa, r, r);
    nc_logl(r, r);
    nc_prodl(&nc_halfl, r, r);
    return;
    /*
      return nc_prod(nc_half,nc_log(nc_quot(nc_sum(nc_1,x),nc_diff(nc_1,x))));
    */
}

static void
nc_cosl(clongdouble *x, clongdouble *r)
{
    longdouble xr=x->real, xi=x->imag;
    r->real = cosl(xr)*coshl(xi);
    r->imag = -sinl(xr)*sinhl(xi);
    return;
}

static void
nc_coshl(clongdouble *x, clongdouble *r)
{
    longdouble xr=x->real, xi=x->imag;
    r->real = cosl(xi)*coshl(xr);
    r->imag = sinl(xi)*sinhl(xr);
    return;
}


#define M_LOG10_E 0.434294481903251827651128918916605082294397

static void
nc_log10l(clongdouble *x, clongdouble *r)
{
    nc_logl(x, r);
    r->real *= (longdouble) M_LOG10_E;
    r->imag *= (longdouble) M_LOG10_E;
    return;
}

static void
nc_sinl(clongdouble *x, clongdouble *r)
{
    longdouble xr=x->real, xi=x->imag;
    r->real = sinl(xr)*coshl(xi);
    r->imag = cosl(xr)*sinhl(xi);
    return;
}

static void
nc_sinhl(clongdouble *x, clongdouble *r)
{
    longdouble xr=x->real, xi=x->imag;
    r->real = cosl(xi)*sinhl(xr);
    r->imag = sinl(xi)*coshl(xr);
    return;
}

static void
nc_tanl(clongdouble *x, clongdouble *r)
{
    longdouble sr,cr,shi,chi;
    longdouble rs,is,rc,ic;
    longdouble d;
    longdouble xr=x->real, xi=x->imag;
    sr = sinl(xr);
    cr = cosl(xr);
    shi = sinhl(xi);
    chi = coshl(xi);
    rs = sr*chi;
    is = cr*shi;
    rc = cr*chi;
    ic = -sr*shi;
    d = rc*rc + ic*ic;
    r->real = (rs*rc+is*ic)/d;
    r->imag = (is*rc-rs*ic)/d;
    return;
}

static void
nc_tanhl(clongdouble *x, clongdouble *r)
{
    longdouble si,ci,shr,chr;
    longdouble rs,is,rc,ic;
    longdouble d;
    longdouble xr=x->real, xi=x->imag;
    si = sinl(xi);
    ci = cosl(xi);
    shr = sinhl(xr);
    chr = coshl(xr);
    rs = ci*shr;
    is = si*chr;
    rc = ci*chr;
    ic = si*shr;
    d = rc*rc + ic*ic;
    r->real = (rs*rc+is*ic)/d;
    r->imag = (is*rc-rs*ic)/d;
    return;
}



/*
 *****************************************************************************
 **                             UFUNC LOOPS                                 **
 *****************************************************************************
 */


#line 1010

static void
BOOL_add(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((Bool *)i1) || *((Bool *)i2);
    }
}


#line 1010

static void
BYTE_add(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((byte *)op)=*((byte *)i1) + *((byte *)i2);
    }
}


#line 1010

static void
UBYTE_add(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((ubyte *)op)=*((ubyte *)i1) + *((ubyte *)i2);
    }
}


#line 1010

static void
SHORT_add(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((short *)op)=*((short *)i1) + *((short *)i2);
    }
}


#line 1010

static void
USHORT_add(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((ushort *)op)=*((ushort *)i1) + *((ushort *)i2);
    }
}


#line 1010

static void
INT_add(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((int *)op)=*((int *)i1) + *((int *)i2);
    }
}


#line 1010

static void
UINT_add(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((uint *)op)=*((uint *)i1) + *((uint *)i2);
    }
}


#line 1010

static void
LONG_add(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((long *)op)=*((long *)i1) + *((long *)i2);
    }
}


#line 1010

static void
ULONG_add(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((ulong *)op)=*((ulong *)i1) + *((ulong *)i2);
    }
}


#line 1010

static void
LONGLONG_add(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((longlong *)op)=*((longlong *)i1) + *((longlong *)i2);
    }
}


#line 1010

static void
ULONGLONG_add(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((ulonglong *)op)=*((ulonglong *)i1) + *((ulonglong *)i2);
    }
}


#line 1010

static void
FLOAT_add(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((float *)op)=*((float *)i1) + *((float *)i2);
    }
}


#line 1010

static void
DOUBLE_add(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((double *)op)=*((double *)i1) + *((double *)i2);
    }
}


#line 1010

static void
LONGDOUBLE_add(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((longdouble *)op)=*((longdouble *)i1) + *((longdouble *)i2);
    }
}


#line 1010

static void
BOOL_subtract(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((Bool *)i1) ^ *((Bool *)i2);
    }
}


#line 1010

static void
BYTE_subtract(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((byte *)op)=*((byte *)i1) - *((byte *)i2);
    }
}


#line 1010

static void
UBYTE_subtract(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((ubyte *)op)=*((ubyte *)i1) - *((ubyte *)i2);
    }
}


#line 1010

static void
SHORT_subtract(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((short *)op)=*((short *)i1) - *((short *)i2);
    }
}


#line 1010

static void
USHORT_subtract(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((ushort *)op)=*((ushort *)i1) - *((ushort *)i2);
    }
}


#line 1010

static void
INT_subtract(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((int *)op)=*((int *)i1) - *((int *)i2);
    }
}


#line 1010

static void
UINT_subtract(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((uint *)op)=*((uint *)i1) - *((uint *)i2);
    }
}


#line 1010

static void
LONG_subtract(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((long *)op)=*((long *)i1) - *((long *)i2);
    }
}


#line 1010

static void
ULONG_subtract(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((ulong *)op)=*((ulong *)i1) - *((ulong *)i2);
    }
}


#line 1010

static void
LONGLONG_subtract(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((longlong *)op)=*((longlong *)i1) - *((longlong *)i2);
    }
}


#line 1010

static void
ULONGLONG_subtract(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((ulonglong *)op)=*((ulonglong *)i1) - *((ulonglong *)i2);
    }
}


#line 1010

static void
FLOAT_subtract(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((float *)op)=*((float *)i1) - *((float *)i2);
    }
}


#line 1010

static void
DOUBLE_subtract(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((double *)op)=*((double *)i1) - *((double *)i2);
    }
}


#line 1010

static void
LONGDOUBLE_subtract(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((longdouble *)op)=*((longdouble *)i1) - *((longdouble *)i2);
    }
}



#line 1031

static void
CFLOAT_add(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        ((float *)op)[0]=((float *)i1)[0] + ((float *)i2)[0];
        ((float *)op)[1]=((float *)i1)[1] + ((float *)i2)[1];
    }
}


#line 1031

static void
CDOUBLE_add(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        ((double *)op)[0]=((double *)i1)[0] + ((double *)i2)[0];
        ((double *)op)[1]=((double *)i1)[1] + ((double *)i2)[1];
    }
}


#line 1031

static void
CLONGDOUBLE_add(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        ((longdouble *)op)[0]=((longdouble *)i1)[0] + ((longdouble *)i2)[0];
        ((longdouble *)op)[1]=((longdouble *)i1)[1] + ((longdouble *)i2)[1];
    }
}


#line 1031

static void
CFLOAT_subtract(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        ((float *)op)[0]=((float *)i1)[0] - ((float *)i2)[0];
        ((float *)op)[1]=((float *)i1)[1] - ((float *)i2)[1];
    }
}


#line 1031

static void
CDOUBLE_subtract(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        ((double *)op)[0]=((double *)i1)[0] - ((double *)i2)[0];
        ((double *)op)[1]=((double *)i1)[1] - ((double *)i2)[1];
    }
}


#line 1031

static void
CLONGDOUBLE_subtract(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        ((longdouble *)op)[0]=((longdouble *)i1)[0] - ((longdouble *)i2)[0];
        ((longdouble *)op)[1]=((longdouble *)i1)[1] - ((longdouble *)i2)[1];
    }
}




static void
BOOL_multiply(char **args, intp *dimensions, intp *steps, void *func) {
    register intp i;
    intp is1=steps[0], is2=steps[1], os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for (i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = *((Bool *)i1) && *((Bool *)i2);
    }
}

#line 1062
static void
BYTE_multiply(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0], is2=steps[1], os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for (i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((byte *)op) = (*((byte *)i1)) * (*((byte *)i2));
    }
}

#line 1062
static void
SHORT_multiply(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0], is2=steps[1], os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for (i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((short *)op) = (*((short *)i1)) * (*((short *)i2));
    }
}

#line 1062
static void
INT_multiply(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0], is2=steps[1], os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for (i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((int *)op) = (*((int *)i1)) * (*((int *)i2));
    }
}

#line 1062
static void
LONG_multiply(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0], is2=steps[1], os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for (i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((long *)op) = (*((long *)i1)) * (*((long *)i2));
    }
}

#line 1062
static void
LONGLONG_multiply(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0], is2=steps[1], os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for (i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((longlong *)op) = (*((longlong *)i1)) * (*((longlong *)i2));
    }
}

#line 1062
static void
UBYTE_multiply(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0], is2=steps[1], os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for (i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((ubyte *)op) = (*((ubyte *)i1)) * (*((ubyte *)i2));
    }
}

#line 1062
static void
USHORT_multiply(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0], is2=steps[1], os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for (i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((ushort *)op) = (*((ushort *)i1)) * (*((ushort *)i2));
    }
}

#line 1062
static void
UINT_multiply(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0], is2=steps[1], os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for (i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((uint *)op) = (*((uint *)i1)) * (*((uint *)i2));
    }
}

#line 1062
static void
ULONG_multiply(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0], is2=steps[1], os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for (i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((ulong *)op) = (*((ulong *)i1)) * (*((ulong *)i2));
    }
}

#line 1062
static void
ULONGLONG_multiply(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0], is2=steps[1], os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for (i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((ulonglong *)op) = (*((ulonglong *)i1)) * (*((ulonglong *)i2));
    }
}

#line 1062
static void
FLOAT_multiply(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0], is2=steps[1], os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for (i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((float *)op) = (*((float *)i1)) * (*((float *)i2));
    }
}

#line 1062
static void
DOUBLE_multiply(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0], is2=steps[1], os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for (i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((double *)op) = (*((double *)i1)) * (*((double *)i2));
    }
}

#line 1062
static void
LONGDOUBLE_multiply(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0], is2=steps[1], os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for (i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((longdouble *)op) = (*((longdouble *)i1)) * (*((longdouble *)i2));
    }
}



#line 1080
static void
CFLOAT_multiply(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0], is2=steps[1], os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for (i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        register float ar=((cfloat *)i1)->real, \
            ai=((cfloat *)i1)->imag,        \
            br=((cfloat *)i2)->real,        \
            bi=((cfloat *)i2)->imag;
        ((cfloat *)op)->real = ar*br - ai*bi;
        ((cfloat *)op)->imag = ar*bi + ai*br;
    }
}

static void
CFLOAT_divide(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0], is2=steps[1], os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for (i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        register float ar=((cfloat *)i1)->real, \
            ai=((cfloat *)i1)->imag,        \
            br=((cfloat *)i2)->real,        \
            bi=((cfloat *)i2)->imag;
        register float d = br*br + bi*bi;
        ((cfloat *)op)->real = (ar*br + ai*bi)/d;
        ((cfloat *)op)->imag = (ai*br - ar*bi)/d;
    }
}

static void
CFLOAT_floor_divide(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2],n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        register float ar=((cfloat *)i1)->real,    \
            ai=((cfloat *)i1)->imag,           \
            br=((cfloat *)i2)->real,           \
            bi=((cfloat *)i2)->imag;
        register float d = br*br + bi*bi;
        ((cfloat *)op)->real = floorf((ar*br + ai*bi)/d);
        ((cfloat *)op)->imag = 0;
    }
}

#define CFLOAT_true_divide CFLOAT_divide

#line 1080
static void
CDOUBLE_multiply(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0], is2=steps[1], os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for (i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        register double ar=((cdouble *)i1)->real, \
            ai=((cdouble *)i1)->imag,        \
            br=((cdouble *)i2)->real,        \
            bi=((cdouble *)i2)->imag;
        ((cdouble *)op)->real = ar*br - ai*bi;
        ((cdouble *)op)->imag = ar*bi + ai*br;
    }
}

static void
CDOUBLE_divide(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0], is2=steps[1], os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for (i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        register double ar=((cdouble *)i1)->real, \
            ai=((cdouble *)i1)->imag,        \
            br=((cdouble *)i2)->real,        \
            bi=((cdouble *)i2)->imag;
        register double d = br*br + bi*bi;
        ((cdouble *)op)->real = (ar*br + ai*bi)/d;
        ((cdouble *)op)->imag = (ai*br - ar*bi)/d;
    }
}

static void
CDOUBLE_floor_divide(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2],n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        register double ar=((cdouble *)i1)->real,    \
            ai=((cdouble *)i1)->imag,           \
            br=((cdouble *)i2)->real,           \
            bi=((cdouble *)i2)->imag;
        register double d = br*br + bi*bi;
        ((cdouble *)op)->real = floor((ar*br + ai*bi)/d);
        ((cdouble *)op)->imag = 0;
    }
}

#define CDOUBLE_true_divide CDOUBLE_divide

#line 1080
static void
CLONGDOUBLE_multiply(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0], is2=steps[1], os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for (i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        register longdouble ar=((clongdouble *)i1)->real, \
            ai=((clongdouble *)i1)->imag,        \
            br=((clongdouble *)i2)->real,        \
            bi=((clongdouble *)i2)->imag;
        ((clongdouble *)op)->real = ar*br - ai*bi;
        ((clongdouble *)op)->imag = ar*bi + ai*br;
    }
}

static void
CLONGDOUBLE_divide(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0], is2=steps[1], os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for (i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        register longdouble ar=((clongdouble *)i1)->real, \
            ai=((clongdouble *)i1)->imag,        \
            br=((clongdouble *)i2)->real,        \
            bi=((clongdouble *)i2)->imag;
        register longdouble d = br*br + bi*bi;
        ((clongdouble *)op)->real = (ar*br + ai*bi)/d;
        ((clongdouble *)op)->imag = (ai*br - ar*bi)/d;
    }
}

static void
CLONGDOUBLE_floor_divide(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2],n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        register longdouble ar=((clongdouble *)i1)->real,    \
            ai=((clongdouble *)i1)->imag,           \
            br=((clongdouble *)i2)->real,           \
            bi=((clongdouble *)i2)->imag;
        register longdouble d = br*br + bi*bi;
        ((clongdouble *)op)->real = floorl((ar*br + ai*bi)/d);
        ((clongdouble *)op)->imag = 0;
    }
}

#define CLONGDOUBLE_true_divide CLONGDOUBLE_divide



#line 1138
static void
UBYTE_divide(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, is1=steps[0],is2=steps[1],os=steps[2],n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        if (*((ubyte *)i2)==0) {
            generate_divbyzero_error();
            *((ubyte *)op)=0;
        }
        else {
            *((ubyte *)op)= *((ubyte *)i1) / *((ubyte *)i2);
        }
    }
}

#line 1138
static void
USHORT_divide(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, is1=steps[0],is2=steps[1],os=steps[2],n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        if (*((ushort *)i2)==0) {
            generate_divbyzero_error();
            *((ushort *)op)=0;
        }
        else {
            *((ushort *)op)= *((ushort *)i1) / *((ushort *)i2);
        }
    }
}

#line 1138
static void
UINT_divide(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, is1=steps[0],is2=steps[1],os=steps[2],n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        if (*((uint *)i2)==0) {
            generate_divbyzero_error();
            *((uint *)op)=0;
        }
        else {
            *((uint *)op)= *((uint *)i1) / *((uint *)i2);
        }
    }
}

#line 1138
static void
ULONG_divide(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, is1=steps[0],is2=steps[1],os=steps[2],n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        if (*((ulong *)i2)==0) {
            generate_divbyzero_error();
            *((ulong *)op)=0;
        }
        else {
            *((ulong *)op)= *((ulong *)i1) / *((ulong *)i2);
        }
    }
}

#line 1138
static void
ULONGLONG_divide(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, is1=steps[0],is2=steps[1],os=steps[2],n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        if (*((ulonglong *)i2)==0) {
            generate_divbyzero_error();
            *((ulonglong *)op)=0;
        }
        else {
            *((ulonglong *)op)= *((ulonglong *)i1) / *((ulonglong *)i2);
        }
    }
}



#line 1160
static void
BYTE_divide(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, is1=steps[0],is2=steps[1],os=steps[2],n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    char x, y, tmp;
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        y = *((char *)i2);
        if (y == 0) {
            generate_divbyzero_error();
            *((char *)op)=0;
        }
        else {
            x = *((char *)i1);
            tmp = x / y;
            if (((x > 0) != (y > 0)) && (x % y != 0)) tmp--;
            *((char *)op)= tmp;
        }
    }
}

#line 1160
static void
SHORT_divide(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, is1=steps[0],is2=steps[1],os=steps[2],n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    short x, y, tmp;
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        y = *((short *)i2);
        if (y == 0) {
            generate_divbyzero_error();
            *((short *)op)=0;
        }
        else {
            x = *((short *)i1);
            tmp = x / y;
            if (((x > 0) != (y > 0)) && (x % y != 0)) tmp--;
            *((short *)op)= tmp;
        }
    }
}

#line 1160
static void
INT_divide(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, is1=steps[0],is2=steps[1],os=steps[2],n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    int x, y, tmp;
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        y = *((int *)i2);
        if (y == 0) {
            generate_divbyzero_error();
            *((int *)op)=0;
        }
        else {
            x = *((int *)i1);
            tmp = x / y;
            if (((x > 0) != (y > 0)) && (x % y != 0)) tmp--;
            *((int *)op)= tmp;
        }
    }
}

#line 1160
static void
LONG_divide(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, is1=steps[0],is2=steps[1],os=steps[2],n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    long x, y, tmp;
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        y = *((long *)i2);
        if (y == 0) {
            generate_divbyzero_error();
            *((long *)op)=0;
        }
        else {
            x = *((long *)i1);
            tmp = x / y;
            if (((x > 0) != (y > 0)) && (x % y != 0)) tmp--;
            *((long *)op)= tmp;
        }
    }
}

#line 1160
static void
LONGLONG_divide(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, is1=steps[0],is2=steps[1],os=steps[2],n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    longlong x, y, tmp;
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        y = *((longlong *)i2);
        if (y == 0) {
            generate_divbyzero_error();
            *((longlong *)op)=0;
        }
        else {
            x = *((longlong *)i1);
            tmp = x / y;
            if (((x > 0) != (y > 0)) && (x % y != 0)) tmp--;
            *((longlong *)op)= tmp;
        }
    }
}



#line 1188
static void
BYTE_true_divide(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, is1=steps[0],is2=steps[1],os=steps[2],n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        if (*((char *)i2)==0) {
            generate_divbyzero_error();
            *((float *)op)=0;
        }
        else {
            *((float *)op)=                                \
                (float)((double)*((char *)i1) / (double)*((char *)i2));
        }
    }
}
#define BYTE_floor_divide BYTE_divide

#line 1188
static void
UBYTE_true_divide(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, is1=steps[0],is2=steps[1],os=steps[2],n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        if (*((ubyte *)i2)==0) {
            generate_divbyzero_error();
            *((float *)op)=0;
        }
        else {
            *((float *)op)=                                \
                (float)((double)*((ubyte *)i1) / (double)*((ubyte *)i2));
        }
    }
}
#define UBYTE_floor_divide UBYTE_divide

#line 1188
static void
SHORT_true_divide(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, is1=steps[0],is2=steps[1],os=steps[2],n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        if (*((short *)i2)==0) {
            generate_divbyzero_error();
            *((float *)op)=0;
        }
        else {
            *((float *)op)=                                \
                (float)((double)*((short *)i1) / (double)*((short *)i2));
        }
    }
}
#define SHORT_floor_divide SHORT_divide

#line 1188
static void
USHORT_true_divide(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, is1=steps[0],is2=steps[1],os=steps[2],n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        if (*((ushort *)i2)==0) {
            generate_divbyzero_error();
            *((float *)op)=0;
        }
        else {
            *((float *)op)=                                \
                (float)((double)*((ushort *)i1) / (double)*((ushort *)i2));
        }
    }
}
#define USHORT_floor_divide USHORT_divide

#line 1188
static void
INT_true_divide(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, is1=steps[0],is2=steps[1],os=steps[2],n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        if (*((int *)i2)==0) {
            generate_divbyzero_error();
            *((double *)op)=0;
        }
        else {
            *((double *)op)=                                \
                (double)((double)*((int *)i1) / (double)*((int *)i2));
        }
    }
}
#define INT_floor_divide INT_divide

#line 1188
static void
UINT_true_divide(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, is1=steps[0],is2=steps[1],os=steps[2],n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        if (*((uint *)i2)==0) {
            generate_divbyzero_error();
            *((double *)op)=0;
        }
        else {
            *((double *)op)=                                \
                (double)((double)*((uint *)i1) / (double)*((uint *)i2));
        }
    }
}
#define UINT_floor_divide UINT_divide

#line 1188
static void
LONG_true_divide(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, is1=steps[0],is2=steps[1],os=steps[2],n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        if (*((long *)i2)==0) {
            generate_divbyzero_error();
            *((double *)op)=0;
        }
        else {
            *((double *)op)=                                \
                (double)((double)*((long *)i1) / (double)*((long *)i2));
        }
    }
}
#define LONG_floor_divide LONG_divide

#line 1188
static void
ULONG_true_divide(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, is1=steps[0],is2=steps[1],os=steps[2],n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        if (*((ulong *)i2)==0) {
            generate_divbyzero_error();
            *((double *)op)=0;
        }
        else {
            *((double *)op)=                                \
                (double)((double)*((ulong *)i1) / (double)*((ulong *)i2));
        }
    }
}
#define ULONG_floor_divide ULONG_divide

#line 1188
static void
LONGLONG_true_divide(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, is1=steps[0],is2=steps[1],os=steps[2],n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        if (*((longlong *)i2)==0) {
            generate_divbyzero_error();
            *((double *)op)=0;
        }
        else {
            *((double *)op)=                                \
                (double)((double)*((longlong *)i1) / (double)*((longlong *)i2));
        }
    }
}
#define LONGLONG_floor_divide LONGLONG_divide

#line 1188
static void
ULONGLONG_true_divide(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, is1=steps[0],is2=steps[1],os=steps[2],n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        if (*((ulonglong *)i2)==0) {
            generate_divbyzero_error();
            *((double *)op)=0;
        }
        else {
            *((double *)op)=                                \
                (double)((double)*((ulonglong *)i1) / (double)*((ulonglong *)i2));
        }
    }
}
#define ULONGLONG_floor_divide ULONGLONG_divide




#line 1213
static void
FLOAT_divide(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, is1=steps[0],is2=steps[1],os=steps[2],n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((float *)op)=*((float *)i1) / *((float *)i2);
    }
}
#define FLOAT_true_divide FLOAT_divide

#line 1213
static void
DOUBLE_divide(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, is1=steps[0],is2=steps[1],os=steps[2],n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((double *)op)=*((double *)i1) / *((double *)i2);
    }
}
#define DOUBLE_true_divide DOUBLE_divide

#line 1213
static void
LONGDOUBLE_divide(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, is1=steps[0],is2=steps[1],os=steps[2],n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((longdouble *)op)=*((longdouble *)i1) / *((longdouble *)i2);
    }
}
#define LONGDOUBLE_true_divide LONGDOUBLE_divide


#line 1231
static void
FLOAT_floor_divide(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, is1=steps[0],is2=steps[1],os=steps[2],n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((float *)op)=floorf(*((float *)i1) / *((float *)i2));
    }
}

#line 1231
static void
DOUBLE_floor_divide(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, is1=steps[0],is2=steps[1],os=steps[2],n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((double *)op)=floor(*((double *)i1) / *((double *)i2));
    }
}

#line 1231
static void
LONGDOUBLE_floor_divide(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, is1=steps[0],is2=steps[1],os=steps[2],n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((longdouble *)op)=floorl(*((longdouble *)i1) / *((longdouble *)i2));
    }
}


#line 1246
static void
BYTE_square(char **args, intp *dimensions, intp *steps, void *data)
{
    intp i, is1 = steps[0], os = steps[1], n = dimensions[0];
    char *i1 = args[0], *op = args[1];

    for (i = 0; i < n; i++, i1 += is1, op += os) {
        char x = *((char *)i1);
        *((char *)op) = x*x;
    }
}

#line 1246
static void
UBYTE_square(char **args, intp *dimensions, intp *steps, void *data)
{
    intp i, is1 = steps[0], os = steps[1], n = dimensions[0];
    char *i1 = args[0], *op = args[1];

    for (i = 0; i < n; i++, i1 += is1, op += os) {
        ubyte x = *((ubyte *)i1);
        *((ubyte *)op) = x*x;
    }
}

#line 1246
static void
SHORT_square(char **args, intp *dimensions, intp *steps, void *data)
{
    intp i, is1 = steps[0], os = steps[1], n = dimensions[0];
    char *i1 = args[0], *op = args[1];

    for (i = 0; i < n; i++, i1 += is1, op += os) {
        short x = *((short *)i1);
        *((short *)op) = x*x;
    }
}

#line 1246
static void
USHORT_square(char **args, intp *dimensions, intp *steps, void *data)
{
    intp i, is1 = steps[0], os = steps[1], n = dimensions[0];
    char *i1 = args[0], *op = args[1];

    for (i = 0; i < n; i++, i1 += is1, op += os) {
        ushort x = *((ushort *)i1);
        *((ushort *)op) = x*x;
    }
}

#line 1246
static void
INT_square(char **args, intp *dimensions, intp *steps, void *data)
{
    intp i, is1 = steps[0], os = steps[1], n = dimensions[0];
    char *i1 = args[0], *op = args[1];

    for (i = 0; i < n; i++, i1 += is1, op += os) {
        int x = *((int *)i1);
        *((int *)op) = x*x;
    }
}

#line 1246
static void
UINT_square(char **args, intp *dimensions, intp *steps, void *data)
{
    intp i, is1 = steps[0], os = steps[1], n = dimensions[0];
    char *i1 = args[0], *op = args[1];

    for (i = 0; i < n; i++, i1 += is1, op += os) {
        uint x = *((uint *)i1);
        *((uint *)op) = x*x;
    }
}

#line 1246
static void
LONG_square(char **args, intp *dimensions, intp *steps, void *data)
{
    intp i, is1 = steps[0], os = steps[1], n = dimensions[0];
    char *i1 = args[0], *op = args[1];

    for (i = 0; i < n; i++, i1 += is1, op += os) {
        long x = *((long *)i1);
        *((long *)op) = x*x;
    }
}

#line 1246
static void
ULONG_square(char **args, intp *dimensions, intp *steps, void *data)
{
    intp i, is1 = steps[0], os = steps[1], n = dimensions[0];
    char *i1 = args[0], *op = args[1];

    for (i = 0; i < n; i++, i1 += is1, op += os) {
        ulong x = *((ulong *)i1);
        *((ulong *)op) = x*x;
    }
}

#line 1246
static void
LONGLONG_square(char **args, intp *dimensions, intp *steps, void *data)
{
    intp i, is1 = steps[0], os = steps[1], n = dimensions[0];
    char *i1 = args[0], *op = args[1];

    for (i = 0; i < n; i++, i1 += is1, op += os) {
        longlong x = *((longlong *)i1);
        *((longlong *)op) = x*x;
    }
}

#line 1246
static void
ULONGLONG_square(char **args, intp *dimensions, intp *steps, void *data)
{
    intp i, is1 = steps[0], os = steps[1], n = dimensions[0];
    char *i1 = args[0], *op = args[1];

    for (i = 0; i < n; i++, i1 += is1, op += os) {
        ulonglong x = *((ulonglong *)i1);
        *((ulonglong *)op) = x*x;
    }
}

#line 1246
static void
FLOAT_square(char **args, intp *dimensions, intp *steps, void *data)
{
    intp i, is1 = steps[0], os = steps[1], n = dimensions[0];
    char *i1 = args[0], *op = args[1];

    for (i = 0; i < n; i++, i1 += is1, op += os) {
        float x = *((float *)i1);
        *((float *)op) = x*x;
    }
}

#line 1246
static void
DOUBLE_square(char **args, intp *dimensions, intp *steps, void *data)
{
    intp i, is1 = steps[0], os = steps[1], n = dimensions[0];
    char *i1 = args[0], *op = args[1];

    for (i = 0; i < n; i++, i1 += is1, op += os) {
        double x = *((double *)i1);
        *((double *)op) = x*x;
    }
}

#line 1246
static void
LONGDOUBLE_square(char **args, intp *dimensions, intp *steps, void *data)
{
    intp i, is1 = steps[0], os = steps[1], n = dimensions[0];
    char *i1 = args[0], *op = args[1];

    for (i = 0; i < n; i++, i1 += is1, op += os) {
        longdouble x = *((longdouble *)i1);
        *((longdouble *)op) = x*x;
    }
}


#line 1263
static void
CFLOAT_square(char **args, intp *dimensions, intp *steps, void *data)
{
    intp i, is1 = steps[0], os = steps[1], n = dimensions[0];
    char *i1 = args[0], *op = args[1];
    cfloat *x, *y;
    float xr, xi;

    for (i = 0; i < n; i++, i1 += is1, op += os) {
        x = (cfloat *)i1;
        y = (cfloat *)op;
        xr = x->real;
        xi = x->imag;
        y->real = xr*xr - xi*xi;
        y->imag = 2*xr*xi;
    }
}

#line 1263
static void
CDOUBLE_square(char **args, intp *dimensions, intp *steps, void *data)
{
    intp i, is1 = steps[0], os = steps[1], n = dimensions[0];
    char *i1 = args[0], *op = args[1];
    cdouble *x, *y;
    double xr, xi;

    for (i = 0; i < n; i++, i1 += is1, op += os) {
        x = (cdouble *)i1;
        y = (cdouble *)op;
        xr = x->real;
        xi = x->imag;
        y->real = xr*xr - xi*xi;
        y->imag = 2*xr*xi;
    }
}

#line 1263
static void
CLONGDOUBLE_square(char **args, intp *dimensions, intp *steps, void *data)
{
    intp i, is1 = steps[0], os = steps[1], n = dimensions[0];
    char *i1 = args[0], *op = args[1];
    clongdouble *x, *y;
    longdouble xr, xi;

    for (i = 0; i < n; i++, i1 += is1, op += os) {
        x = (clongdouble *)i1;
        y = (clongdouble *)op;
        xr = x->real;
        xi = x->imag;
        y->real = xr*xr - xi*xi;
        y->imag = 2*xr*xi;
    }
}


static PyObject *
Py_square(PyObject *o)
{
    return PyNumber_Multiply(o, o);
}


#line 1293
static void
BYTE_reciprocal(char **args, intp *dimensions, intp *steps, void *data)
{
    intp i, is1 = steps[0], os = steps[1], n = dimensions[0];
    char *i1 = args[0], *op = args[1];

    for (i = 0; i < n; i++, i1 += is1, op += os) {
        char x = *((char *)i1);
        *((char *)op) = (char) (1.0 / x);
    }
}

#line 1293
static void
UBYTE_reciprocal(char **args, intp *dimensions, intp *steps, void *data)
{
    intp i, is1 = steps[0], os = steps[1], n = dimensions[0];
    char *i1 = args[0], *op = args[1];

    for (i = 0; i < n; i++, i1 += is1, op += os) {
        ubyte x = *((ubyte *)i1);
        *((ubyte *)op) = (ubyte) (1.0 / x);
    }
}

#line 1293
static void
SHORT_reciprocal(char **args, intp *dimensions, intp *steps, void *data)
{
    intp i, is1 = steps[0], os = steps[1], n = dimensions[0];
    char *i1 = args[0], *op = args[1];

    for (i = 0; i < n; i++, i1 += is1, op += os) {
        short x = *((short *)i1);
        *((short *)op) = (short) (1.0 / x);
    }
}

#line 1293
static void
USHORT_reciprocal(char **args, intp *dimensions, intp *steps, void *data)
{
    intp i, is1 = steps[0], os = steps[1], n = dimensions[0];
    char *i1 = args[0], *op = args[1];

    for (i = 0; i < n; i++, i1 += is1, op += os) {
        ushort x = *((ushort *)i1);
        *((ushort *)op) = (ushort) (1.0 / x);
    }
}

#line 1293
static void
INT_reciprocal(char **args, intp *dimensions, intp *steps, void *data)
{
    intp i, is1 = steps[0], os = steps[1], n = dimensions[0];
    char *i1 = args[0], *op = args[1];

    for (i = 0; i < n; i++, i1 += is1, op += os) {
        int x = *((int *)i1);
        *((int *)op) = (int) (1.0 / x);
    }
}

#line 1293
static void
UINT_reciprocal(char **args, intp *dimensions, intp *steps, void *data)
{
    intp i, is1 = steps[0], os = steps[1], n = dimensions[0];
    char *i1 = args[0], *op = args[1];

    for (i = 0; i < n; i++, i1 += is1, op += os) {
        uint x = *((uint *)i1);
        *((uint *)op) = (uint) (1.0 / x);
    }
}

#line 1293
static void
LONG_reciprocal(char **args, intp *dimensions, intp *steps, void *data)
{
    intp i, is1 = steps[0], os = steps[1], n = dimensions[0];
    char *i1 = args[0], *op = args[1];

    for (i = 0; i < n; i++, i1 += is1, op += os) {
        long x = *((long *)i1);
        *((long *)op) = (long) (1.0 / x);
    }
}

#line 1293
static void
ULONG_reciprocal(char **args, intp *dimensions, intp *steps, void *data)
{
    intp i, is1 = steps[0], os = steps[1], n = dimensions[0];
    char *i1 = args[0], *op = args[1];

    for (i = 0; i < n; i++, i1 += is1, op += os) {
        ulong x = *((ulong *)i1);
        *((ulong *)op) = (ulong) (1.0 / x);
    }
}

#line 1293
static void
LONGLONG_reciprocal(char **args, intp *dimensions, intp *steps, void *data)
{
    intp i, is1 = steps[0], os = steps[1], n = dimensions[0];
    char *i1 = args[0], *op = args[1];

    for (i = 0; i < n; i++, i1 += is1, op += os) {
        longlong x = *((longlong *)i1);
        *((longlong *)op) = (longlong) (1.0 / x);
    }
}

#line 1293
static void
ULONGLONG_reciprocal(char **args, intp *dimensions, intp *steps, void *data)
{
    intp i, is1 = steps[0], os = steps[1], n = dimensions[0];
    char *i1 = args[0], *op = args[1];

    for (i = 0; i < n; i++, i1 += is1, op += os) {
        ulonglong x = *((ulonglong *)i1);
        *((ulonglong *)op) = (ulonglong) (1.0 / x);
    }
}

#line 1293
static void
FLOAT_reciprocal(char **args, intp *dimensions, intp *steps, void *data)
{
    intp i, is1 = steps[0], os = steps[1], n = dimensions[0];
    char *i1 = args[0], *op = args[1];

    for (i = 0; i < n; i++, i1 += is1, op += os) {
        float x = *((float *)i1);
        *((float *)op) = (float) (1.0 / x);
    }
}

#line 1293
static void
DOUBLE_reciprocal(char **args, intp *dimensions, intp *steps, void *data)
{
    intp i, is1 = steps[0], os = steps[1], n = dimensions[0];
    char *i1 = args[0], *op = args[1];

    for (i = 0; i < n; i++, i1 += is1, op += os) {
        double x = *((double *)i1);
        *((double *)op) = (double) (1.0 / x);
    }
}

#line 1293
static void
LONGDOUBLE_reciprocal(char **args, intp *dimensions, intp *steps, void *data)
{
    intp i, is1 = steps[0], os = steps[1], n = dimensions[0];
    char *i1 = args[0], *op = args[1];

    for (i = 0; i < n; i++, i1 += is1, op += os) {
        longdouble x = *((longdouble *)i1);
        *((longdouble *)op) = (longdouble) (1.0 / x);
    }
}


#line 1310
static void
CFLOAT_reciprocal(char **args, intp *dimensions, intp *steps, void *data)
{
    intp i, is1 = steps[0], os = steps[1], n = dimensions[0];
    char *i1 = args[0], *op = args[1];
    cfloat *x, *y;
    float xr, xi, r, denom;

    for (i = 0; i < n; i++, i1 += is1, op += os) {
        x = (cfloat *)i1;
        y = (cfloat *)op;
        xr = x->real;
        xi = x->imag;
        if (fabs(xi) <= fabs(xr)) {
            r = xi / xr;
            denom = xr + xi * r;
            y->real = 1 / denom;
            y->imag = -r / denom;
        } else {
            r = xr / xi;
            denom = xr * r + xi;
            y->real = r / denom;
            y->imag = -1 / denom;
        }
    }
}

#line 1310
static void
CDOUBLE_reciprocal(char **args, intp *dimensions, intp *steps, void *data)
{
    intp i, is1 = steps[0], os = steps[1], n = dimensions[0];
    char *i1 = args[0], *op = args[1];
    cdouble *x, *y;
    double xr, xi, r, denom;

    for (i = 0; i < n; i++, i1 += is1, op += os) {
        x = (cdouble *)i1;
        y = (cdouble *)op;
        xr = x->real;
        xi = x->imag;
        if (fabs(xi) <= fabs(xr)) {
            r = xi / xr;
            denom = xr + xi * r;
            y->real = 1 / denom;
            y->imag = -r / denom;
        } else {
            r = xr / xi;
            denom = xr * r + xi;
            y->real = r / denom;
            y->imag = -1 / denom;
        }
    }
}

#line 1310
static void
CLONGDOUBLE_reciprocal(char **args, intp *dimensions, intp *steps, void *data)
{
    intp i, is1 = steps[0], os = steps[1], n = dimensions[0];
    char *i1 = args[0], *op = args[1];
    clongdouble *x, *y;
    longdouble xr, xi, r, denom;

    for (i = 0; i < n; i++, i1 += is1, op += os) {
        x = (clongdouble *)i1;
        y = (clongdouble *)op;
        xr = x->real;
        xi = x->imag;
        if (fabs(xi) <= fabs(xr)) {
            r = xi / xr;
            denom = xr + xi * r;
            y->real = 1 / denom;
            y->imag = -r / denom;
        } else {
            r = xr / xi;
            denom = xr * r + xi;
            y->real = r / denom;
            y->imag = -1 / denom;
        }
    }
}



static PyObject *
Py_reciprocal(PyObject *o)
{
    PyObject *one, *result;
    one = PyInt_FromLong(1);
    if (!one) return NULL;
    result = PyNumber_Divide(one, o);
    Py_DECREF(one);
    return result;
}

static PyObject *
_npy_ObjectMax(PyObject *i1, PyObject *i2)
{
    int cmp;
    PyObject *res;
    if (PyObject_Cmp(i1, i2, &cmp) < 0) return NULL;

    if (cmp >= 0) {
        res = i1;
    }
    else {
        res = i2;
    }
    Py_INCREF(res);
    return res;
}

static PyObject *
_npy_ObjectMin(PyObject *i1, PyObject *i2)
{
    int cmp;
    PyObject *res;
    if (PyObject_Cmp(i1, i2, &cmp) < 0) return NULL;

    if (cmp <= 0) {
        res = i1;
    }
    else {
        res = i2;
    }
    Py_INCREF(res);
    return res;
}

/* ones_like is defined here because it's used for x**0 */

#line 1390
static void
BYTE_ones_like(char **args, intp *dimensions, intp *steps, void *data)
{
    intp i, os = steps[1], n = dimensions[0];
    char *op = args[1];

    for (i = 0; i < n; i++, op += os) {
        *((char *)op) = 1;
    }
}

#line 1390
static void
UBYTE_ones_like(char **args, intp *dimensions, intp *steps, void *data)
{
    intp i, os = steps[1], n = dimensions[0];
    char *op = args[1];

    for (i = 0; i < n; i++, op += os) {
        *((ubyte *)op) = 1;
    }
}

#line 1390
static void
SHORT_ones_like(char **args, intp *dimensions, intp *steps, void *data)
{
    intp i, os = steps[1], n = dimensions[0];
    char *op = args[1];

    for (i = 0; i < n; i++, op += os) {
        *((short *)op) = 1;
    }
}

#line 1390
static void
USHORT_ones_like(char **args, intp *dimensions, intp *steps, void *data)
{
    intp i, os = steps[1], n = dimensions[0];
    char *op = args[1];

    for (i = 0; i < n; i++, op += os) {
        *((ushort *)op) = 1;
    }
}

#line 1390
static void
INT_ones_like(char **args, intp *dimensions, intp *steps, void *data)
{
    intp i, os = steps[1], n = dimensions[0];
    char *op = args[1];

    for (i = 0; i < n; i++, op += os) {
        *((int *)op) = 1;
    }
}

#line 1390
static void
UINT_ones_like(char **args, intp *dimensions, intp *steps, void *data)
{
    intp i, os = steps[1], n = dimensions[0];
    char *op = args[1];

    for (i = 0; i < n; i++, op += os) {
        *((uint *)op) = 1;
    }
}

#line 1390
static void
LONG_ones_like(char **args, intp *dimensions, intp *steps, void *data)
{
    intp i, os = steps[1], n = dimensions[0];
    char *op = args[1];

    for (i = 0; i < n; i++, op += os) {
        *((long *)op) = 1;
    }
}

#line 1390
static void
ULONG_ones_like(char **args, intp *dimensions, intp *steps, void *data)
{
    intp i, os = steps[1], n = dimensions[0];
    char *op = args[1];

    for (i = 0; i < n; i++, op += os) {
        *((ulong *)op) = 1;
    }
}

#line 1390
static void
LONGLONG_ones_like(char **args, intp *dimensions, intp *steps, void *data)
{
    intp i, os = steps[1], n = dimensions[0];
    char *op = args[1];

    for (i = 0; i < n; i++, op += os) {
        *((longlong *)op) = 1;
    }
}

#line 1390
static void
ULONGLONG_ones_like(char **args, intp *dimensions, intp *steps, void *data)
{
    intp i, os = steps[1], n = dimensions[0];
    char *op = args[1];

    for (i = 0; i < n; i++, op += os) {
        *((ulonglong *)op) = 1;
    }
}

#line 1390
static void
FLOAT_ones_like(char **args, intp *dimensions, intp *steps, void *data)
{
    intp i, os = steps[1], n = dimensions[0];
    char *op = args[1];

    for (i = 0; i < n; i++, op += os) {
        *((float *)op) = 1;
    }
}

#line 1390
static void
DOUBLE_ones_like(char **args, intp *dimensions, intp *steps, void *data)
{
    intp i, os = steps[1], n = dimensions[0];
    char *op = args[1];

    for (i = 0; i < n; i++, op += os) {
        *((double *)op) = 1;
    }
}

#line 1390
static void
LONGDOUBLE_ones_like(char **args, intp *dimensions, intp *steps, void *data)
{
    intp i, os = steps[1], n = dimensions[0];
    char *op = args[1];

    for (i = 0; i < n; i++, op += os) {
        *((longdouble *)op) = 1;
    }
}


#line 1406
static void
CFLOAT_ones_like(char **args, intp *dimensions, intp *steps, void *data)
{
    intp i, is1 = steps[0], os = steps[1], n = dimensions[0];
    char *i1 = args[0], *op = args[1];
    cfloat *y;

    for (i = 0; i < n; i++, i1 += is1, op += os) {
        y = (cfloat *)op;
        y->real = 1.0;
        y->imag = 0.0;
    }
}

#line 1406
static void
CDOUBLE_ones_like(char **args, intp *dimensions, intp *steps, void *data)
{
    intp i, is1 = steps[0], os = steps[1], n = dimensions[0];
    char *i1 = args[0], *op = args[1];
    cdouble *y;

    for (i = 0; i < n; i++, i1 += is1, op += os) {
        y = (cdouble *)op;
        y->real = 1.0;
        y->imag = 0.0;
    }
}

#line 1406
static void
CLONGDOUBLE_ones_like(char **args, intp *dimensions, intp *steps, void *data)
{
    intp i, is1 = steps[0], os = steps[1], n = dimensions[0];
    char *i1 = args[0], *op = args[1];
    clongdouble *y;

    for (i = 0; i < n; i++, i1 += is1, op += os) {
        y = (clongdouble *)op;
        y->real = 1.0;
        y->imag = 0.0;
    }
}


static PyObject *
Py_get_one(PyObject *o)
{
    return PyInt_FromLong(1);
}


#line 1433
static void
BYTE_power(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, is1=steps[0],is2=steps[1];
    register intp os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    float x, y;

    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        x = (float)*((char *)i1);
        y = (float)*((char *)i2);
        *((char *)op) = (char) pow(x,y);
    }
}

#line 1433
static void
UBYTE_power(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, is1=steps[0],is2=steps[1];
    register intp os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    float x, y;

    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        x = (float)*((ubyte *)i1);
        y = (float)*((ubyte *)i2);
        *((ubyte *)op) = (ubyte) pow(x,y);
    }
}

#line 1433
static void
SHORT_power(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, is1=steps[0],is2=steps[1];
    register intp os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    float x, y;

    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        x = (float)*((short *)i1);
        y = (float)*((short *)i2);
        *((short *)op) = (short) pow(x,y);
    }
}

#line 1433
static void
USHORT_power(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, is1=steps[0],is2=steps[1];
    register intp os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    float x, y;

    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        x = (float)*((ushort *)i1);
        y = (float)*((ushort *)i2);
        *((ushort *)op) = (ushort) pow(x,y);
    }
}

#line 1433
static void
INT_power(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, is1=steps[0],is2=steps[1];
    register intp os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    double x, y;

    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        x = (double)*((int *)i1);
        y = (double)*((int *)i2);
        *((int *)op) = (int) pow(x,y);
    }
}

#line 1433
static void
UINT_power(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, is1=steps[0],is2=steps[1];
    register intp os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    double x, y;

    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        x = (double)*((uint *)i1);
        y = (double)*((uint *)i2);
        *((uint *)op) = (uint) pow(x,y);
    }
}

#line 1433
static void
LONG_power(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, is1=steps[0],is2=steps[1];
    register intp os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    double x, y;

    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        x = (double)*((long *)i1);
        y = (double)*((long *)i2);
        *((long *)op) = (long) pow(x,y);
    }
}

#line 1433
static void
ULONG_power(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, is1=steps[0],is2=steps[1];
    register intp os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    double x, y;

    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        x = (double)*((ulong *)i1);
        y = (double)*((ulong *)i2);
        *((ulong *)op) = (ulong) pow(x,y);
    }
}

#line 1433
static void
LONGLONG_power(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, is1=steps[0],is2=steps[1];
    register intp os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    double x, y;

    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        x = (double)*((longlong *)i1);
        y = (double)*((longlong *)i2);
        *((longlong *)op) = (longlong) pow(x,y);
    }
}

#line 1433
static void
ULONGLONG_power(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, is1=steps[0],is2=steps[1];
    register intp os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    double x, y;

    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        x = (double)*((ulonglong *)i1);
        y = (double)*((ulonglong *)i2);
        *((ulonglong *)op) = (ulonglong) pow(x,y);
    }
}


#line 1453
static void
UBYTE_conjugate(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, is1=steps[0], os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((ubyte *)op)=*((ubyte *)i1);
    }
}

#line 1453
static void
BYTE_conjugate(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, is1=steps[0], os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((char *)op)=*((char *)i1);
    }
}

#line 1453
static void
SHORT_conjugate(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, is1=steps[0], os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((short *)op)=*((short *)i1);
    }
}

#line 1453
static void
USHORT_conjugate(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, is1=steps[0], os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((ushort *)op)=*((ushort *)i1);
    }
}

#line 1453
static void
INT_conjugate(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, is1=steps[0], os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((int *)op)=*((int *)i1);
    }
}

#line 1453
static void
UINT_conjugate(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, is1=steps[0], os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((uint *)op)=*((uint *)i1);
    }
}

#line 1453
static void
LONG_conjugate(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, is1=steps[0], os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((long *)op)=*((long *)i1);
    }
}

#line 1453
static void
ULONG_conjugate(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, is1=steps[0], os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((ulong *)op)=*((ulong *)i1);
    }
}

#line 1453
static void
LONGLONG_conjugate(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, is1=steps[0], os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((longlong *)op)=*((longlong *)i1);
    }
}

#line 1453
static void
ULONGLONG_conjugate(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, is1=steps[0], os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((ulonglong *)op)=*((ulonglong *)i1);
    }
}

#line 1453
static void
FLOAT_conjugate(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, is1=steps[0], os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((float *)op)=*((float *)i1);
    }
}

#line 1453
static void
DOUBLE_conjugate(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, is1=steps[0], os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((double *)op)=*((double *)i1);
    }
}

#line 1453
static void
LONGDOUBLE_conjugate(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, is1=steps[0], os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((longdouble *)op)=*((longdouble *)i1);
    }
}


#line 1469
static void
CFLOAT_conjugate(char **args, intp *dimensions, intp *steps, void *func) {
    register intp i, is1=steps[0], os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];

    for(i=0; i<n; i++, i1+=is1, op+=os) {
        ((float *)op)[0]=((float *)i1)[0];
        ((float *)op)[1]=-(((float *)i1)[1]);
    }
}

#line 1469
static void
CDOUBLE_conjugate(char **args, intp *dimensions, intp *steps, void *func) {
    register intp i, is1=steps[0], os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];

    for(i=0; i<n; i++, i1+=is1, op+=os) {
        ((double *)op)[0]=((double *)i1)[0];
        ((double *)op)[1]=-(((double *)i1)[1]);
    }
}

#line 1469
static void
CLONGDOUBLE_conjugate(char **args, intp *dimensions, intp *steps, void *func) {
    register intp i, is1=steps[0], os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];

    for(i=0; i<n; i++, i1+=is1, op+=os) {
        ((longdouble *)op)[0]=((longdouble *)i1)[0];
        ((longdouble *)op)[1]=-(((longdouble *)i1)[1]);
    }
}



#line 1487
static void
BOOL_absolute(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, n;
    intp is1=steps[0], os=steps[1];
    char *i1=args[0], *op=args[1];

    n=dimensions[0];

    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((Bool *)op) = *((Bool*)i1);
    }
}

#line 1487
static void
UBYTE_absolute(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, n;
    intp is1=steps[0], os=steps[1];
    char *i1=args[0], *op=args[1];

    n=dimensions[0];

    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((ubyte *)op) = *((ubyte*)i1);
    }
}

#line 1487
static void
USHORT_absolute(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, n;
    intp is1=steps[0], os=steps[1];
    char *i1=args[0], *op=args[1];

    n=dimensions[0];

    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((ushort *)op) = *((ushort*)i1);
    }
}

#line 1487
static void
UINT_absolute(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, n;
    intp is1=steps[0], os=steps[1];
    char *i1=args[0], *op=args[1];

    n=dimensions[0];

    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((uint *)op) = *((uint*)i1);
    }
}

#line 1487
static void
ULONG_absolute(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, n;
    intp is1=steps[0], os=steps[1];
    char *i1=args[0], *op=args[1];

    n=dimensions[0];

    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((ulong *)op) = *((ulong*)i1);
    }
}

#line 1487
static void
ULONGLONG_absolute(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, n;
    intp is1=steps[0], os=steps[1];
    char *i1=args[0], *op=args[1];

    n=dimensions[0];

    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((ulonglong *)op) = *((ulonglong*)i1);
    }
}


#line 1507
static void
BYTE_absolute(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, n;
    intp is1=steps[0], os=steps[1];
    char *i1=args[0], *op=args[1];

    n=dimensions[0];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((byte *)op) = *((byte *)i1) < 0 ? -*((byte *)i1) : *((byte *)i1);
        *((byte *)op) += 0; /* clear sign-bit */
    }
}

#line 1507
static void
SHORT_absolute(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, n;
    intp is1=steps[0], os=steps[1];
    char *i1=args[0], *op=args[1];

    n=dimensions[0];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((short *)op) = *((short *)i1) < 0 ? -*((short *)i1) : *((short *)i1);
        *((short *)op) += 0; /* clear sign-bit */
    }
}

#line 1507
static void
INT_absolute(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, n;
    intp is1=steps[0], os=steps[1];
    char *i1=args[0], *op=args[1];

    n=dimensions[0];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((int *)op) = *((int *)i1) < 0 ? -*((int *)i1) : *((int *)i1);
        *((int *)op) += 0; /* clear sign-bit */
    }
}

#line 1507
static void
LONG_absolute(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, n;
    intp is1=steps[0], os=steps[1];
    char *i1=args[0], *op=args[1];

    n=dimensions[0];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((long *)op) = *((long *)i1) < 0 ? -*((long *)i1) : *((long *)i1);
        *((long *)op) += 0; /* clear sign-bit */
    }
}

#line 1507
static void
LONGLONG_absolute(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, n;
    intp is1=steps[0], os=steps[1];
    char *i1=args[0], *op=args[1];

    n=dimensions[0];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((longlong *)op) = *((longlong *)i1) < 0 ? -*((longlong *)i1) : *((longlong *)i1);
        *((longlong *)op) += 0; /* clear sign-bit */
    }
}

#line 1507
static void
FLOAT_absolute(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, n;
    intp is1=steps[0], os=steps[1];
    char *i1=args[0], *op=args[1];

    n=dimensions[0];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((float *)op) = *((float *)i1) < 0 ? -*((float *)i1) : *((float *)i1);
        *((float *)op) += 0; /* clear sign-bit */
    }
}

#line 1507
static void
DOUBLE_absolute(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, n;
    intp is1=steps[0], os=steps[1];
    char *i1=args[0], *op=args[1];

    n=dimensions[0];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((double *)op) = *((double *)i1) < 0 ? -*((double *)i1) : *((double *)i1);
        *((double *)op) += 0; /* clear sign-bit */
    }
}

#line 1507
static void
LONGDOUBLE_absolute(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, n;
    intp is1=steps[0], os=steps[1];
    char *i1=args[0], *op=args[1];

    n=dimensions[0];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((longdouble *)op) = *((longdouble *)i1) < 0 ? -*((longdouble *)i1) : *((longdouble *)i1);
        *((longdouble *)op) += 0; /* clear sign-bit */
    }
}


#line 1527
static void
CFLOAT_absolute(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, n;
    register intp is1=steps[0], os=steps[1];
    char *i1=args[0], *op=args[1];
    n=dimensions[0];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((float *)op) = (float)sqrtf(((float *)i1)[0]*((float *)i1)[0] + ((float *)i1)[1]*((float *)i1)[1]);
    }
}

#line 1527
static void
CDOUBLE_absolute(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, n;
    register intp is1=steps[0], os=steps[1];
    char *i1=args[0], *op=args[1];
    n=dimensions[0];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((double *)op) = (double)sqrt(((double *)i1)[0]*((double *)i1)[0] + ((double *)i1)[1]*((double *)i1)[1]);
    }
}

#line 1527
static void
CLONGDOUBLE_absolute(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i, n;
    register intp is1=steps[0], os=steps[1];
    char *i1=args[0], *op=args[1];
    n=dimensions[0];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((longdouble *)op) = (longdouble)sqrtl(((longdouble *)i1)[0]*((longdouble *)i1)[0] + ((longdouble *)i1)[1]*((longdouble *)i1)[1]);
    }
}


#line 1545
static void
BOOL_greater(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    Bool in1, in2;
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        in1 = (*((Bool *)i1) != 0);
        in2 = (*((Bool *)i2) != 0);
        *((Bool *)op)= in1 > in2;
    }
}

#line 1545
static void
BOOL_greater_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    Bool in1, in2;
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        in1 = (*((Bool *)i1) != 0);
        in2 = (*((Bool *)i2) != 0);
        *((Bool *)op)= in1 >= in2;
    }
}

#line 1545
static void
BOOL_less(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    Bool in1, in2;
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        in1 = (*((Bool *)i1) != 0);
        in2 = (*((Bool *)i2) != 0);
        *((Bool *)op)= in1 < in2;
    }
}

#line 1545
static void
BOOL_less_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    Bool in1, in2;
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        in1 = (*((Bool *)i1) != 0);
        in2 = (*((Bool *)i2) != 0);
        *((Bool *)op)= in1 <= in2;
    }
}

#line 1545
static void
BOOL_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    Bool in1, in2;
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        in1 = (*((Bool *)i1) != 0);
        in2 = (*((Bool *)i2) != 0);
        *((Bool *)op)= in1 == in2;
    }
}

#line 1545
static void
BOOL_not_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    Bool in1, in2;
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        in1 = (*((Bool *)i1) != 0);
        in2 = (*((Bool *)i2) != 0);
        *((Bool *)op)= in1 != in2;
    }
}

#line 1545
static void
BOOL_logical_and(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    Bool in1, in2;
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        in1 = (*((Bool *)i1) != 0);
        in2 = (*((Bool *)i2) != 0);
        *((Bool *)op)= in1 && in2;
    }
}

#line 1545
static void
BOOL_logical_or(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    Bool in1, in2;
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        in1 = (*((Bool *)i1) != 0);
        in2 = (*((Bool *)i2) != 0);
        *((Bool *)op)= in1 || in2;
    }
}

#line 1545
static void
BOOL_bitwise_and(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    Bool in1, in2;
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        in1 = (*((Bool *)i1) != 0);
        in2 = (*((Bool *)i2) != 0);
        *((Bool *)op)= in1 & in2;
    }
}

#line 1545
static void
BOOL_bitwise_or(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    Bool in1, in2;
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        in1 = (*((Bool *)i1) != 0);
        in2 = (*((Bool *)i2) != 0);
        *((Bool *)op)= in1 | in2;
    }
}

#line 1545
static void
BOOL_bitwise_xor(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    Bool in1, in2;
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        in1 = (*((Bool *)i1) != 0);
        in2 = (*((Bool *)i2) != 0);
        *((Bool *)op)= in1 ^ in2;
    }
}


#line 1567

static void
BYTE_greater(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((byte *)i1) > *((byte *)i2);
    }
}

#line 1567

static void
UBYTE_greater(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((ubyte *)i1) > *((ubyte *)i2);
    }
}

#line 1567

static void
SHORT_greater(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((short *)i1) > *((short *)i2);
    }
}

#line 1567

static void
USHORT_greater(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((ushort *)i1) > *((ushort *)i2);
    }
}

#line 1567

static void
INT_greater(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((int *)i1) > *((int *)i2);
    }
}

#line 1567

static void
UINT_greater(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((uint *)i1) > *((uint *)i2);
    }
}

#line 1567

static void
LONG_greater(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((long *)i1) > *((long *)i2);
    }
}

#line 1567

static void
ULONG_greater(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((ulong *)i1) > *((ulong *)i2);
    }
}

#line 1567

static void
LONGLONG_greater(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((longlong *)i1) > *((longlong *)i2);
    }
}

#line 1567

static void
ULONGLONG_greater(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((ulonglong *)i1) > *((ulonglong *)i2);
    }
}

#line 1567

static void
FLOAT_greater(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((float *)i1) > *((float *)i2);
    }
}

#line 1567

static void
DOUBLE_greater(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((double *)i1) > *((double *)i2);
    }
}

#line 1567

static void
LONGDOUBLE_greater(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((longdouble *)i1) > *((longdouble *)i2);
    }
}

#line 1567

static void
BYTE_greater_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((byte *)i1) >= *((byte *)i2);
    }
}

#line 1567

static void
UBYTE_greater_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((ubyte *)i1) >= *((ubyte *)i2);
    }
}

#line 1567

static void
SHORT_greater_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((short *)i1) >= *((short *)i2);
    }
}

#line 1567

static void
USHORT_greater_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((ushort *)i1) >= *((ushort *)i2);
    }
}

#line 1567

static void
INT_greater_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((int *)i1) >= *((int *)i2);
    }
}

#line 1567

static void
UINT_greater_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((uint *)i1) >= *((uint *)i2);
    }
}

#line 1567

static void
LONG_greater_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((long *)i1) >= *((long *)i2);
    }
}

#line 1567

static void
ULONG_greater_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((ulong *)i1) >= *((ulong *)i2);
    }
}

#line 1567

static void
LONGLONG_greater_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((longlong *)i1) >= *((longlong *)i2);
    }
}

#line 1567

static void
ULONGLONG_greater_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((ulonglong *)i1) >= *((ulonglong *)i2);
    }
}

#line 1567

static void
FLOAT_greater_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((float *)i1) >= *((float *)i2);
    }
}

#line 1567

static void
DOUBLE_greater_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((double *)i1) >= *((double *)i2);
    }
}

#line 1567

static void
LONGDOUBLE_greater_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((longdouble *)i1) >= *((longdouble *)i2);
    }
}

#line 1567

static void
BYTE_less(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((byte *)i1) < *((byte *)i2);
    }
}

#line 1567

static void
UBYTE_less(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((ubyte *)i1) < *((ubyte *)i2);
    }
}

#line 1567

static void
SHORT_less(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((short *)i1) < *((short *)i2);
    }
}

#line 1567

static void
USHORT_less(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((ushort *)i1) < *((ushort *)i2);
    }
}

#line 1567

static void
INT_less(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((int *)i1) < *((int *)i2);
    }
}

#line 1567

static void
UINT_less(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((uint *)i1) < *((uint *)i2);
    }
}

#line 1567

static void
LONG_less(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((long *)i1) < *((long *)i2);
    }
}

#line 1567

static void
ULONG_less(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((ulong *)i1) < *((ulong *)i2);
    }
}

#line 1567

static void
LONGLONG_less(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((longlong *)i1) < *((longlong *)i2);
    }
}

#line 1567

static void
ULONGLONG_less(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((ulonglong *)i1) < *((ulonglong *)i2);
    }
}

#line 1567

static void
FLOAT_less(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((float *)i1) < *((float *)i2);
    }
}

#line 1567

static void
DOUBLE_less(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((double *)i1) < *((double *)i2);
    }
}

#line 1567

static void
LONGDOUBLE_less(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((longdouble *)i1) < *((longdouble *)i2);
    }
}

#line 1567

static void
BYTE_less_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((byte *)i1) <= *((byte *)i2);
    }
}

#line 1567

static void
UBYTE_less_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((ubyte *)i1) <= *((ubyte *)i2);
    }
}

#line 1567

static void
SHORT_less_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((short *)i1) <= *((short *)i2);
    }
}

#line 1567

static void
USHORT_less_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((ushort *)i1) <= *((ushort *)i2);
    }
}

#line 1567

static void
INT_less_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((int *)i1) <= *((int *)i2);
    }
}

#line 1567

static void
UINT_less_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((uint *)i1) <= *((uint *)i2);
    }
}

#line 1567

static void
LONG_less_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((long *)i1) <= *((long *)i2);
    }
}

#line 1567

static void
ULONG_less_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((ulong *)i1) <= *((ulong *)i2);
    }
}

#line 1567

static void
LONGLONG_less_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((longlong *)i1) <= *((longlong *)i2);
    }
}

#line 1567

static void
ULONGLONG_less_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((ulonglong *)i1) <= *((ulonglong *)i2);
    }
}

#line 1567

static void
FLOAT_less_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((float *)i1) <= *((float *)i2);
    }
}

#line 1567

static void
DOUBLE_less_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((double *)i1) <= *((double *)i2);
    }
}

#line 1567

static void
LONGDOUBLE_less_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((longdouble *)i1) <= *((longdouble *)i2);
    }
}



#line 1587

static void
CFLOAT_greater(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        if (((cfloat *)i1)->real == ((cfloat *)i2)->real)
            *((Bool *)op)=((cfloat *)i1)->imag > \
                ((cfloat *)i2)->imag;
        else
            *((Bool *)op)=((cfloat *)i1)->real > \
                ((cfloat *)i2)->real;
    }
}

#line 1587

static void
CDOUBLE_greater(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        if (((cdouble *)i1)->real == ((cdouble *)i2)->real)
            *((Bool *)op)=((cdouble *)i1)->imag > \
                ((cdouble *)i2)->imag;
        else
            *((Bool *)op)=((cdouble *)i1)->real > \
                ((cdouble *)i2)->real;
    }
}

#line 1587

static void
CLONGDOUBLE_greater(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        if (((clongdouble *)i1)->real == ((clongdouble *)i2)->real)
            *((Bool *)op)=((clongdouble *)i1)->imag > \
                ((clongdouble *)i2)->imag;
        else
            *((Bool *)op)=((clongdouble *)i1)->real > \
                ((clongdouble *)i2)->real;
    }
}

#line 1587

static void
CFLOAT_greater_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        if (((cfloat *)i1)->real == ((cfloat *)i2)->real)
            *((Bool *)op)=((cfloat *)i1)->imag >= \
                ((cfloat *)i2)->imag;
        else
            *((Bool *)op)=((cfloat *)i1)->real >= \
                ((cfloat *)i2)->real;
    }
}

#line 1587

static void
CDOUBLE_greater_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        if (((cdouble *)i1)->real == ((cdouble *)i2)->real)
            *((Bool *)op)=((cdouble *)i1)->imag >= \
                ((cdouble *)i2)->imag;
        else
            *((Bool *)op)=((cdouble *)i1)->real >= \
                ((cdouble *)i2)->real;
    }
}

#line 1587

static void
CLONGDOUBLE_greater_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        if (((clongdouble *)i1)->real == ((clongdouble *)i2)->real)
            *((Bool *)op)=((clongdouble *)i1)->imag >= \
                ((clongdouble *)i2)->imag;
        else
            *((Bool *)op)=((clongdouble *)i1)->real >= \
                ((clongdouble *)i2)->real;
    }
}

#line 1587

static void
CFLOAT_less(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        if (((cfloat *)i1)->real == ((cfloat *)i2)->real)
            *((Bool *)op)=((cfloat *)i1)->imag < \
                ((cfloat *)i2)->imag;
        else
            *((Bool *)op)=((cfloat *)i1)->real < \
                ((cfloat *)i2)->real;
    }
}

#line 1587

static void
CDOUBLE_less(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        if (((cdouble *)i1)->real == ((cdouble *)i2)->real)
            *((Bool *)op)=((cdouble *)i1)->imag < \
                ((cdouble *)i2)->imag;
        else
            *((Bool *)op)=((cdouble *)i1)->real < \
                ((cdouble *)i2)->real;
    }
}

#line 1587

static void
CLONGDOUBLE_less(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        if (((clongdouble *)i1)->real == ((clongdouble *)i2)->real)
            *((Bool *)op)=((clongdouble *)i1)->imag < \
                ((clongdouble *)i2)->imag;
        else
            *((Bool *)op)=((clongdouble *)i1)->real < \
                ((clongdouble *)i2)->real;
    }
}

#line 1587

static void
CFLOAT_less_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        if (((cfloat *)i1)->real == ((cfloat *)i2)->real)
            *((Bool *)op)=((cfloat *)i1)->imag <= \
                ((cfloat *)i2)->imag;
        else
            *((Bool *)op)=((cfloat *)i1)->real <= \
                ((cfloat *)i2)->real;
    }
}

#line 1587

static void
CDOUBLE_less_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        if (((cdouble *)i1)->real == ((cdouble *)i2)->real)
            *((Bool *)op)=((cdouble *)i1)->imag <= \
                ((cdouble *)i2)->imag;
        else
            *((Bool *)op)=((cdouble *)i1)->real <= \
                ((cdouble *)i2)->real;
    }
}

#line 1587

static void
CLONGDOUBLE_less_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        if (((clongdouble *)i1)->real == ((clongdouble *)i2)->real)
            *((Bool *)op)=((clongdouble *)i1)->imag <= \
                ((clongdouble *)i2)->imag;
        else
            *((Bool *)op)=((clongdouble *)i1)->real <= \
                ((clongdouble *)i2)->real;
    }
}



#line 1612
static void
BYTE_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = *((byte *)i1) == *((byte *)i2);
    }
}

#line 1612
static void
UBYTE_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = *((ubyte *)i1) == *((ubyte *)i2);
    }
}

#line 1612
static void
SHORT_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = *((short *)i1) == *((short *)i2);
    }
}

#line 1612
static void
USHORT_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = *((ushort *)i1) == *((ushort *)i2);
    }
}

#line 1612
static void
INT_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = *((int *)i1) == *((int *)i2);
    }
}

#line 1612
static void
UINT_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = *((uint *)i1) == *((uint *)i2);
    }
}

#line 1612
static void
LONG_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = *((long *)i1) == *((long *)i2);
    }
}

#line 1612
static void
ULONG_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = *((ulong *)i1) == *((ulong *)i2);
    }
}

#line 1612
static void
LONGLONG_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = *((longlong *)i1) == *((longlong *)i2);
    }
}

#line 1612
static void
ULONGLONG_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = *((ulonglong *)i1) == *((ulonglong *)i2);
    }
}

#line 1612
static void
FLOAT_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = *((float *)i1) == *((float *)i2);
    }
}

#line 1612
static void
DOUBLE_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = *((double *)i1) == *((double *)i2);
    }
}

#line 1612
static void
LONGDOUBLE_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = *((longdouble *)i1) == *((longdouble *)i2);
    }
}

#line 1612
static void
BYTE_not_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = *((byte *)i1) != *((byte *)i2);
    }
}

#line 1612
static void
UBYTE_not_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = *((ubyte *)i1) != *((ubyte *)i2);
    }
}

#line 1612
static void
SHORT_not_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = *((short *)i1) != *((short *)i2);
    }
}

#line 1612
static void
USHORT_not_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = *((ushort *)i1) != *((ushort *)i2);
    }
}

#line 1612
static void
INT_not_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = *((int *)i1) != *((int *)i2);
    }
}

#line 1612
static void
UINT_not_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = *((uint *)i1) != *((uint *)i2);
    }
}

#line 1612
static void
LONG_not_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = *((long *)i1) != *((long *)i2);
    }
}

#line 1612
static void
ULONG_not_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = *((ulong *)i1) != *((ulong *)i2);
    }
}

#line 1612
static void
LONGLONG_not_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = *((longlong *)i1) != *((longlong *)i2);
    }
}

#line 1612
static void
ULONGLONG_not_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = *((ulonglong *)i1) != *((ulonglong *)i2);
    }
}

#line 1612
static void
FLOAT_not_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = *((float *)i1) != *((float *)i2);
    }
}

#line 1612
static void
DOUBLE_not_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = *((double *)i1) != *((double *)i2);
    }
}

#line 1612
static void
LONGDOUBLE_not_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = *((longdouble *)i1) != *((longdouble *)i2);
    }
}

#line 1612
static void
BYTE_logical_and(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = *((byte *)i1) && *((byte *)i2);
    }
}

#line 1612
static void
UBYTE_logical_and(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = *((ubyte *)i1) && *((ubyte *)i2);
    }
}

#line 1612
static void
SHORT_logical_and(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = *((short *)i1) && *((short *)i2);
    }
}

#line 1612
static void
USHORT_logical_and(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = *((ushort *)i1) && *((ushort *)i2);
    }
}

#line 1612
static void
INT_logical_and(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = *((int *)i1) && *((int *)i2);
    }
}

#line 1612
static void
UINT_logical_and(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = *((uint *)i1) && *((uint *)i2);
    }
}

#line 1612
static void
LONG_logical_and(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = *((long *)i1) && *((long *)i2);
    }
}

#line 1612
static void
ULONG_logical_and(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = *((ulong *)i1) && *((ulong *)i2);
    }
}

#line 1612
static void
LONGLONG_logical_and(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = *((longlong *)i1) && *((longlong *)i2);
    }
}

#line 1612
static void
ULONGLONG_logical_and(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = *((ulonglong *)i1) && *((ulonglong *)i2);
    }
}

#line 1612
static void
FLOAT_logical_and(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = *((float *)i1) && *((float *)i2);
    }
}

#line 1612
static void
DOUBLE_logical_and(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = *((double *)i1) && *((double *)i2);
    }
}

#line 1612
static void
LONGDOUBLE_logical_and(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = *((longdouble *)i1) && *((longdouble *)i2);
    }
}

#line 1612
static void
BYTE_logical_or(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = *((byte *)i1) || *((byte *)i2);
    }
}

#line 1612
static void
UBYTE_logical_or(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = *((ubyte *)i1) || *((ubyte *)i2);
    }
}

#line 1612
static void
SHORT_logical_or(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = *((short *)i1) || *((short *)i2);
    }
}

#line 1612
static void
USHORT_logical_or(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = *((ushort *)i1) || *((ushort *)i2);
    }
}

#line 1612
static void
INT_logical_or(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = *((int *)i1) || *((int *)i2);
    }
}

#line 1612
static void
UINT_logical_or(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = *((uint *)i1) || *((uint *)i2);
    }
}

#line 1612
static void
LONG_logical_or(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = *((long *)i1) || *((long *)i2);
    }
}

#line 1612
static void
ULONG_logical_or(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = *((ulong *)i1) || *((ulong *)i2);
    }
}

#line 1612
static void
LONGLONG_logical_or(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = *((longlong *)i1) || *((longlong *)i2);
    }
}

#line 1612
static void
ULONGLONG_logical_or(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = *((ulonglong *)i1) || *((ulonglong *)i2);
    }
}

#line 1612
static void
FLOAT_logical_or(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = *((float *)i1) || *((float *)i2);
    }
}

#line 1612
static void
DOUBLE_logical_or(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = *((double *)i1) || *((double *)i2);
    }
}

#line 1612
static void
LONGDOUBLE_logical_or(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = *((longdouble *)i1) || *((longdouble *)i2);
    }
}



#line 1633
static void
CFLOAT_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = (*((float *)i1) == *((float *)i2)) && (*((float *)i1+1) == *((float *)i2+1));
    }
}

#line 1633
static void
CDOUBLE_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = (*((double *)i1) == *((double *)i2)) && (*((double *)i1+1) == *((double *)i2+1));
    }
}

#line 1633
static void
CLONGDOUBLE_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = (*((longdouble *)i1) == *((longdouble *)i2)) && (*((longdouble *)i1+1) == *((longdouble *)i2+1));
    }
}

#line 1633
static void
CFLOAT_not_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = (*((float *)i1) != *((float *)i2)) || (*((float *)i1+1) != *((float *)i2+1));
    }
}

#line 1633
static void
CDOUBLE_not_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = (*((double *)i1) != *((double *)i2)) || (*((double *)i1+1) != *((double *)i2+1));
    }
}

#line 1633
static void
CLONGDOUBLE_not_equal(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = (*((longdouble *)i1) != *((longdouble *)i2)) || (*((longdouble *)i1+1) != *((longdouble *)i2+1));
    }
}

#line 1633
static void
CFLOAT_logical_and(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = (*((float *)i1) && *((float *)i2)) && (*((float *)i1+1) && *((float *)i2+1));
    }
}

#line 1633
static void
CDOUBLE_logical_and(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = (*((double *)i1) && *((double *)i2)) && (*((double *)i1+1) && *((double *)i2+1));
    }
}

#line 1633
static void
CLONGDOUBLE_logical_and(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = (*((longdouble *)i1) && *((longdouble *)i2)) && (*((longdouble *)i1+1) && *((longdouble *)i2+1));
    }
}

#line 1633
static void
CFLOAT_logical_or(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = (*((float *)i1) || *((float *)i2)) || (*((float *)i1+1) || *((float *)i2+1));
    }
}

#line 1633
static void
CDOUBLE_logical_or(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = (*((double *)i1) || *((double *)i2)) || (*((double *)i1+1) || *((double *)i2+1));
    }
}

#line 1633
static void
CLONGDOUBLE_logical_or(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = (*((longdouble *)i1) || *((longdouble *)i2)) || (*((longdouble *)i1+1) || *((longdouble *)i2+1));
    }
}



/** OBJECT comparison for OBJECT arrays **/

#line 1653
static void
OBJECT_greater(char **args, intp *dimensions, intp *steps, void *func) {
    register intp i, is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=PyObject_RichCompareBool(*((PyObject **)i1),
                                               *((PyObject **)i2),
                                               Py_GT);
    }
}

#line 1653
static void
OBJECT_greater_equal(char **args, intp *dimensions, intp *steps, void *func) {
    register intp i, is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=PyObject_RichCompareBool(*((PyObject **)i1),
                                               *((PyObject **)i2),
                                               Py_GE);
    }
}

#line 1653
static void
OBJECT_less(char **args, intp *dimensions, intp *steps, void *func) {
    register intp i, is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=PyObject_RichCompareBool(*((PyObject **)i1),
                                               *((PyObject **)i2),
                                               Py_LT);
    }
}

#line 1653
static void
OBJECT_less_equal(char **args, intp *dimensions, intp *steps, void *func) {
    register intp i, is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=PyObject_RichCompareBool(*((PyObject **)i1),
                                               *((PyObject **)i2),
                                               Py_LE);
    }
}

#line 1653
static void
OBJECT_equal(char **args, intp *dimensions, intp *steps, void *func) {
    register intp i, is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=PyObject_RichCompareBool(*((PyObject **)i1),
                                               *((PyObject **)i2),
                                               Py_EQ);
    }
}

#line 1653
static void
OBJECT_not_equal(char **args, intp *dimensions, intp *steps, void *func) {
    register intp i, is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=PyObject_RichCompareBool(*((PyObject **)i1),
                                               *((PyObject **)i2),
                                               Py_NE);
    }
}


#line 1671
static void
BYTE_negative(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((byte *)op) = (byte) (- (byte)*((byte *)i1));
    }
}

#line 1671
static void
UBYTE_negative(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((ubyte *)op) = (ubyte) (- (byte)*((ubyte *)i1));
    }
}

#line 1671
static void
SHORT_negative(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((short *)op) = (short) (- (short)*((short *)i1));
    }
}

#line 1671
static void
USHORT_negative(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((ushort *)op) = (ushort) (- (short)*((ushort *)i1));
    }
}

#line 1671
static void
INT_negative(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((int *)op) = (int) (- (int)*((int *)i1));
    }
}

#line 1671
static void
UINT_negative(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((uint *)op) = (uint) (- (int)*((uint *)i1));
    }
}

#line 1671
static void
LONG_negative(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((long *)op) = (long) (- (long)*((long *)i1));
    }
}

#line 1671
static void
ULONG_negative(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((ulong *)op) = (ulong) (- (long)*((ulong *)i1));
    }
}

#line 1671
static void
LONGLONG_negative(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((longlong *)op) = (longlong) (- (longlong)*((longlong *)i1));
    }
}

#line 1671
static void
ULONGLONG_negative(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((ulonglong *)op) = (ulonglong) (- (longlong)*((ulonglong *)i1));
    }
}

#line 1671
static void
FLOAT_negative(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((float *)op) = (float) (- (float)*((float *)i1));
    }
}

#line 1671
static void
DOUBLE_negative(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((double *)op) = (double) (- (double)*((double *)i1));
    }
}

#line 1671
static void
LONGDOUBLE_negative(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((longdouble *)op) = (longdouble) (- (longdouble)*((longdouble *)i1));
    }
}


#define BOOL_negative BOOL_logical_not

#define _SIGN1(x) ((x) > 0 ? 1 : ((x) < 0 ? -1 : 0))
#define _SIGN2(x) ((x) == 0 ? 0 : 1)
#define _SIGNC(x) (((x).real > 0) ? 1 : ((x).real < 0 ? -1 : ((x).imag > 0 ? 1 : ((x).imag < 0) ? -1 : 0)))
#line 1693
static void
BYTE_sign(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    byte t1;
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        t1 = *((byte *)i1);
        *((byte *)op) = (byte) _SIGN1(t1);
    }
}

#line 1693
static void
SHORT_sign(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    short t1;
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        t1 = *((short *)i1);
        *((short *)op) = (short) _SIGN1(t1);
    }
}

#line 1693
static void
INT_sign(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    int t1;
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        t1 = *((int *)i1);
        *((int *)op) = (int) _SIGN1(t1);
    }
}

#line 1693
static void
LONG_sign(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    long t1;
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        t1 = *((long *)i1);
        *((long *)op) = (long) _SIGN1(t1);
    }
}

#line 1693
static void
LONGLONG_sign(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    longlong t1;
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        t1 = *((longlong *)i1);
        *((longlong *)op) = (longlong) _SIGN1(t1);
    }
}

#line 1693
static void
FLOAT_sign(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    float t1;
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        t1 = *((float *)i1);
        *((float *)op) = (float) _SIGN1(t1);
    }
}

#line 1693
static void
DOUBLE_sign(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    double t1;
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        t1 = *((double *)i1);
        *((double *)op) = (double) _SIGN1(t1);
    }
}

#line 1693
static void
LONGDOUBLE_sign(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    longdouble t1;
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        t1 = *((longdouble *)i1);
        *((longdouble *)op) = (longdouble) _SIGN1(t1);
    }
}

#line 1693
static void
UBYTE_sign(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    ubyte t1;
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        t1 = *((ubyte *)i1);
        *((ubyte *)op) = (ubyte) _SIGN2(t1);
    }
}

#line 1693
static void
USHORT_sign(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    ushort t1;
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        t1 = *((ushort *)i1);
        *((ushort *)op) = (ushort) _SIGN2(t1);
    }
}

#line 1693
static void
UINT_sign(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    uint t1;
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        t1 = *((uint *)i1);
        *((uint *)op) = (uint) _SIGN2(t1);
    }
}

#line 1693
static void
ULONG_sign(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    ulong t1;
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        t1 = *((ulong *)i1);
        *((ulong *)op) = (ulong) _SIGN2(t1);
    }
}

#line 1693
static void
ULONGLONG_sign(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    ulonglong t1;
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        t1 = *((ulonglong *)i1);
        *((ulonglong *)op) = (ulonglong) _SIGN2(t1);
    }
}


#line 1712
static void
CFLOAT_sign(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    cfloat t1;
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        t1 = *((cfloat *)i1);
        (*((cfloat *)op)).real = (float)_SIGNC(t1);
        (*((cfloat *)op)).imag = (float)0;
    }
}

#line 1712
static void
CDOUBLE_sign(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    cdouble t1;
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        t1 = *((cdouble *)i1);
        (*((cdouble *)op)).real = (double)_SIGNC(t1);
        (*((cdouble *)op)).imag = (double)0;
    }
}

#line 1712
static void
CLONGDOUBLE_sign(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    clongdouble t1;
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        t1 = *((clongdouble *)i1);
        (*((clongdouble *)op)).real = (longdouble)_SIGNC(t1);
        (*((clongdouble *)op)).imag = (longdouble)0;
    }
}


#undef _SIGN1
#undef _SIGN2
#undef _SIGNC


static void
OBJECT_sign(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    PyObject *t1, *zero, *res;
    zero = PyInt_FromLong(0);
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        t1 = *((PyObject **)i1);
        res = PyInt_FromLong((long) PyObject_Compare(t1, zero));
        *((PyObject **)op) = res;
    }
    Py_DECREF(zero);
}


#line 1753
static void
BOOL_logical_not(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((Bool *)op) = ! *((Bool *)i1);
    }
}

#line 1753
static void
BYTE_logical_not(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((Bool *)op) = ! *((byte *)i1);
    }
}

#line 1753
static void
UBYTE_logical_not(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((Bool *)op) = ! *((ubyte *)i1);
    }
}

#line 1753
static void
SHORT_logical_not(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((Bool *)op) = ! *((short *)i1);
    }
}

#line 1753
static void
USHORT_logical_not(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((Bool *)op) = ! *((ushort *)i1);
    }
}

#line 1753
static void
INT_logical_not(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((Bool *)op) = ! *((int *)i1);
    }
}

#line 1753
static void
UINT_logical_not(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((Bool *)op) = ! *((uint *)i1);
    }
}

#line 1753
static void
LONG_logical_not(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((Bool *)op) = ! *((long *)i1);
    }
}

#line 1753
static void
ULONG_logical_not(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((Bool *)op) = ! *((ulong *)i1);
    }
}

#line 1753
static void
LONGLONG_logical_not(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((Bool *)op) = ! *((longlong *)i1);
    }
}

#line 1753
static void
ULONGLONG_logical_not(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((Bool *)op) = ! *((ulonglong *)i1);
    }
}

#line 1753
static void
FLOAT_logical_not(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((Bool *)op) = ! *((float *)i1);
    }
}

#line 1753
static void
DOUBLE_logical_not(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((Bool *)op) = ! *((double *)i1);
    }
}

#line 1753
static void
LONGDOUBLE_logical_not(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((Bool *)op) = ! *((longdouble *)i1);
    }
}


#line 1769
static void
CFLOAT_logical_not(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((Bool *)op) = ! (((cfloat *)i1)->real ||       \
                           ((cfloat *)i1)->imag);
    }
}

#line 1769
static void
CDOUBLE_logical_not(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((Bool *)op) = ! (((cdouble *)i1)->real ||       \
                           ((cdouble *)i1)->imag);
    }
}

#line 1769
static void
CLONGDOUBLE_logical_not(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((Bool *)op) = ! (((clongdouble *)i1)->real ||       \
                           ((clongdouble *)i1)->imag);
    }
}





#line 1790
static void
BYTE_remainder(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    register byte ix,iy, tmp;
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        ix = *((byte *)i1);
        iy = *((byte *)i2);
        if (iy == 0 || ix == 0) {
            if (iy == 0) generate_divbyzero_error();
            *((byte *)op) = 0;
        }
        else if ((ix > 0) == (iy > 0)) {
            *((byte *)op) = ix % iy;
        }
        else {  /* handle mixed case the way Python does */
            tmp = ix % iy;
            if (tmp) tmp += iy;
            *((byte *)op)= tmp;
        }
    }
}

#line 1790
static void
SHORT_remainder(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    register short ix,iy, tmp;
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        ix = *((short *)i1);
        iy = *((short *)i2);
        if (iy == 0 || ix == 0) {
            if (iy == 0) generate_divbyzero_error();
            *((short *)op) = 0;
        }
        else if ((ix > 0) == (iy > 0)) {
            *((short *)op) = ix % iy;
        }
        else {  /* handle mixed case the way Python does */
            tmp = ix % iy;
            if (tmp) tmp += iy;
            *((short *)op)= tmp;
        }
    }
}

#line 1790
static void
INT_remainder(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    register int ix,iy, tmp;
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        ix = *((int *)i1);
        iy = *((int *)i2);
        if (iy == 0 || ix == 0) {
            if (iy == 0) generate_divbyzero_error();
            *((int *)op) = 0;
        }
        else if ((ix > 0) == (iy > 0)) {
            *((int *)op) = ix % iy;
        }
        else {  /* handle mixed case the way Python does */
            tmp = ix % iy;
            if (tmp) tmp += iy;
            *((int *)op)= tmp;
        }
    }
}

#line 1790
static void
LONG_remainder(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    register long ix,iy, tmp;
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        ix = *((long *)i1);
        iy = *((long *)i2);
        if (iy == 0 || ix == 0) {
            if (iy == 0) generate_divbyzero_error();
            *((long *)op) = 0;
        }
        else if ((ix > 0) == (iy > 0)) {
            *((long *)op) = ix % iy;
        }
        else {  /* handle mixed case the way Python does */
            tmp = ix % iy;
            if (tmp) tmp += iy;
            *((long *)op)= tmp;
        }
    }
}

#line 1790
static void
LONGLONG_remainder(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    register longlong ix,iy, tmp;
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        ix = *((longlong *)i1);
        iy = *((longlong *)i2);
        if (iy == 0 || ix == 0) {
            if (iy == 0) generate_divbyzero_error();
            *((longlong *)op) = 0;
        }
        else if ((ix > 0) == (iy > 0)) {
            *((longlong *)op) = ix % iy;
        }
        else {  /* handle mixed case the way Python does */
            tmp = ix % iy;
            if (tmp) tmp += iy;
            *((longlong *)op)= tmp;
        }
    }
}


#line 1820
static void
UBYTE_remainder(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    register ubyte ix,iy;
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        ix = *((ubyte *)i1);
        iy = *((ubyte *)i2);
        if (iy == 0) {
            generate_divbyzero_error();
            *((ubyte *)op) = 0;
        }
        *((ubyte *)op) = ix % iy;
    }
}

#line 1820
static void
USHORT_remainder(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    register ushort ix,iy;
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        ix = *((ushort *)i1);
        iy = *((ushort *)i2);
        if (iy == 0) {
            generate_divbyzero_error();
            *((ushort *)op) = 0;
        }
        *((ushort *)op) = ix % iy;
    }
}

#line 1820
static void
UINT_remainder(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    register uint ix,iy;
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        ix = *((uint *)i1);
        iy = *((uint *)i2);
        if (iy == 0) {
            generate_divbyzero_error();
            *((uint *)op) = 0;
        }
        *((uint *)op) = ix % iy;
    }
}

#line 1820
static void
ULONG_remainder(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    register ulong ix,iy;
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        ix = *((ulong *)i1);
        iy = *((ulong *)i2);
        if (iy == 0) {
            generate_divbyzero_error();
            *((ulong *)op) = 0;
        }
        *((ulong *)op) = ix % iy;
    }
}

#line 1820
static void
ULONGLONG_remainder(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    register ulonglong ix,iy;
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        ix = *((ulonglong *)i1);
        iy = *((ulonglong *)i2);
        if (iy == 0) {
            generate_divbyzero_error();
            *((ulonglong *)op) = 0;
        }
        *((ulonglong *)op) = ix % iy;
    }
}


#line 1844
static void
FLOAT_remainder(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    float x, y, res;
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        x = *((float *)i1);
        y = *((float *)i2);
        res = fmodf(x, y);
        if (res && ((y < 0) != (res < 0))) {
            res += y;
        }
        *((float *)op)= res;
    }
}

#line 1844
static void
DOUBLE_remainder(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    double x, y, res;
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        x = *((double *)i1);
        y = *((double *)i2);
        res = fmod(x, y);
        if (res && ((y < 0) != (res < 0))) {
            res += y;
        }
        *((double *)op)= res;
    }
}

#line 1844
static void
LONGDOUBLE_remainder(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    longdouble x, y, res;
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        x = *((longdouble *)i1);
        y = *((longdouble *)i2);
        res = fmodl(x, y);
        if (res && ((y < 0) != (res < 0))) {
            res += y;
        }
        *((longdouble *)op)= res;
    }
}



#line 1869
static void
BYTE_fmod(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    byte x, y;
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        x = *((byte *)i1);
        y = *((byte *)i2);
        if (y == 0) {
            generate_divbyzero_error();
            *((byte *)op) = 0;
        }
        else {
            *((byte *)op)= x % y;
        }

    }
}

#line 1869
static void
UBYTE_fmod(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    ubyte x, y;
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        x = *((ubyte *)i1);
        y = *((ubyte *)i2);
        if (y == 0) {
            generate_divbyzero_error();
            *((ubyte *)op) = 0;
        }
        else {
            *((ubyte *)op)= x % y;
        }

    }
}

#line 1869
static void
SHORT_fmod(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    short x, y;
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        x = *((short *)i1);
        y = *((short *)i2);
        if (y == 0) {
            generate_divbyzero_error();
            *((short *)op) = 0;
        }
        else {
            *((short *)op)= x % y;
        }

    }
}

#line 1869
static void
USHORT_fmod(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    ushort x, y;
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        x = *((ushort *)i1);
        y = *((ushort *)i2);
        if (y == 0) {
            generate_divbyzero_error();
            *((ushort *)op) = 0;
        }
        else {
            *((ushort *)op)= x % y;
        }

    }
}

#line 1869
static void
INT_fmod(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    int x, y;
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        x = *((int *)i1);
        y = *((int *)i2);
        if (y == 0) {
            generate_divbyzero_error();
            *((int *)op) = 0;
        }
        else {
            *((int *)op)= x % y;
        }

    }
}

#line 1869
static void
UINT_fmod(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    uint x, y;
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        x = *((uint *)i1);
        y = *((uint *)i2);
        if (y == 0) {
            generate_divbyzero_error();
            *((uint *)op) = 0;
        }
        else {
            *((uint *)op)= x % y;
        }

    }
}

#line 1869
static void
LONG_fmod(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    long x, y;
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        x = *((long *)i1);
        y = *((long *)i2);
        if (y == 0) {
            generate_divbyzero_error();
            *((long *)op) = 0;
        }
        else {
            *((long *)op)= x % y;
        }

    }
}

#line 1869
static void
ULONG_fmod(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    ulong x, y;
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        x = *((ulong *)i1);
        y = *((ulong *)i2);
        if (y == 0) {
            generate_divbyzero_error();
            *((ulong *)op) = 0;
        }
        else {
            *((ulong *)op)= x % y;
        }

    }
}

#line 1869
static void
LONGLONG_fmod(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    longlong x, y;
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        x = *((longlong *)i1);
        y = *((longlong *)i2);
        if (y == 0) {
            generate_divbyzero_error();
            *((longlong *)op) = 0;
        }
        else {
            *((longlong *)op)= x % y;
        }

    }
}

#line 1869
static void
ULONGLONG_fmod(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    ulonglong x, y;
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        x = *((ulonglong *)i1);
        y = *((ulonglong *)i2);
        if (y == 0) {
            generate_divbyzero_error();
            *((ulonglong *)op) = 0;
        }
        else {
            *((ulonglong *)op)= x % y;
        }

    }
}


#line 1899
static void
BYTE_bitwise_and(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    register char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((byte *)op)=*((byte *)i1) & *((byte *)i2);
    }
}

#line 1899
static void
UBYTE_bitwise_and(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    register char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((ubyte *)op)=*((ubyte *)i1) & *((ubyte *)i2);
    }
}

#line 1899
static void
SHORT_bitwise_and(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    register char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((short *)op)=*((short *)i1) & *((short *)i2);
    }
}

#line 1899
static void
USHORT_bitwise_and(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    register char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((ushort *)op)=*((ushort *)i1) & *((ushort *)i2);
    }
}

#line 1899
static void
INT_bitwise_and(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    register char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((int *)op)=*((int *)i1) & *((int *)i2);
    }
}

#line 1899
static void
UINT_bitwise_and(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    register char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((uint *)op)=*((uint *)i1) & *((uint *)i2);
    }
}

#line 1899
static void
LONG_bitwise_and(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    register char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((long *)op)=*((long *)i1) & *((long *)i2);
    }
}

#line 1899
static void
ULONG_bitwise_and(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    register char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((ulong *)op)=*((ulong *)i1) & *((ulong *)i2);
    }
}

#line 1899
static void
LONGLONG_bitwise_and(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    register char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((longlong *)op)=*((longlong *)i1) & *((longlong *)i2);
    }
}

#line 1899
static void
ULONGLONG_bitwise_and(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    register char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((ulonglong *)op)=*((ulonglong *)i1) & *((ulonglong *)i2);
    }
}

#line 1899
static void
BYTE_bitwise_or(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    register char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((byte *)op)=*((byte *)i1) | *((byte *)i2);
    }
}

#line 1899
static void
UBYTE_bitwise_or(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    register char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((ubyte *)op)=*((ubyte *)i1) | *((ubyte *)i2);
    }
}

#line 1899
static void
SHORT_bitwise_or(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    register char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((short *)op)=*((short *)i1) | *((short *)i2);
    }
}

#line 1899
static void
USHORT_bitwise_or(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    register char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((ushort *)op)=*((ushort *)i1) | *((ushort *)i2);
    }
}

#line 1899
static void
INT_bitwise_or(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    register char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((int *)op)=*((int *)i1) | *((int *)i2);
    }
}

#line 1899
static void
UINT_bitwise_or(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    register char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((uint *)op)=*((uint *)i1) | *((uint *)i2);
    }
}

#line 1899
static void
LONG_bitwise_or(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    register char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((long *)op)=*((long *)i1) | *((long *)i2);
    }
}

#line 1899
static void
ULONG_bitwise_or(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    register char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((ulong *)op)=*((ulong *)i1) | *((ulong *)i2);
    }
}

#line 1899
static void
LONGLONG_bitwise_or(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    register char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((longlong *)op)=*((longlong *)i1) | *((longlong *)i2);
    }
}

#line 1899
static void
ULONGLONG_bitwise_or(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    register char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((ulonglong *)op)=*((ulonglong *)i1) | *((ulonglong *)i2);
    }
}

#line 1899
static void
BYTE_bitwise_xor(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    register char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((byte *)op)=*((byte *)i1) ^ *((byte *)i2);
    }
}

#line 1899
static void
UBYTE_bitwise_xor(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    register char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((ubyte *)op)=*((ubyte *)i1) ^ *((ubyte *)i2);
    }
}

#line 1899
static void
SHORT_bitwise_xor(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    register char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((short *)op)=*((short *)i1) ^ *((short *)i2);
    }
}

#line 1899
static void
USHORT_bitwise_xor(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    register char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((ushort *)op)=*((ushort *)i1) ^ *((ushort *)i2);
    }
}

#line 1899
static void
INT_bitwise_xor(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    register char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((int *)op)=*((int *)i1) ^ *((int *)i2);
    }
}

#line 1899
static void
UINT_bitwise_xor(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    register char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((uint *)op)=*((uint *)i1) ^ *((uint *)i2);
    }
}

#line 1899
static void
LONG_bitwise_xor(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    register char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((long *)op)=*((long *)i1) ^ *((long *)i2);
    }
}

#line 1899
static void
ULONG_bitwise_xor(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    register char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((ulong *)op)=*((ulong *)i1) ^ *((ulong *)i2);
    }
}

#line 1899
static void
LONGLONG_bitwise_xor(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    register char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((longlong *)op)=*((longlong *)i1) ^ *((longlong *)i2);
    }
}

#line 1899
static void
ULONGLONG_bitwise_xor(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    register char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((ulonglong *)op)=*((ulonglong *)i1) ^ *((ulonglong *)i2);
    }
}

#line 1899
static void
BYTE_left_shift(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    register char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((byte *)op)=*((byte *)i1) << *((byte *)i2);
    }
}

#line 1899
static void
UBYTE_left_shift(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    register char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((ubyte *)op)=*((ubyte *)i1) << *((ubyte *)i2);
    }
}

#line 1899
static void
SHORT_left_shift(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    register char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((short *)op)=*((short *)i1) << *((short *)i2);
    }
}

#line 1899
static void
USHORT_left_shift(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    register char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((ushort *)op)=*((ushort *)i1) << *((ushort *)i2);
    }
}

#line 1899
static void
INT_left_shift(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    register char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((int *)op)=*((int *)i1) << *((int *)i2);
    }
}

#line 1899
static void
UINT_left_shift(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    register char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((uint *)op)=*((uint *)i1) << *((uint *)i2);
    }
}

#line 1899
static void
LONG_left_shift(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    register char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((long *)op)=*((long *)i1) << *((long *)i2);
    }
}

#line 1899
static void
ULONG_left_shift(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    register char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((ulong *)op)=*((ulong *)i1) << *((ulong *)i2);
    }
}

#line 1899
static void
LONGLONG_left_shift(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    register char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((longlong *)op)=*((longlong *)i1) << *((longlong *)i2);
    }
}

#line 1899
static void
ULONGLONG_left_shift(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    register char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((ulonglong *)op)=*((ulonglong *)i1) << *((ulonglong *)i2);
    }
}

#line 1899
static void
BYTE_right_shift(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    register char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((byte *)op)=*((byte *)i1) >> *((byte *)i2);
    }
}

#line 1899
static void
UBYTE_right_shift(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    register char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((ubyte *)op)=*((ubyte *)i1) >> *((ubyte *)i2);
    }
}

#line 1899
static void
SHORT_right_shift(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    register char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((short *)op)=*((short *)i1) >> *((short *)i2);
    }
}

#line 1899
static void
USHORT_right_shift(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    register char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((ushort *)op)=*((ushort *)i1) >> *((ushort *)i2);
    }
}

#line 1899
static void
INT_right_shift(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    register char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((int *)op)=*((int *)i1) >> *((int *)i2);
    }
}

#line 1899
static void
UINT_right_shift(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    register char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((uint *)op)=*((uint *)i1) >> *((uint *)i2);
    }
}

#line 1899
static void
LONG_right_shift(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    register char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((long *)op)=*((long *)i1) >> *((long *)i2);
    }
}

#line 1899
static void
ULONG_right_shift(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    register char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((ulong *)op)=*((ulong *)i1) >> *((ulong *)i2);
    }
}

#line 1899
static void
LONGLONG_right_shift(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    register char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((longlong *)op)=*((longlong *)i1) >> *((longlong *)i2);
    }
}

#line 1899
static void
ULONGLONG_right_shift(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    register char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((ulonglong *)op)=*((ulonglong *)i1) >> *((ulonglong *)i2);
    }
}



#line 1916
static void
BYTE_invert(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0], os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((byte *)op) = ~ *((byte*)i1);
    }
}

#line 1916
static void
UBYTE_invert(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0], os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((ubyte *)op) = ~ *((ubyte*)i1);
    }
}

#line 1916
static void
SHORT_invert(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0], os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((short *)op) = ~ *((short*)i1);
    }
}

#line 1916
static void
USHORT_invert(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0], os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((ushort *)op) = ~ *((ushort*)i1);
    }
}

#line 1916
static void
INT_invert(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0], os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((int *)op) = ~ *((int*)i1);
    }
}

#line 1916
static void
UINT_invert(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0], os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((uint *)op) = ~ *((uint*)i1);
    }
}

#line 1916
static void
LONG_invert(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0], os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((long *)op) = ~ *((long*)i1);
    }
}

#line 1916
static void
ULONG_invert(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0], os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((ulong *)op) = ~ *((ulong*)i1);
    }
}

#line 1916
static void
LONGLONG_invert(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0], os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((longlong *)op) = ~ *((longlong*)i1);
    }
}

#line 1916
static void
ULONGLONG_invert(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0], os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((ulonglong *)op) = ~ *((ulonglong*)i1);
    }
}


static void
BOOL_invert(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0], os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((Bool *)op) = (*((Bool *)i1) ? FALSE : TRUE);
    }
}


#line 1945
static void
BOOL_logical_xor(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=(*((Bool *)i1) || *((Bool *)i2)) && !(*((Bool *)i1) && *((Bool *)i2));
    }
}

#line 1945
static void
BYTE_logical_xor(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=(*((byte *)i1) || *((byte *)i2)) && !(*((byte *)i1) && *((byte *)i2));
    }
}

#line 1945
static void
UBYTE_logical_xor(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=(*((ubyte *)i1) || *((ubyte *)i2)) && !(*((ubyte *)i1) && *((ubyte *)i2));
    }
}

#line 1945
static void
SHORT_logical_xor(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=(*((short *)i1) || *((short *)i2)) && !(*((short *)i1) && *((short *)i2));
    }
}

#line 1945
static void
USHORT_logical_xor(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=(*((ushort *)i1) || *((ushort *)i2)) && !(*((ushort *)i1) && *((ushort *)i2));
    }
}

#line 1945
static void
INT_logical_xor(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=(*((int *)i1) || *((int *)i2)) && !(*((int *)i1) && *((int *)i2));
    }
}

#line 1945
static void
UINT_logical_xor(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=(*((uint *)i1) || *((uint *)i2)) && !(*((uint *)i1) && *((uint *)i2));
    }
}

#line 1945
static void
LONG_logical_xor(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=(*((long *)i1) || *((long *)i2)) && !(*((long *)i1) && *((long *)i2));
    }
}

#line 1945
static void
ULONG_logical_xor(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=(*((ulong *)i1) || *((ulong *)i2)) && !(*((ulong *)i1) && *((ulong *)i2));
    }
}

#line 1945
static void
LONGLONG_logical_xor(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=(*((longlong *)i1) || *((longlong *)i2)) && !(*((longlong *)i1) && *((longlong *)i2));
    }
}

#line 1945
static void
ULONGLONG_logical_xor(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=(*((ulonglong *)i1) || *((ulonglong *)i2)) && !(*((ulonglong *)i1) && *((ulonglong *)i2));
    }
}

#line 1945
static void
FLOAT_logical_xor(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=(*((float *)i1) || *((float *)i2)) && !(*((float *)i1) && *((float *)i2));
    }
}

#line 1945
static void
DOUBLE_logical_xor(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=(*((double *)i1) || *((double *)i2)) && !(*((double *)i1) && *((double *)i2));
    }
}

#line 1945
static void
LONGDOUBLE_logical_xor(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=(*((longdouble *)i1) || *((longdouble *)i2)) && !(*((longdouble *)i1) && *((longdouble *)i2));
    }
}



#line 1962
static void
CFLOAT_logical_xor(char **args, intp *dimensions, intp *steps, void *func)
{
    Bool p1, p2;
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        p1 = ((cfloat *)i1)->real || ((cfloat *)i1)->imag;
        p2 = ((cfloat *)i2)->real || ((cfloat *)i2)->imag;
        *((Bool *)op)= (p1 || p2) && !(p1 && p2);
    }
}

#line 1962
static void
CDOUBLE_logical_xor(char **args, intp *dimensions, intp *steps, void *func)
{
    Bool p1, p2;
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        p1 = ((cdouble *)i1)->real || ((cdouble *)i1)->imag;
        p2 = ((cdouble *)i2)->real || ((cdouble *)i2)->imag;
        *((Bool *)op)= (p1 || p2) && !(p1 && p2);
    }
}

#line 1962
static void
CLONGDOUBLE_logical_xor(char **args, intp *dimensions, intp *steps, void *func)
{
    Bool p1, p2;
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        p1 = ((clongdouble *)i1)->real || ((clongdouble *)i1)->imag;
        p2 = ((clongdouble *)i2)->real || ((clongdouble *)i2)->imag;
        *((Bool *)op)= (p1 || p2) && !(p1 && p2);
    }
}




#line 1986
static void
BOOL_maximum(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((Bool *)i1) > *((Bool *)i2) ? *((Bool *)i1) : *((Bool *)i2);
    }
}

#line 1986
static void
BYTE_maximum(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((byte *)op)=*((byte *)i1) > *((byte *)i2) ? *((byte *)i1) : *((byte *)i2);
    }
}

#line 1986
static void
UBYTE_maximum(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((ubyte *)op)=*((ubyte *)i1) > *((ubyte *)i2) ? *((ubyte *)i1) : *((ubyte *)i2);
    }
}

#line 1986
static void
SHORT_maximum(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((short *)op)=*((short *)i1) > *((short *)i2) ? *((short *)i1) : *((short *)i2);
    }
}

#line 1986
static void
USHORT_maximum(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((ushort *)op)=*((ushort *)i1) > *((ushort *)i2) ? *((ushort *)i1) : *((ushort *)i2);
    }
}

#line 1986
static void
INT_maximum(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((int *)op)=*((int *)i1) > *((int *)i2) ? *((int *)i1) : *((int *)i2);
    }
}

#line 1986
static void
UINT_maximum(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((uint *)op)=*((uint *)i1) > *((uint *)i2) ? *((uint *)i1) : *((uint *)i2);
    }
}

#line 1986
static void
LONG_maximum(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((long *)op)=*((long *)i1) > *((long *)i2) ? *((long *)i1) : *((long *)i2);
    }
}

#line 1986
static void
ULONG_maximum(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((ulong *)op)=*((ulong *)i1) > *((ulong *)i2) ? *((ulong *)i1) : *((ulong *)i2);
    }
}

#line 1986
static void
LONGLONG_maximum(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((longlong *)op)=*((longlong *)i1) > *((longlong *)i2) ? *((longlong *)i1) : *((longlong *)i2);
    }
}

#line 1986
static void
ULONGLONG_maximum(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((ulonglong *)op)=*((ulonglong *)i1) > *((ulonglong *)i2) ? *((ulonglong *)i1) : *((ulonglong *)i2);
    }
}

#line 1986
static void
FLOAT_maximum(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((float *)op)=*((float *)i1) > *((float *)i2) ? *((float *)i1) : *((float *)i2);
    }
}

#line 1986
static void
DOUBLE_maximum(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((double *)op)=*((double *)i1) > *((double *)i2) ? *((double *)i1) : *((double *)i2);
    }
}

#line 1986
static void
LONGDOUBLE_maximum(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((longdouble *)op)=*((longdouble *)i1) > *((longdouble *)i2) ? *((longdouble *)i1) : *((longdouble *)i2);
    }
}

#line 1986
static void
BOOL_minimum(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((Bool *)i1) < *((Bool *)i2) ? *((Bool *)i1) : *((Bool *)i2);
    }
}

#line 1986
static void
BYTE_minimum(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((byte *)op)=*((byte *)i1) < *((byte *)i2) ? *((byte *)i1) : *((byte *)i2);
    }
}

#line 1986
static void
UBYTE_minimum(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((ubyte *)op)=*((ubyte *)i1) < *((ubyte *)i2) ? *((ubyte *)i1) : *((ubyte *)i2);
    }
}

#line 1986
static void
SHORT_minimum(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((short *)op)=*((short *)i1) < *((short *)i2) ? *((short *)i1) : *((short *)i2);
    }
}

#line 1986
static void
USHORT_minimum(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((ushort *)op)=*((ushort *)i1) < *((ushort *)i2) ? *((ushort *)i1) : *((ushort *)i2);
    }
}

#line 1986
static void
INT_minimum(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((int *)op)=*((int *)i1) < *((int *)i2) ? *((int *)i1) : *((int *)i2);
    }
}

#line 1986
static void
UINT_minimum(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((uint *)op)=*((uint *)i1) < *((uint *)i2) ? *((uint *)i1) : *((uint *)i2);
    }
}

#line 1986
static void
LONG_minimum(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((long *)op)=*((long *)i1) < *((long *)i2) ? *((long *)i1) : *((long *)i2);
    }
}

#line 1986
static void
ULONG_minimum(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((ulong *)op)=*((ulong *)i1) < *((ulong *)i2) ? *((ulong *)i1) : *((ulong *)i2);
    }
}

#line 1986
static void
LONGLONG_minimum(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((longlong *)op)=*((longlong *)i1) < *((longlong *)i2) ? *((longlong *)i1) : *((longlong *)i2);
    }
}

#line 1986
static void
ULONGLONG_minimum(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((ulonglong *)op)=*((ulonglong *)i1) < *((ulonglong *)i2) ? *((ulonglong *)i1) : *((ulonglong *)i2);
    }
}

#line 1986
static void
FLOAT_minimum(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((float *)op)=*((float *)i1) < *((float *)i2) ? *((float *)i1) : *((float *)i2);
    }
}

#line 1986
static void
DOUBLE_minimum(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((double *)op)=*((double *)i1) < *((double *)i2) ? *((double *)i1) : *((double *)i2);
    }
}

#line 1986
static void
LONGDOUBLE_minimum(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((longdouble *)op)=*((longdouble *)i1) < *((longdouble *)i2) ? *((longdouble *)i1) : *((longdouble *)i2);
    }
}


#line 2005
static void
CFLOAT_maximum(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    cfloat *i1c, *i2c;
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        i1c = (cfloat *)i1;
        i2c = (cfloat *)i2;
        if ((i1c->real > i2c->real) ||                       \
            ((i1c->real==i2c->real) && (i1c->imag > i2c->imag)))
            memmove(op, i1, sizeof(cfloat));
        else
            memmove(op, i2, sizeof(cfloat));
    }
}

#line 2005
static void
CDOUBLE_maximum(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    cdouble *i1c, *i2c;
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        i1c = (cdouble *)i1;
        i2c = (cdouble *)i2;
        if ((i1c->real > i2c->real) ||                       \
            ((i1c->real==i2c->real) && (i1c->imag > i2c->imag)))
            memmove(op, i1, sizeof(cdouble));
        else
            memmove(op, i2, sizeof(cdouble));
    }
}

#line 2005
static void
CLONGDOUBLE_maximum(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    clongdouble *i1c, *i2c;
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        i1c = (clongdouble *)i1;
        i2c = (clongdouble *)i2;
        if ((i1c->real > i2c->real) ||                       \
            ((i1c->real==i2c->real) && (i1c->imag > i2c->imag)))
            memmove(op, i1, sizeof(clongdouble));
        else
            memmove(op, i2, sizeof(clongdouble));
    }
}

#line 2005
static void
CFLOAT_minimum(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    cfloat *i1c, *i2c;
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        i1c = (cfloat *)i1;
        i2c = (cfloat *)i2;
        if ((i1c->real < i2c->real) ||                       \
            ((i1c->real==i2c->real) && (i1c->imag < i2c->imag)))
            memmove(op, i1, sizeof(cfloat));
        else
            memmove(op, i2, sizeof(cfloat));
    }
}

#line 2005
static void
CDOUBLE_minimum(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    cdouble *i1c, *i2c;
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        i1c = (cdouble *)i1;
        i2c = (cdouble *)i2;
        if ((i1c->real < i2c->real) ||                       \
            ((i1c->real==i2c->real) && (i1c->imag < i2c->imag)))
            memmove(op, i1, sizeof(cdouble));
        else
            memmove(op, i2, sizeof(cdouble));
    }
}

#line 2005
static void
CLONGDOUBLE_minimum(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    clongdouble *i1c, *i2c;
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        i1c = (clongdouble *)i1;
        i2c = (clongdouble *)i2;
        if ((i1c->real < i2c->real) ||                       \
            ((i1c->real==i2c->real) && (i1c->imag < i2c->imag)))
            memmove(op, i1, sizeof(clongdouble));
        else
            memmove(op, i2, sizeof(clongdouble));
    }
}




/*** isinf, isinf, isfinite, signbit ***/
#line 2033
static void
FLOAT_isnan(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is=steps[0], os=steps[1], n=dimensions[0];
    char *ip=args[0], *op=args[1];
    for(i=0; i<n; i++, ip+=is, op+=os) {
        *((Bool *)op) = (Bool) (isnanf(*((float *)ip)) != 0);
    }
}

#line 2033
static void
DOUBLE_isnan(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is=steps[0], os=steps[1], n=dimensions[0];
    char *ip=args[0], *op=args[1];
    for(i=0; i<n; i++, ip+=is, op+=os) {
        *((Bool *)op) = (Bool) (isnan(*((double *)ip)) != 0);
    }
}

#line 2033
static void
LONGDOUBLE_isnan(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is=steps[0], os=steps[1], n=dimensions[0];
    char *ip=args[0], *op=args[1];
    for(i=0; i<n; i++, ip+=is, op+=os) {
        *((Bool *)op) = (Bool) (isnanl(*((longdouble *)ip)) != 0);
    }
}

#line 2033
static void
FLOAT_isinf(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is=steps[0], os=steps[1], n=dimensions[0];
    char *ip=args[0], *op=args[1];
    for(i=0; i<n; i++, ip+=is, op+=os) {
        *((Bool *)op) = (Bool) (isinff(*((float *)ip)) != 0);
    }
}

#line 2033
static void
DOUBLE_isinf(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is=steps[0], os=steps[1], n=dimensions[0];
    char *ip=args[0], *op=args[1];
    for(i=0; i<n; i++, ip+=is, op+=os) {
        *((Bool *)op) = (Bool) (isinf(*((double *)ip)) != 0);
    }
}

#line 2033
static void
LONGDOUBLE_isinf(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is=steps[0], os=steps[1], n=dimensions[0];
    char *ip=args[0], *op=args[1];
    for(i=0; i<n; i++, ip+=is, op+=os) {
        *((Bool *)op) = (Bool) (isinfl(*((longdouble *)ip)) != 0);
    }
}

#line 2033
static void
FLOAT_isfinite(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is=steps[0], os=steps[1], n=dimensions[0];
    char *ip=args[0], *op=args[1];
    for(i=0; i<n; i++, ip+=is, op+=os) {
        *((Bool *)op) = (Bool) (isfinitef(*((float *)ip)) != 0);
    }
}

#line 2033
static void
DOUBLE_isfinite(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is=steps[0], os=steps[1], n=dimensions[0];
    char *ip=args[0], *op=args[1];
    for(i=0; i<n; i++, ip+=is, op+=os) {
        *((Bool *)op) = (Bool) (isfinite(*((double *)ip)) != 0);
    }
}

#line 2033
static void
LONGDOUBLE_isfinite(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is=steps[0], os=steps[1], n=dimensions[0];
    char *ip=args[0], *op=args[1];
    for(i=0; i<n; i++, ip+=is, op+=os) {
        *((Bool *)op) = (Bool) (isfinitel(*((longdouble *)ip)) != 0);
    }
}

#line 2033
static void
FLOAT_signbit(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is=steps[0], os=steps[1], n=dimensions[0];
    char *ip=args[0], *op=args[1];
    for(i=0; i<n; i++, ip+=is, op+=os) {
        *((Bool *)op) = (Bool) (signbitf(*((float *)ip)) != 0);
    }
}

#line 2033
static void
DOUBLE_signbit(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is=steps[0], os=steps[1], n=dimensions[0];
    char *ip=args[0], *op=args[1];
    for(i=0; i<n; i++, ip+=is, op+=os) {
        *((Bool *)op) = (Bool) (signbit(*((double *)ip)) != 0);
    }
}

#line 2033
static void
LONGDOUBLE_signbit(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is=steps[0], os=steps[1], n=dimensions[0];
    char *ip=args[0], *op=args[1];
    for(i=0; i<n; i++, ip+=is, op+=os) {
        *((Bool *)op) = (Bool) (signbitl(*((longdouble *)ip)) != 0);
    }
}



#line 2053
static void
CFLOAT_isnan(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is=steps[0], os=steps[1], n=dimensions[0];
    char *ip=args[0], *op=args[1];
    for(i=0; i<n; i++, ip+=is, op+=os) {
        *((Bool *)op) = isnanf(((float *)ip)[0]) ||        \
            isnanf(((float *)ip)[1]);
    }
}

#line 2053
static void
CDOUBLE_isnan(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is=steps[0], os=steps[1], n=dimensions[0];
    char *ip=args[0], *op=args[1];
    for(i=0; i<n; i++, ip+=is, op+=os) {
        *((Bool *)op) = isnan(((double *)ip)[0]) ||        \
            isnan(((double *)ip)[1]);
    }
}

#line 2053
static void
CLONGDOUBLE_isnan(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is=steps[0], os=steps[1], n=dimensions[0];
    char *ip=args[0], *op=args[1];
    for(i=0; i<n; i++, ip+=is, op+=os) {
        *((Bool *)op) = isnanl(((longdouble *)ip)[0]) ||        \
            isnanl(((longdouble *)ip)[1]);
    }
}

#line 2053
static void
CFLOAT_isinf(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is=steps[0], os=steps[1], n=dimensions[0];
    char *ip=args[0], *op=args[1];
    for(i=0; i<n; i++, ip+=is, op+=os) {
        *((Bool *)op) = isinff(((float *)ip)[0]) ||        \
            isinff(((float *)ip)[1]);
    }
}

#line 2053
static void
CDOUBLE_isinf(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is=steps[0], os=steps[1], n=dimensions[0];
    char *ip=args[0], *op=args[1];
    for(i=0; i<n; i++, ip+=is, op+=os) {
        *((Bool *)op) = isinf(((double *)ip)[0]) ||        \
            isinf(((double *)ip)[1]);
    }
}

#line 2053
static void
CLONGDOUBLE_isinf(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is=steps[0], os=steps[1], n=dimensions[0];
    char *ip=args[0], *op=args[1];
    for(i=0; i<n; i++, ip+=is, op+=os) {
        *((Bool *)op) = isinfl(((longdouble *)ip)[0]) ||        \
            isinfl(((longdouble *)ip)[1]);
    }
}

#line 2053
static void
CFLOAT_isfinite(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is=steps[0], os=steps[1], n=dimensions[0];
    char *ip=args[0], *op=args[1];
    for(i=0; i<n; i++, ip+=is, op+=os) {
        *((Bool *)op) = isfinitef(((float *)ip)[0]) &&        \
            isfinitef(((float *)ip)[1]);
    }
}

#line 2053
static void
CDOUBLE_isfinite(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is=steps[0], os=steps[1], n=dimensions[0];
    char *ip=args[0], *op=args[1];
    for(i=0; i<n; i++, ip+=is, op+=os) {
        *((Bool *)op) = isfinite(((double *)ip)[0]) &&        \
            isfinite(((double *)ip)[1]);
    }
}

#line 2053
static void
CLONGDOUBLE_isfinite(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is=steps[0], os=steps[1], n=dimensions[0];
    char *ip=args[0], *op=args[1];
    for(i=0; i<n; i++, ip+=is, op+=os) {
        *((Bool *)op) = isfinitel(((longdouble *)ip)[0]) &&        \
            isfinitel(((longdouble *)ip)[1]);
    }
}





/****** modf ****/

#line 2076
static void
FLOAT_modf(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os1=steps[1],os2=steps[2],n=dimensions[0];
    char *i1=args[0], *op1=args[1], *op2=args[2];
    float x1, y1, y2;
    for (i=0; i<n; i++, i1+=is1, op1+=os1, op2+=os2) {
        x1 = *((float *)i1);
        y1 = modff(x1, &y2);
        *((float *)op1) = y1;
        *((float *)op2) = y2;
    }
}

#line 2076
static void
DOUBLE_modf(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os1=steps[1],os2=steps[2],n=dimensions[0];
    char *i1=args[0], *op1=args[1], *op2=args[2];
    double x1, y1, y2;
    for (i=0; i<n; i++, i1+=is1, op1+=os1, op2+=os2) {
        x1 = *((double *)i1);
        y1 = modf(x1, &y2);
        *((double *)op1) = y1;
        *((double *)op2) = y2;
    }
}

#line 2076
static void
LONGDOUBLE_modf(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os1=steps[1],os2=steps[2],n=dimensions[0];
    char *i1=args[0], *op1=args[1], *op2=args[2];
    longdouble x1, y1, y2;
    for (i=0; i<n; i++, i1+=is1, op1+=os1, op2+=os2) {
        x1 = *((longdouble *)i1);
        y1 = modfl(x1, &y2);
        *((longdouble *)op1) = y1;
        *((longdouble *)op2) = y2;
    }
}


#define HAVE_DOUBLE_FUNCS
#line 2098
#ifdef HAVE_FLOAT_FUNCS
static void
FLOAT_frexp(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os1=steps[1],os2=steps[2],n=dimensions[0];
    char *i1=args[0], *op1=args[1], *op2=args[2];
    float x1, y1;
    int y2;
    for (i=0; i<n; i++, i1+=is1, op1+=os1, op2+=os2) {
        x1 = *((float *)i1);
        y1 = frexpf(x1, &y2);
        *((float *)op1) = y1;
        *((int *) op2) = y2;
    }
}

static void
FLOAT_ldexp(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2],n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    float x1, y1;
    int x2;
    for (i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        x1 = *((float *)i1);
        x2 = *((int *)i2);
        y1 = ldexpf(x1, x2);
        *((float *)op) = y1;
    }
}
#endif

#line 2098
#ifdef HAVE_DOUBLE_FUNCS
static void
DOUBLE_frexp(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os1=steps[1],os2=steps[2],n=dimensions[0];
    char *i1=args[0], *op1=args[1], *op2=args[2];
    double x1, y1;
    int y2;
    for (i=0; i<n; i++, i1+=is1, op1+=os1, op2+=os2) {
        x1 = *((double *)i1);
        y1 = frexp(x1, &y2);
        *((double *)op1) = y1;
        *((int *) op2) = y2;
    }
}

static void
DOUBLE_ldexp(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2],n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    double x1, y1;
    int x2;
    for (i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        x1 = *((double *)i1);
        x2 = *((int *)i2);
        y1 = ldexp(x1, x2);
        *((double *)op) = y1;
    }
}
#endif

#line 2098
#ifdef HAVE_LONGDOUBLE_FUNCS
static void
LONGDOUBLE_frexp(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os1=steps[1],os2=steps[2],n=dimensions[0];
    char *i1=args[0], *op1=args[1], *op2=args[2];
    longdouble x1, y1;
    int y2;
    for (i=0; i<n; i++, i1+=is1, op1+=os1, op2+=os2) {
        x1 = *((longdouble *)i1);
        y1 = frexpl(x1, &y2);
        *((longdouble *)op1) = y1;
        *((int *) op2) = y2;
    }
}

static void
LONGDOUBLE_ldexp(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2],n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    longdouble x1, y1;
    int x2;
    for (i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        x1 = *((longdouble *)i1);
        x2 = *((int *)i2);
        y1 = ldexpl(x1, x2);
        *((longdouble *)op) = y1;
    }
}
#endif

#undef HAVE_DOUBLE_FUNCS


static PyUFuncGenericFunction frexp_functions[] = {
#ifdef HAVE_FLOAT_FUNCS
    FLOAT_frexp,
#endif
    DOUBLE_frexp
#ifdef HAVE_LONGDOUBLE_FUNCS
    ,LONGDOUBLE_frexp
#endif
};

static void * blank3_data[] = { (void *)NULL, (void *)NULL, (void *)NULL};
static char frexp_signatures[] = {
#ifdef HAVE_FLOAT_FUNCS
    PyArray_FLOAT, PyArray_FLOAT, PyArray_INT,
#endif
    PyArray_DOUBLE, PyArray_DOUBLE, PyArray_INT
#ifdef HAVE_LONGDOUBLE_FUNCS
    ,PyArray_LONGDOUBLE, PyArray_LONGDOUBLE, PyArray_INT
#endif
};


static PyUFuncGenericFunction ldexp_functions[] = {
#ifdef HAVE_FLOAT_FUNCS
    FLOAT_ldexp,
#endif
    DOUBLE_ldexp
#ifdef HAVE_LONGDOUBLE_FUNCS
    ,LONGDOUBLE_ldexp
#endif
};

static char ldexp_signatures[] = {
#ifdef HAVE_FLOAT_FUNCS
    PyArray_FLOAT, PyArray_INT, PyArray_FLOAT,
#endif
    PyArray_DOUBLE, PyArray_INT, PyArray_DOUBLE
#ifdef HAVE_LONGDOUBLE_FUNCS
    ,PyArray_LONGDOUBLE, PyArray_INT, PyArray_LONGDOUBLE
#endif
};



#include "__umath_generated.c"


#include "ufuncobject.c"

#include "__ufunc_api.c"

static double
pinf_init(void)
{
    double mul = 1e10;
    double tmp = 0.0;
    double pinf;

    pinf = mul;
    for (;;) {
        pinf *= mul;
        if (pinf == tmp) break;
        tmp = pinf;
    }
    return pinf;
}

static double
pzero_init(void)
{
    double div = 1e10;
    double tmp = 0.0;
    double pinf;

    pinf = div;
    for (;;) {
        pinf /= div;
        if (pinf == tmp) break;
        tmp = pinf;
    }
    return pinf;
}

/* Less automated additions to the ufuncs */

static void
InitOtherOperators(PyObject *dictionary) {
    PyObject *f;
    int num=1;

#ifdef HAVE_LONGDOUBLE_FUNCS
    num += 1;
#endif
#ifdef HAVE_FLOAT_FUNCS
    num += 1;
#endif
    f = PyUFunc_FromFuncAndData(frexp_functions, blank3_data,
                                frexp_signatures, num,
                                1, 2, PyUFunc_None, "frexp",
                                "Split the number, x, into a normalized"\
                                " fraction (y1) and exponent (y2)",0);
    PyDict_SetItemString(dictionary, "frexp", f);
    Py_DECREF(f);

    f = PyUFunc_FromFuncAndData(ldexp_functions, blank3_data, ldexp_signatures, num,
                                2, 1, PyUFunc_None, "ldexp",
                                "Compute y = x1 * 2**x2.",0);
    PyDict_SetItemString(dictionary, "ldexp", f);
    Py_DECREF(f);
    return;
}

static struct PyMethodDef methods[] = {
    {"frompyfunc", (PyCFunction) ufunc_frompyfunc,
     METH_VARARGS | METH_KEYWORDS, doc_frompyfunc},
    {"seterrobj", (PyCFunction) ufunc_seterr,
     METH_VARARGS, NULL},
    {"geterrobj", (PyCFunction) ufunc_geterr,
     METH_VARARGS, NULL},
    {NULL,          NULL, 0}                /* sentinel */
};

PyMODINIT_FUNC initumath(void) {
    PyObject *m, *d, *s, *s2, *c_api;
    double pinf, pzero, mynan;
    int UFUNC_FLOATING_POINT_SUPPORT = 1;

#ifdef NO_UFUNC_FLOATING_POINT_SUPPORT
    UFUNC_FLOATING_POINT_SUPPORT = 0;
#endif
    /* Create the module and add the functions */
    m = Py_InitModule("umath", methods);

    /* Import the array */
    if (_import_array() < 0) {
        if (!PyErr_Occurred()) {
            PyErr_SetString(PyExc_ImportError,
                            "umath failed: Could not import array core.");
        }
        return;
    }

    /* Initialize the types */
    if (PyType_Ready(&PyUFunc_Type) < 0)
        return;

    /* Add some symbolic constants to the module */
    d = PyModule_GetDict(m);

    c_api = PyCObject_FromVoidPtr((void *)PyUFunc_API, NULL);
    if (PyErr_Occurred()) goto err;
    PyDict_SetItemString(d, "_UFUNC_API", c_api);
    Py_DECREF(c_api);
    if (PyErr_Occurred()) goto err;

    s = PyString_FromString("0.4.0");
    PyDict_SetItemString(d, "__version__", s);
    Py_DECREF(s);

    /* Load the ufunc operators into the array module's namespace */
    InitOperators(d);

    InitOtherOperators(d);

    PyDict_SetItemString(d, "pi", s = PyFloat_FromDouble(M_PI));
    Py_DECREF(s);
    PyDict_SetItemString(d, "e", s = PyFloat_FromDouble(exp(1.0)));
    Py_DECREF(s);

#define ADDCONST(str) PyModule_AddIntConstant(m, #str, UFUNC_##str)
#define ADDSCONST(str) PyModule_AddStringConstant(m, "UFUNC_" #str, UFUNC_##str)

    ADDCONST(ERR_IGNORE);
    ADDCONST(ERR_WARN);
    ADDCONST(ERR_CALL);
    ADDCONST(ERR_RAISE);
    ADDCONST(ERR_PRINT);
    ADDCONST(ERR_LOG);
    ADDCONST(ERR_DEFAULT);
    ADDCONST(ERR_DEFAULT2);

    ADDCONST(SHIFT_DIVIDEBYZERO);
    ADDCONST(SHIFT_OVERFLOW);
    ADDCONST(SHIFT_UNDERFLOW);
    ADDCONST(SHIFT_INVALID);

    ADDCONST(FPE_DIVIDEBYZERO);
    ADDCONST(FPE_OVERFLOW);
    ADDCONST(FPE_UNDERFLOW);
    ADDCONST(FPE_INVALID);

    ADDCONST(FLOATING_POINT_SUPPORT);

    ADDSCONST(PYVALS_NAME);

#undef ADDCONST
#undef ADDSCONST
    PyModule_AddIntConstant(m, "UFUNC_BUFSIZE_DEFAULT", (long)PyArray_BUFSIZE);

    pinf = pinf_init();
    pzero = pzero_init();
    mynan = pinf / pinf;

    PyModule_AddObject(m, "PINF", PyFloat_FromDouble(pinf));
    PyModule_AddObject(m, "NINF", PyFloat_FromDouble(-pinf));
    PyModule_AddObject(m, "PZERO", PyFloat_FromDouble(pzero));
    PyModule_AddObject(m, "NZERO", PyFloat_FromDouble(-pzero));
    PyModule_AddObject(m, "NAN", PyFloat_FromDouble(mynan));

    s = PyDict_GetItemString(d, "conjugate");
    s2 = PyDict_GetItemString(d, "remainder");
    /* Setup the array object's numerical structures with appropriate
       ufuncs in d*/
    PyArray_SetNumericOps(d);

    PyDict_SetItemString(d, "conj", s);
    PyDict_SetItemString(d, "mod", s2);

    return;
 err:
    /* Check for errors */
    if (!PyErr_Occurred()) {
        PyErr_SetString(PyExc_RuntimeError,
                        "cannot load umath module.");
    }
    return;
}

